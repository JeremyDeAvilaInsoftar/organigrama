import {
  CommonModule,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-S5ZZW3UU.js";
import {
  Component,
  ElementRef,
  EventEmitter,
  Injectable,
  Input,
  NgModule,
  NgZone,
  Output,
  ViewChild,
  __spreadProps,
  __spreadValues,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵdefineComponent,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery
} from "./chunk-VE4PK55K.js";

// node_modules/basicprimitives/src/enums.js
var AdviserPlacementType = {
  /**
   * Auto select by layout manager
   */
  Auto: 0,
  /**
   * Left side
   */
  Left: 2,
  /**
   * Right side
   */
  Right: 3
};
var AnnotationType = {
  /**
   * The connector annotation displays a spline between two nodes of the diagram.
   * They are drawn on top and across the existing diagram layout, and they don't affect nodes placement.
   * If available space between nodes is not enough to display connector annotation,
   * then control draws it outside on the side of them.
   */
  Connector: 0,
  /**
   * Shape annotation is a possibility to draw some geometrical shapes over several nodes of the diagram. 
   */
  Shape: 1,
  /**
   * Highlight path annotation traces a path between a given sequence of nodes over existing relation lines in the diagram.
   */
  HighlightPath: 2,
  /**
   * The in-layout label annotation display values over relation lines between nodes. 
   * The control preserves space for labels in the diagram layout so they don't overlap nodes.
   * Label annotations are designed for auto-placement and bundling of connection lines between nodes when needed.
   */
  Label: 3,
  /**
   * The background annotation highlights nodes via drawing the rectangular shape in the node's background.
   * If the same style annotations of neighboring nodes overlap, control merges them into one continuous polygon geometry. 
   */
  Background: 4,
  /**
   * Level annotation highlights same level nodes of the diagram via drawing continuous rectangular shape 
   * from side to side in their background. Level has optional title on the side of the diagram view area.
   * Title may be placed inside or outside of the diagram. If it is placed inside, it is drawn in the 
   * background and does not occupy space. 
   */
  Level: 5
};
var ChildrenPlacementType = {
  /**
   * Auto: This mode lets you set nodes layout at the component level and then redefine it for individual nodes if needed.
   */
  Auto: 0,
  /**
   * Vertical layout
   */
  Vertical: 1,
  /**
   * Horizontal layout
   */
  Horizontal: 2,
  /**
   * Matrix formation of the nodes
   */
  Matrix: 3
};
var Colors = {
  AliceBlue: "#f0f8ff",
  AntiqueWhite: "#faebd7",
  Aqua: "#00ffff",
  Aquamarine: "#7fffd4",
  Azure: "#f0ffff",
  Beige: "#f5f5dc",
  Bisque: "#ffe4c4",
  Black: "#000000",
  BlanchedAlmond: "#ffebcd",
  Blue: "#0000ff",
  BlueViolet: "#8a2be2",
  Brown: "#a52a2a",
  BurlyWood: "#deb887",
  Bronze: "#cd7f32",
  CadetBlue: "#5f9ea0",
  ChartReuse: "#7fff00",
  Chocolate: "#d2691e",
  Coral: "#ff7f50",
  CornflowerBlue: "#6495ed",
  Cornsilk: "#fff8dc",
  Crimson: "#dc143c",
  Cyan: "#00ffff",
  DarkBlue: "#00008b",
  DarkCyan: "#008b8b",
  DarkGoldenrod: "#b8860b",
  DarkGray: "#a9a9a9",
  DarkGreen: "#006400",
  DarkKhaki: "#bdb76b",
  DarkMagenta: "#8b008b",
  DarkOliveGreen: "#556b2f",
  Darkorange: "#ff8c00",
  DarkOrchid: "#9932cc",
  DarkRed: "#8b0000",
  DarkSalmon: "#e9967a",
  DarkSeaGreen: "#8fbc8f",
  DarkSlateBlue: "#483d8b",
  DarkSlateGray: "#2f4f4f",
  DarkTurquoise: "#00ced1",
  DarkViolet: "#9400d3",
  DeepPink: "#ff1493",
  DeepSkyBlue: "#00bfff",
  DimGray: "#696969",
  DodgerBlue: "#1e90ff",
  FireBrick: "#b22222",
  FloralWhite: "#fffaf0",
  ForestGreen: "#228b22",
  Fuchsia: "#ff00ff",
  Gainsboro: "#dcdcdc",
  GhostWhite: "#f8f8ff",
  Gold: "#ffd700",
  Goldenrod: "#daa520",
  Gray: "#808080",
  Green: "#008000",
  GreenYellow: "#adff2f",
  Honeydew: "#f0fff0",
  Hotpink: "#ff69b4",
  IndianRed: "#cd5c5c",
  Indigo: "#4b0082",
  Ivory: "#fffff0",
  Khaki: "#f0e68c",
  Lavender: "#e6e6fa",
  LavenderBlush: "#fff0f5",
  Lawngreen: "#7cfc00",
  Lemonchiffon: "#fffacd",
  LightBlue: "#add8e6",
  LightCoral: "#f08080",
  LightCyan: "#e0ffff",
  LightGoldenrodYellow: "#fafad2",
  LightGray: "#d3d3d3",
  LightGreen: "#90ee90",
  LightPink: "#ffb6c1",
  LightSalmon: "#ffa07a",
  LightSeaGreen: "#20b2aa",
  LightSkyBlue: "#87cefa",
  LightSlateGray: "#778899",
  LightSteelBlue: "#b0c4de",
  LightYellow: "#ffffe0",
  Lime: "#00ff00",
  Limegreen: "#32cd32",
  Linen: "#faf0e6",
  Magenta: "#ff00ff",
  Maroon: "#800000",
  MediumAquamarine: "#66cdaa",
  MediumBlue: "#0000cd",
  MediumOrchid: "#ba55d3",
  MediumPurple: "#9370d8",
  MediumSeaGreen: "#3cb371",
  MediumSlateBlue: "#7b68ee",
  MediumSpringGreen: "#00fa9a",
  MediumTurquoise: "#48d1cc",
  MediumVioletRed: "#c71585",
  MidnightBlue: "#191970",
  MintCream: "#f5fffa",
  MistyRose: "#ffe4e1",
  Moccasin: "#ffe4b5",
  NavajoWhite: "#ffdead",
  Navy: "#000080",
  Oldlace: "#fdf5e6",
  Olive: "#808000",
  Olivedrab: "#6b8e23",
  Orange: "#ffa500",
  OrangeRed: "#ff4500",
  Orchid: "#da70d6",
  PaleGoldenRod: "#eee8aa",
  PaleGreen: "#98fb98",
  PaleTurquoise: "#afeeee",
  PaleVioletRed: "#d87093",
  Papayawhip: "#ffefd5",
  Peachpuff: "#ffdab9",
  Peru: "#cd853f",
  Pink: "#ffc0cb",
  Plum: "#dda0dd",
  PowderBlue: "#b0e0e6",
  Purple: "#800080",
  Red: "#ff0000",
  RosyBrown: "#bc8f8f",
  RoyalBlue: "#4169e1",
  SaddleBrown: "#8b4513",
  Salmon: "#fa8072",
  SandyBrown: "#f4a460",
  SeaGreen: "#2e8b57",
  Seashell: "#fff5ee",
  Sienna: "#a0522d",
  Silver: "#c0c0c0",
  SkyBlue: "#87ceeb",
  SlateBlue: "#6a5acd",
  SlateGray: "#708090",
  Snow: "#fffafa",
  SpringGreen: "#00ff7f",
  SteelBlue: "#4682b4",
  Tan: "#d2b48c",
  Teal: "#008080",
  Thistle: "#d8bfd8",
  Tomato: "#ff6347",
  Turquoise: "#40e0d0",
  Violet: "#ee82ee",
  Wheat: "#f5deb3",
  White: "#ffffff",
  WhiteSmoke: "#f5f5f5",
  Yellow: "#ffff00",
  YellowGreen: "#9acd32"
};
var ConnectorLabelPlacementType = {
  From: 0,
  Between: 1,
  To: 2
};
var ConnectorPlacementType = {
  /**
   * Places connector annotation in the way that it does not overlap underlying diagram connector lines.
   * If nodes are close to each other and gap between them cannot fit annotation, then 
   * it will be drawn on the side of the nodes, so it will have enough space for arrow and label.
   */
  Offbeat: 0,
  /**
   * Straight line annotation between nodes. This annotation mode provides basic conflict resolution between annotations
   * overlapping each other. If two or more straight annotations overlap each other then layout engine will 
   * add extra offset to them, so they will be drawn in parallel to each other.
   */
  Straight: 1
};
var ConnectorShapeType = {
  /**
   * Single line with one arrow
   */
  OneWay: 0,
  /**
   * Two parallel lines with single arrows
   */
  TwoWay: 1,
  /**
   * Single line with 2 arrows.
   */
  BothWay: 2
};
var ConnectorStyleType = {
  Extra: 0,
  Regular: 1,
  Highlight: 2
};
var ConnectorType = {
  /**
   * Orthogonal connection lines
   */
  Squared: 0,
  /**
   * Angular direct node to node connection lines
   */
  Angular: 1,
  /**
   * Curved direct node to node connection lines
   */
  Curved: 2
};
var ElbowType = {
  /**
   * No elbow
   */
  None: 0,
  /**
   * Dot marker at the intersection
   */
  Dot: 1,
  /**
   * Bevel elbow
   */
  Bevel: 2,
  /**
   * Round elbow
   */
  Round: 3
};
var Enabled = {
  /**
   * Option state is auto defined.
   */
  Auto: 0,
  /**
   * Enabled
   */
  True: 1,
  /**
   * Disabled
   */
  False: 2
};
var GroupByType = {
  None: 0,
  Parents: 1,
  Children: 2
};
var HorizontalAlignmentType = {
  Center: 0,
  Left: 1,
  Right: 2
};
var ItemType = {
  /**
   * The regular type places node below parent.
   */
  Regular: 0,
  /**
   * The assistant type places node at the row on the side of the connection line going from parent to its children.
   */
  Assistant: 1,
  /**
   * The sub-assistant node type is a variation of the assistant node type. 
   * The sub-assistant places node at the row on the side of the connection line
   * going from parent to its children. The connection line goes out of the top side of the node.
   */
  SubAssistant: 4,
  /**
   * The adviser type places node on the right or left side of the parent.
   */
  Adviser: 2,
  /**
   * The sub-adviser type places node on the right or left side of the parent. 
   * The connection line goes out of the top side of the sub-adviser node.
   */
  SubAdviser: 5,
  /**
   * The general partner type is an imitation of multiple inheritances in the organizational chart hierarchy.
   * The general-partner node is drawn side by side with its logical parent, and control places
   * regular children below them, so they visually look like parents. Another layout specifics
   * of the general partner is that it is connected to its logical parent's parent.
   * So visually, it becomes an immediate child of its grandparent.
   */
  GeneralPartner: 6,
  /**
   * The limited partner is a variation of the general partner.
   * The only difference is that it is not connected to its logical grandparent.
   */
  LimitedPartner: 7,
  /**
   * The adviser partner is a variation of the limited partner. 
   * The difference is that it has an extra connection line to its logical parent.
   */
  AdviserPartner: 8
};
var LabelType = {
  Regular: 0,
  Dummy: 1,
  Fixed: 2,
  None: 3
};
var Layers = {
  LevelAnnotation: 1,
  BackgroundAnnotation: 2,
  BackgroundAnnotations: 3,
  BackgroundConnectorAnnotation: 4,
  BackgroundHighlightPathAnnotations: 5,
  Connector: 6,
  ForegroundHighlightPathAnnotations: 7,
  Highlight: 8,
  Marker: 9,
  Label: 10,
  Cursor: 11,
  Item: 12,
  ForegroundAnnotations: 13,
  ForegroundConnectorAnnotation: 14,
  Annotation: 15,
  Controls: 16
};
var LineType = {
  Solid: 0,
  Dotted: 1,
  Dashed: 2
};
var NavigationMode = {
  /**
   * Everything is on.
   */
  Default: 0,
  /**
   * Cursor selection only without highlight. 
   */
  CursorOnly: 1,
  /**
   * Mouse over feedback only
   */
  HighlightOnly: 3,
  /**
   * No interactivity
   */
  Inactive: 2
};
var NeighboursSelectionMode = {
  /**
   * Selects parents and children of the cursor item
   */
  ParentsAndChildren: 0,
  /**
   * Selects parents, children, and siblings of the cursor item.
   */
  ParentsChildrenSiblingsAndSpouses: 1
};
var OrientationType = {
  Top: 0,
  Bottom: 1,
  Left: 2,
  Right: 3,
  None: 4
};
var PageFitMode = {
  /**
   * Disabled. All nodes are being rendered using their templates.
   */
  None: 0,
  /**
   * Fits diagram into the view width, so it has no horizontal scrollbar.
   */
  PageWidth: 1,
  /**
   * Fits diagram into the view hight, so it has no vertical scrollbar.
   */
  PageHeight: 2,
  /**
   * Fits diagram into the view so it has no scroll bars.
   */
  FitToPage: 3,
  /**
   * This is opposite mode to auto fit. In this mode diagram controls its size, it sets its size to fit all nodes and render them full size using templates.
   */
  AutoSize: 5,
  /**
   * Renders all nodes as markers regardless of available screen space. Control selects and renders full size cursor, its neighbours and selected nodes only.
   * Don't forget to disable selection path as well, so nodes from cursor up to the root are not selected.
   */
  SelectionOnly: 6
};
var PlacementType = {
  /**
   * Defined by other control options.
   */
  Auto: 0,
  TopLeft: 8,
  Top: 1,
  TopRight: 2,
  RightTop: 11,
  Right: 3,
  RightBottom: 12,
  BottomRight: 4,
  Bottom: 5,
  BottomLeft: 6,
  LeftBottom: 10,
  Left: 7,
  LeftTop: 9
};
var RenderingMode = {
  /**
   * Template is just created.
   */
  Create: 0,
  /**
   * Template is reused and update is needed.
   */
  Update: 1
};
var SegmentType = {
  Line: 0,
  Move: 1,
  QuadraticArc: 2,
  CubicArc: 3,
  Dot: 4
};
var SelectionPathMode = {
  /**
   * No selection path
   */
  None: 0,
  /**
   * Selects cursor node parents up to the root are renders them full size regardless of available space.
   */
  FullStack: 1
};
var ShapeType = {
  Rectangle: 0,
  Oval: 1,
  Triangle: 2,
  CrossOut: 3,
  Circle: 4,
  Rhombus: 5,
  Wedge: 7,
  FramedOval: 8,
  FramedTriangle: 9,
  FramedWedge: 10,
  FramedRhombus: 11,
  None: 6
};
var SideFlag = {
  Top: 1,
  Right: 2,
  Bottom: 4,
  Left: 8
};
var TextOrientationType = {
  /**
   * Regular horizontal text
   */
  Horizontal: 0,
  /**
   * Rotate text left for 90 degree.
   */
  RotateLeft: 1,
  /**
   * Rotate text right for 90 degree.
   */
  RotateRight: 2,
  /**
   * Depends on other options.
   */
  Auto: 3
};
var VectorRelationType = {
  None: 0,
  Null: 1,
  Collinear: 2,
  Opposite: 3
};
var VerticalAlignmentType = {
  Top: 0,
  Middle: 1,
  Bottom: 2
};
var Visibility = {
  /**
   * Selects best visibility mode.
   */
  Auto: 0,
  /**
   * Regular template based diagram nodes
   */
  Normal: 1,
  /**
   * Diagram draws nodes in form of markers
   */
  Dot: 2,
  /**
   * Diagram only draws connection lines and hides actual nodes.
   */
  Line: 3,
  /**
   * Makes node invisible in layout. If node has no parents then 
   * its connection lines are hidden as well.
   * 
   * @ignore
   */
  Invisible: 4
};
var ZOrderType = {
  /**
   * Depends on annotation type.
   */
  Auto: 0,
  /**
   * Background
   */
  Background: 1,
  /**
   * Foreground
   */
  Foreground: 2
};

// node_modules/basicprimitives/src/common/index.js
function isNullOrEmpty(value) {
  var result = true, string;
  if (value !== void 0 && value !== null) {
    string = value.toString();
    if (string.length > 0) {
      result = false;
    }
  }
  return result;
}
function loop(thisArg, items, onItem) {
  var key, index, len;
  if (onItem != null) {
    if (Array.isArray(items)) {
      for (index = 0, len = items.length; index < len; index += 1) {
        if (onItem.call(thisArg, index, items[index])) {
          break;
        }
      }
    } else {
      for (key in items) {
        if (items.hasOwnProperty(key)) {
          if (onItem.call(thisArg, key, items[key])) {
            break;
          }
        }
      }
    }
  }
}
function splitCamelCaseName(name2) {
  var result = [];
  var word = "";
  for (var i = 0; i < name2.length; i += 1) {
    var c = name2[i];
    if (c >= "A" && c <= "Z") {
      if (word !== "") {
        result.push(word);
      }
      word = c;
    } else {
      word += c;
    }
  }
  if (word !== "") {
    result.push(word);
  }
  return result;
}
function isObject(item) {
  return item !== null && typeof item == "object";
}
function isEmptyObject(item) {
  var key;
  for (key in item) {
    if (item.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function cloneObject(source, isShallow) {
  var result;
  if (source === null) {
    result = null;
  } else if (Array.isArray(source)) {
    if (isShallow) {
      result = source.slice(0);
    } else {
      result = [];
      for (var index = 0, len = source.length; index < len; index += 1) {
        result.push(cloneObject(source[index], isShallow));
      }
    }
  } else {
    switch (typeof source) {
      case "object":
        result = {};
        for (var property in source) {
          if (source.hasOwnProperty(property)) {
            if (isShallow) {
              result[property] = source[property];
            } else {
              result[property] = cloneObject(source[property], isShallow);
            }
          }
        }
        break;
      default:
        result = source;
        break;
    }
  }
  return result;
}
function mergeObjects(destination, source) {
  for (var index = 1; index < arguments.length; index += 1) {
    var src = arguments[index];
    if (src !== void 0) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          destination[key] = src[key];
        }
      }
    }
  }
  return destination;
}
function getHashCode(value) {
  var hash = 0, character, i;
  if (value.length > 0) {
    for (i = 0; i < value.length; i += 1) {
      character = value.charCodeAt(i);
      hash = (hash << 5) - hash + character;
      hash = hash & hash;
    }
  }
  return hash;
}

// node_modules/basicprimitives/src/common/colors.js
var ColorHexs;
function getColorHexValue(color) {
  var digits, red, green, blue, rgb, colorIndex, colorKey;
  if (color.substr(0, 1) === "#") {
    return color;
  }
  digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);
  if (digits !== null && digits.length > 0) {
    red = parseInt(digits[2], 10);
    green = parseInt(digits[3], 10);
    blue = parseInt(digits[4], 10);
    rgb = (red << 16 | green << 8 | blue).toString(16);
    return digits[1] + "000000".substr(0, 6 - rgb.length) + rgb;
  }
  if (ColorHexs === void 0) {
    ColorHexs = {};
    colorIndex = 0;
    for (colorKey in Colors) {
      if (Colors.hasOwnProperty(colorKey)) {
        ColorHexs[colorKey.toUpperCase()] = Colors[colorKey];
        colorIndex += 1;
      }
    }
  }
  return ColorHexs[color.toUpperCase()];
}
function getRed(color) {
  if (color.substr(0, 1) === "#" && color.length === 7) {
    return parseInt(color.substr(1, 2), 16);
  }
  return null;
}
var highestContrasts = {};
function highestContrast(baseColor, firstColor, secondColor) {
  var result = firstColor, key = baseColor + "," + firstColor + "," + secondColor;
  if (highestContrasts.hasOwnProperty(key)) {
    result = highestContrasts[key];
  } else {
    if (luminosity(firstColor, baseColor) < luminosity(secondColor, baseColor)) {
      result = secondColor;
    }
    highestContrasts[key] = result;
  }
  return result;
}
function luminosity(firstColor, secondColor) {
  var result, first = getColorHexValue(firstColor), second = getColorHexValue(secondColor), firstLuminosity = 0.2126 * Math.pow(getRed(first) / 255, 2.2) + 0.7152 * Math.pow(getRed(first) / 255, 2.2) + 0.0722 * Math.pow(getRed(first) / 255, 2.2), secondLuminosity = 0.2126 * Math.pow(getRed(second) / 255, 2.2) + 0.7152 * Math.pow(getRed(second) / 255, 2.2) + 0.0722 * Math.pow(getRed(second) / 255, 2.2);
  if (firstLuminosity > secondLuminosity) {
    result = (firstLuminosity + 0.05) / (secondLuminosity + 0.05);
  } else {
    result = (secondLuminosity + 0.05) / (firstLuminosity + 0.05);
  }
  return result;
}

// node_modules/basicprimitives/src/graphics/structs/Size.js
function Size(arg0, arg1) {
  this.width = 0;
  this.height = 0;
  switch (arguments.length) {
    case 1:
      this.width = arg0.width;
      this.height = arg0.height;
      break;
    case 2:
      this.width = arg0;
      this.height = arg1;
      break;
    default:
      break;
  }
}
Size.prototype.isEmpty = function() {
  return this.width === null || this.height === null || this.width < 0 || this.height < 0;
};
Size.prototype.invert = function() {
  var width = this.width;
  this.width = this.height;
  this.height = width;
  return this;
};
Size.prototype.scale = function(scale) {
  this.width = this.width * scale;
  this.height = this.height * scale;
  return this;
};
Size.prototype.space = function() {
  return this.width * this.height;
};
Size.prototype.getCSS = function(units) {
  units = units !== void 0 ? units : "px";
  var result = {
    width: this.width + units,
    height: this.height + units
  };
  return result;
};
Size.prototype.cropBySize = function(size) {
  this.width = Math.min(this.width, size.width);
  this.height = Math.min(this.height, size.height);
  return this;
};
Size.prototype.maxSize = function(size) {
  this.width = Math.max(this.width, size.width);
  this.height = Math.max(this.height, size.height);
  return this;
};
Size.prototype.addThickness = function(thickness) {
  this.width = Math.max(0, this.width + thickness.left + thickness.right);
  this.height = Math.max(0, this.height + thickness.top + thickness.bottom);
  return this;
};
Size.prototype.removeThickness = function(thickness) {
  this.width = Math.max(0, this.width - thickness.left - thickness.right);
  this.height = Math.max(0, this.height - thickness.top - thickness.bottom);
  return this;
};
Size.prototype.validate = function() {
  if (isNaN(this.width) || isNaN(this.height)) {
    throw "Invalid size.";
  }
};

// node_modules/basicprimitives/src/graphics/dom.js
function getFixOfPixelAlignment(element) {
  var elementClientRectangle = element.getBoundingClientRect(), top = elementClientRectangle.top + document.body.scrollTop, left = elementClientRectangle.left + document.body.scrollLeft;
  return new Size(-left + Math.floor(left), -top + Math.floor(top));
}
function getElementOffset(element) {
  var rect = element.getBoundingClientRect();
  var ownerDocument = element.ownerDocument;
  var documentElement = ownerDocument.documentElement;
  return {
    top: rect.top + window.pageYOffset - documentElement.clientTop,
    left: rect.left + window.pageXOffset - documentElement.clientLeft
  };
}
function getInnerSize(element) {
  var size = window.getComputedStyle(element);
  return new Size(parseInt(size.width, 10), parseInt(size.height, 10));
}

// node_modules/basicprimitives/src/common/jsonml-html.js
var JsonML = {};
if (typeof document !== "undefined") {
  (function(JsonML2, document2) {
    "use strict";
    var ATTR_MAP = {
      "accesskey": "accessKey",
      "bgcolor": "bgColor",
      "cellpadding": "cellPadding",
      "cellspacing": "cellSpacing",
      "checked": "defaultChecked",
      "class": "className",
      "colspan": "colSpan",
      "contenteditable": "contentEditable",
      "defaultchecked": "defaultChecked",
      "for": "htmlFor",
      "formnovalidate": "formNoValidate",
      "hidefocus": "hideFocus",
      "ismap": "isMap",
      "maxlength": "maxLength",
      "novalidate": "noValidate",
      "readonly": "readOnly",
      "rowspan": "rowSpan",
      "spellcheck": "spellCheck",
      "tabindex": "tabIndex",
      "usemap": "useMap",
      "willvalidate": "willValidate"
      // can add more attributes here as needed
    };
    var ATTR_DUP = {
      "enctype": "encoding",
      "onscroll": "DOMMouseScroll"
      // can add more attributes here as needed
    };
    var ATTR_DOM = {
      "autocapitalize": 1,
      "autocomplete": 1,
      "autocorrect": 1
      // can add more attributes here as needed
    };
    var ATTR_BOOL = {
      "async": 1,
      "autofocus": 1,
      "checked": 1,
      "defaultchecked": 1,
      "defer": 1,
      "disabled": 1,
      "formnovalidate": 1,
      "hidden": 1,
      "indeterminate": 1,
      "ismap": 1,
      "multiple": 1,
      "novalidate": 1,
      "readonly": 1,
      "required": 1,
      "spellcheck": 1,
      "willvalidate": 1
      // can add more attributes here as needed
    };
    var LEADING = /^[\r\n]+/;
    var TRAILING = /[\r\n]+$/;
    var NUL = 0;
    var FUN = 1;
    var ARY = 2;
    var OBJ = 3;
    var VAL = 4;
    var RAW = 5;
    function Markup(value) {
      this.value = value;
    }
    Markup.prototype.toString = function() {
      return this.value;
    };
    JsonML2.raw = function(value) {
      return new Markup(value);
    };
    var isMarkup = JsonML2.isRaw = function(value) {
      return value instanceof Markup;
    };
    var isArray = Array.isArray || function(val) {
      return val instanceof Array;
    };
    function isFunction(val) {
      return typeof val === "function";
    }
    function getType(val) {
      switch (typeof val) {
        case "object":
          return !val ? NUL : isArray(val) ? ARY : isMarkup(val) ? RAW : val instanceof Date ? VAL : OBJ;
        case "function":
          return FUN;
        case "undefined":
          return NUL;
        default:
          return VAL;
      }
    }
    var createElement = function(tag) {
      if (!tag) {
        if (document2.createDocumentFragment) {
          return document2.createDocumentFragment();
        }
        tag = "";
      } else if (tag.charAt(0) === "!") {
        return document2.createComment(tag === "!" ? "" : tag.substr(1) + " ");
      }
      if (tag.toLowerCase() === "style" && document2.createStyleSheet) {
        return document2.createStyleSheet();
      }
      return document2.createElement(tag);
    };
    var addHandler = function(elem, name2, handler) {
      if (name2.substr(0, 2) === "on") {
        name2 = name2.substr(2);
      }
      switch (typeof handler) {
        case "function":
          if (elem.addEventListener) {
            elem.addEventListener(name2, handler, false);
          } else if (elem.attachEvent && getType(elem[name2]) !== NUL) {
            elem.attachEvent("on" + name2, handler);
          } else {
            var old = elem["on" + name2] || elem[name2];
            elem["on" + name2] = elem[name2] = !isFunction(old) ? handler : function(e) {
              return old.call(this, e) !== false && handler.call(this, e) !== false;
            };
          }
          break;
        case "string":
          elem["on" + name2] = new Function("event", handler);
          break;
      }
    };
    var applyStyles = JsonML2.applyStyles = function(elem, css) {
      for (var key in css) {
        if (css.hasOwnProperty(key)) {
          elem.style[key] = css[key];
        }
      }
      return elem;
    };
    var addAttributes = function(elem, attr) {
      if (attr.name && document2.attachEvent && !elem.parentNode) {
        try {
          var alt = createElement("<" + elem.tagName + ' name="' + attr.name + '">');
          if (elem.tagName === alt.tagName) {
            elem = alt;
          }
        } catch (ex) {
        }
      }
      for (var name2 in attr) {
        if (attr.hasOwnProperty(name2)) {
          var value = attr[name2], type = getType(value);
          if (name2) {
            if (type === NUL) {
              value = "";
              type = VAL;
            }
            name2 = ATTR_MAP[name2.toLowerCase()] || name2;
            if (name2 === "$") {
              value(elem);
            } else if (name2 == "className") {
              if (isArray(value)) {
                for (var index = 0; index < value.length; index += 1) {
                  elem.className += " " + value[index];
                }
              } else {
                elem.className += " " + value;
              }
            } else if (name2 === "style") {
              if (getType(elem.style.cssText) !== NUL) {
                if (typeof value == "string") {
                  elem.style.cssText = value;
                } else {
                  applyStyles(elem, value);
                }
              } else {
                elem.style = value;
              }
            } else if (name2.substr(0, 2) === "on") {
              addHandler(elem, name2, value);
              name2 = ATTR_DUP[name2];
              if (name2) {
                addHandler(elem, name2, value);
              }
            } else if (!ATTR_DOM[name2.toLowerCase()] && (type !== VAL || name2.charAt(0) === "$" || getType(elem[name2]) !== NUL || getType(elem[ATTR_DUP[name2]]) !== NUL)) {
              elem[name2] = value;
              name2 = ATTR_DUP[name2];
              if (name2) {
                elem[name2] = value;
              }
            } else if (ATTR_BOOL[name2.toLowerCase()]) {
              if (value) {
                elem.setAttribute(name2, name2);
                name2 = ATTR_DUP[name2];
                if (name2) {
                  elem.setAttribute(name2, name2);
                }
              }
            } else {
              elem.setAttribute(name2, value);
              name2 = ATTR_DUP[name2];
              if (name2) {
                elem.setAttribute(name2, value);
              }
            }
          }
        }
      }
      return elem;
    };
    var appendDOM = JsonML2.appendDOM = function(elem, child) {
      if (child) {
        var tag = (elem.tagName || "").toLowerCase();
        if (elem.nodeType === 8) {
          if (child.nodeType === 3) {
            elem.nodeValue += child.nodeValue;
          }
        } else if (tag === "table" && elem.tBodies) {
          if (!child.tagName) {
            if (child.nodeType === 11) {
              while (child.firstChild) {
                appendDOM(elem, child.removeChild(child.firstChild));
              }
            }
            return;
          }
          var childTag = child.tagName.toLowerCase();
          if (childTag && childTag !== "tbody" && childTag !== "thead") {
            var tBody = elem.tBodies.length > 0 ? elem.tBodies[elem.tBodies.length - 1] : null;
            if (!tBody) {
              tBody = createElement(childTag === "th" ? "thead" : "tbody");
              elem.appendChild(tBody);
            }
            tBody.appendChild(child);
          } else if (elem.canHaveChildren !== false) {
            elem.appendChild(child);
          }
        } else if (tag === "style" && document2.createStyleSheet) {
          elem.cssText = child;
        } else if (elem.canHaveChildren !== false) {
          elem.appendChild(child);
        } else if (tag === "object" && child.tagName && child.tagName.toLowerCase() === "param") {
          try {
            elem.appendChild(child);
          } catch (ex1) {
          }
          try {
            if (elem.object) {
              elem.object[child.name] = child.value;
            }
          } catch (ex2) {
          }
        }
      }
    };
    var isWhitespace = function(node) {
      return !!node && node.nodeType === 3 && (!node.nodeValue || !/\S/.exec(node.nodeValue));
    };
    var trimPattern = function(node, pattern) {
      if (!!node && node.nodeType === 3 && pattern.exec(node.nodeValue)) {
        node.nodeValue = node.nodeValue.replace(pattern, "");
      }
    };
    var trimWhitespace = function(elem) {
      if (elem) {
        while (isWhitespace(elem.firstChild)) {
          elem.removeChild(elem.firstChild);
        }
        trimPattern(elem.firstChild, LEADING);
        while (isWhitespace(elem.lastChild)) {
          elem.removeChild(elem.lastChild);
        }
        trimPattern(elem.lastChild, TRAILING);
      }
    };
    var toDOM = function(value) {
      var wrapper = createElement("div");
      wrapper.innerHTML = "" + value;
      trimWhitespace(wrapper);
      if (wrapper.childNodes.length === 1) {
        return wrapper.firstChild;
      }
      var frag = createElement("");
      while (wrapper.firstChild) {
        frag.appendChild(wrapper.firstChild);
      }
      return frag;
    };
    var onError = function(ex) {
      return document2.createTextNode("[" + ex + "]");
    };
    JsonML2.onerror = null;
    var patch = JsonML2.patch = function(elem, jml, filter) {
      for (var i = 1; i < jml.length; i += 1) {
        if (isArray(jml[i]) || "string" === typeof jml[i]) {
          appendDOM(elem, toHTML(jml[i], filter));
        } else if (isMarkup(jml[i])) {
          appendDOM(elem, toDOM(jml[i].value));
        } else if ("object" === typeof jml[i] && jml[i] !== null && elem.nodeType === 1) {
          elem = addAttributes(elem, jml[i]);
        }
      }
      return elem;
    };
    var toHTML = JsonML2.toHTML = function(jml, filter) {
      try {
        if (!jml) {
          return null;
        }
        if ("string" === typeof jml) {
          return document2.createTextNode(jml);
        }
        if (isMarkup(jml)) {
          return toDOM(jml.value);
        }
        if (!isArray(jml) || "string" !== typeof jml[0]) {
          throw new SyntaxError("invalid JsonML");
        }
        var tagName = jml[0];
        if (!tagName) {
          var frag = createElement("");
          for (var i = 1; i < jml.length; i += 1) {
            appendDOM(frag, toHTML(jml[i], filter));
          }
          trimWhitespace(frag);
          if (frag.childNodes.length === 1) {
            return frag.firstChild;
          }
          return frag;
        }
        if (tagName.toLowerCase() === "style" && document2.createStyleSheet) {
          patch(document2.createStyleSheet(), jml, filter);
          return null;
        }
        var elem = patch(createElement(tagName), jml, filter);
        trimWhitespace(elem);
        return elem && isFunction(filter) ? filter(elem) : elem;
      } catch (ex) {
        try {
          var err = isFunction(JsonML2.onerror) ? JsonML2.onerror : onError;
          return err(ex, jml, filter);
        } catch (ex2) {
          return document2.createTextNode("[" + ex2 + "]");
        }
      }
    };
    JsonML2.toHTMLText = function(jml, filter) {
      var elem = toHTML(jml, filter);
      if (elem.outerHTML) {
        return elem.outerHTML;
      }
      var parent = createElement("div");
      parent.appendChild(elem);
      var html = parent.innerHTML;
      parent.removeChild(elem);
      return html;
    };
  })(JsonML, document);
}
var jsonml_html_default = JsonML;

// node_modules/basicprimitives/src/graphics/structs/Point.js
function Point(arg0, arg1) {
  this.x = null;
  this.y = null;
  this.context = null;
  switch (arguments.length) {
    case 1:
      this.x = arg0.x;
      this.y = arg0.y;
      this.context = arg0.context;
      break;
    case 2:
      this.x = arg0;
      this.y = arg1;
      break;
    default:
      break;
  }
}
Point.prototype.scale = function(scale) {
  this.x = this.x * scale;
  this.y = this.y * scale;
  return this;
};
Point.prototype.distanceTo = function(arg0, arg1) {
  var x2 = 0, y2 = 0, a, b;
  switch (arguments.length) {
    case 1:
      x2 = arg0.x;
      y2 = arg0.y;
      break;
    case 2:
      x2 = arg0;
      y2 = arg1;
      break;
    default:
      break;
  }
  a = this.x - x2;
  b = this.y - y2;
  return Math.sqrt(a * a + b * b);
};
Point.prototype.equalTo = function(point) {
  return this.x == point.x && this.y == point.y;
};
Point.prototype.swap = function(point) {
  var x = point.x, y = point.y;
  point.x = this.x;
  point.y = this.y;
  this.x = x;
  this.y = y;
};
Point.prototype.clone = function() {
  return new Point(this);
};
Point.prototype.toString = function(units) {
  var result = "";
  units = units !== void 0 ? units : "px";
  result += "left:" + this.x + units + ";";
  result += "top:" + this.y + units + ";";
  return result;
};
Point.prototype.getCSS = function(units) {
  units = units !== void 0 ? units : "px";
  var result = {
    left: this.x + units,
    top: this.y + units
  };
  return result;
};

// node_modules/basicprimitives/src/graphics/structs/Matrix.js
function Matrix(arg0, arg1, arg2, arg3) {
  this.a1 = null;
  this.b1 = null;
  this.a2 = null;
  this.b2 = null;
  switch (arguments.length) {
    case 1:
      this.a1 = arg0.a1;
      this.b1 = arg0.b1;
      this.a2 = arg0.a2;
      this.b2 = arg0.b2;
      break;
    case 4:
      this.a1 = arg0;
      this.b1 = arg1;
      this.a2 = arg2;
      this.b2 = arg3;
      break;
    default:
      break;
  }
}
Matrix.prototype.determinant = function() {
  return this.a1 * this.b2 - this.b1 * this.a2;
};

// node_modules/basicprimitives/src/graphics/structs/Vector.js
function Vector(arg0, arg1) {
  this.from = null;
  this.to = null;
  this.context = null;
  switch (arguments.length) {
    case 1:
      this.from = arg0.from;
      this.to = arg0.to;
      break;
    case 2:
      this.from = arg0;
      this.to = arg1;
      break;
    default:
      break;
  }
}
Vector.prototype.isNull = function() {
  return this.from.x == this.to && this.from.y == this.to.y;
};
Vector.prototype.length = function() {
  return this.from.distanceTo(this.to);
};
Vector.prototype.equalTo = function(vector) {
  return this.from.equalTo(vector.from) && this.to.equalTo(vector.to);
};
Vector.prototype.getMiddlePoint = function() {
  return new Point((this.from.x + this.to.x) / 2, (this.from.y + this.to.y) / 2);
};
Vector.prototype.relateTo = function(vector) {
  var result = VectorRelationType.None, x1 = this.to.x - this.from.x, y1 = this.to.y - this.from.y, x2 = vector.to.x - vector.from.x, y2 = vector.to.y - vector.from.y, key = (x1 ? 8 : 0) + (y1 ? 4 : 0) + (x2 ? 2 : 0) + (y2 ? 1 : 0);
  switch (key) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 8:
    case 12:
      result = VectorRelationType.Null;
      break;
    case 5:
      if (y1 * y2 > 0) {
        result = VectorRelationType.Collinear;
      } else {
        result = VectorRelationType.Opposite;
      }
      break;
    case 10:
      if (x1 * x2 > 0) {
        result = VectorRelationType.Collinear;
      } else {
        result = VectorRelationType.Opposite;
      }
      break;
    case 15:
      if (x1 / x2 == y1 / y2) {
        if (x1 / x2 > 0) {
          result = VectorRelationType.Collinear;
        } else {
          result = VectorRelationType.Opposite;
        }
      }
      break;
  }
  return result;
};
Vector.prototype.offset = function(offset) {
  var length = this.length(), x = (this.to.y - this.from.y) * offset / length, y = -(this.to.x - this.from.x) * offset / length;
  this.from.x += x;
  this.from.y += y;
  this.to.x += x;
  this.to.y += y;
};
Vector.prototype.getLine = function() {
  var x1 = this.from.x, y1 = this.from.y, x2 = this.to.x, y2 = this.to.y, a = y2 - y1, b = x1 - x2, c = x1 * (y1 - y2) + y1 * (x2 - x1);
  return [a, b, c];
};
Vector.prototype.getLineKey = function() {
  var line = this.getLine(), a = line[0], b = line[1], c = line[2], r = 1e4;
  if (b !== 0) {
    line = [Math.floor(a / b * r), 1, Math.floor(c / b * r)];
  } else {
    line = [1, 0, Math.floor(c / a * r)];
  }
  return line.toString();
};
Vector.prototype.intersect = function(vector) {
  var v1 = this.getLine(), v2 = vector.getLine(), m = new Matrix(v1[0], v1[1], v2[0], v2[1]), d = m.determinant(), mx, my, dx, dy, x, y, result = false;
  if (d !== 0) {
    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);
    dx = mx.determinant();
    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);
    dy = my.determinant();
    x = dx / d;
    y = dy / d;
    vector.to.x = x;
    vector.to.y = y;
    this.from.x = x;
    this.from.y = y;
    result = true;
  }
  return result;
};
Vector.prototype.getIntersectionPoint = function(vector, strict, rounding) {
  var v1 = this.getLine(), v2 = vector.getLine(), m = new Matrix(v1[0], v1[1], v2[0], v2[1]), d = m.determinant(), mx, my, dx, dy, x, y, result = null;
  if (d !== 0) {
    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);
    dx = mx.determinant();
    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);
    dy = my.determinant();
    x = dx / d;
    y = dy / d;
    if (strict) {
      if (vector._contains(x, y, rounding) && this._contains(x, y, rounding)) {
        result = new Point(x, y);
      }
    } else {
      result = new Point(x, y);
    }
  }
  return result;
};
Vector.prototype._contains = function(x, y, rounding) {
  var x1 = Math.min(this.from.x, this.to.x), y1 = Math.min(this.from.y, this.to.y), x2 = Math.max(this.from.x, this.to.x), y2 = Math.max(this.from.y, this.to.y);
  return x1 - rounding <= x && x <= x2 + rounding && y1 - rounding <= y && y <= y2 + rounding;
};

// node_modules/basicprimitives/src/graphics/structs/Interval.js
function Interval(arg0, arg1, arg2) {
  this.from = null;
  this.to = null;
  this.context = null;
  switch (arguments.length) {
    case 1:
      this.from = arg0.from;
      this.to = arg0.to;
      this.context = arg0.context;
      break;
    case 2:
      this.from = arg0;
      this.to = arg1;
      break;
    case 3:
      this.from = arg0;
      this.to = arg1;
      this.context = arg2;
      break;
    default:
      break;
  }
}
Interval.prototype.width = function() {
  return this.to - this.from;
};
Interval.prototype.equalTo = function(interval) {
  return this.from == interval.from && this.to == interval.to;
};
Interval.prototype.clone = function() {
  return new Interval(this);
};
Interval.prototype.toString = function() {
  return this.from + ", " + this.to;
};
Interval.prototype.overlaps = function(interval) {
  var result = true;
  if (this.to < interval.from || interval.to < this.from) {
    result = false;
  }
  return result;
};

// node_modules/basicprimitives/src/graphics/structs/Rect.js
function Rect(arg0, arg1, arg2, arg3) {
  this.x = null;
  this.y = null;
  this.width = null;
  this.height = null;
  this.context = null;
  switch (arguments.length) {
    case 1:
      this.x = arg0.x;
      this.y = arg0.y;
      this.width = arg0.width;
      this.height = arg0.height;
      break;
    case 2:
      this.x = Math.min(arg0.x, arg1.x);
      this.y = Math.min(arg0.y, arg1.y);
      this.width = Math.abs(arg1.x - arg0.x);
      this.height = Math.abs(arg1.y - arg0.y);
      break;
    case 4:
      this.x = arg0;
      this.y = arg1;
      this.width = arg2;
      this.height = arg3;
      break;
    default:
      break;
  }
}
Rect.prototype.left = function() {
  return this.x;
};
Rect.prototype.top = function() {
  return this.y;
};
Rect.prototype.right = function() {
  return this.x + this.width;
};
Rect.prototype.bottom = function() {
  return this.y + this.height;
};
Rect.prototype.verticalCenter = function() {
  return this.y + this.height / 2;
};
Rect.prototype.horizontalCenter = function() {
  return this.x + this.width / 2;
};
Rect.prototype.centerPoint = function() {
  return new Point(this.horizontalCenter(), this.verticalCenter());
};
Rect.prototype.isEmpty = function() {
  return this.x === null || this.y === null || this.width === null || this.height === null || this.width < 0 || this.height < 0;
};
Rect.prototype.offset = function(arg0, arg1, arg2, arg3) {
  switch (arguments.length) {
    case 1:
      if (arg0 !== null && typeof arg0 == "object") {
        this.x = this.x - arg0.left;
        this.y = this.y - arg0.top;
        this.width = this.width + arg0.left + arg0.right;
        this.height = this.height + arg0.top + arg0.bottom;
      } else {
        this.x = this.x - arg0;
        this.y = this.y - arg0;
        this.width = this.width + arg0 * 2;
        this.height = this.height + arg0 * 2;
      }
      break;
    case 4:
      this.x = this.x - arg0;
      this.y = this.y - arg1;
      this.width = this.width + arg0 + arg2;
      this.height = this.height + arg1 + arg3;
      break;
  }
  return this;
};
Rect.prototype.scale = function(scale) {
  this.x = this.x * scale;
  this.y = this.y * scale;
  this.width = this.width * scale;
  this.height = this.height * scale;
  return this;
};
Rect.prototype.translate = function(x, y) {
  this.x = this.x + x;
  this.y = this.y + y;
  return this;
};
Rect.prototype.invert = function() {
  var width = this.width, x = this.x;
  this.width = this.height;
  this.height = width;
  this.x = this.y;
  this.y = x;
  return this;
};
Rect.prototype.loopEdges = function(callback) {
  var vertexes = [
    new Point(this.left(), this.top()),
    new Point(this.right(), this.top()),
    new Point(this.right(), this.bottom()),
    new Point(this.left(), this.bottom())
  ], placements = [
    PlacementType.Top,
    PlacementType.Right,
    PlacementType.Bottom,
    PlacementType.Left
  ];
  vertexes.push(vertexes[0]);
  if (callback != null) {
    for (var index = 1, len = vertexes.length; index < len; index += 1) {
      if (callback(new Vector(vertexes[index - 1], vertexes[index]), placements[index - 1])) {
        break;
      }
    }
  }
  return this;
};
Rect.prototype.contains = function(arg0, arg1) {
  switch (arguments.length) {
    case 1:
      return this.x <= arg0.x && arg0.x <= this.x + this.width && this.y <= arg0.y && arg0.y <= this.y + this.height;
    case 2:
      return this.x <= arg0 && arg0 <= this.x + this.width && this.y <= arg1 && arg1 <= this.y + this.height;
    default:
      return false;
  }
};
Rect.prototype.cropByRect = function(rect) {
  if (this.x < rect.x) {
    this.width -= rect.x - this.x;
    this.x = rect.x;
  }
  if (this.right() > rect.right()) {
    this.width -= this.right() - rect.right();
  }
  if (this.y < rect.y) {
    this.height -= rect.y - this.y;
    this.y = rect.y;
  }
  if (this.bottom() > rect.bottom()) {
    this.height -= this.bottom() - rect.bottom();
  }
  if (this.isEmpty()) {
    this.x = null;
    this.y = null;
    this.width = null;
    this.height = null;
  }
  return this;
};
Rect.prototype.overlaps = function(rect) {
  var result = true;
  if (this.x + this.width < rect.x || rect.x + rect.width < this.x || this.y + this.height < rect.y || rect.y + rect.height < this.y) {
    result = false;
  }
  return result;
};
Rect.prototype.addRect = function(arg0, arg1, arg2, arg3) {
  var right, bottom;
  switch (arguments.length) {
    case 1:
      if (!arg0.isEmpty()) {
        if (this.isEmpty()) {
          this.x = arg0.x;
          this.y = arg0.y;
          this.width = arg0.width;
          this.height = arg0.height;
        } else {
          right = Math.max(this.right(), arg0.right());
          bottom = Math.max(this.bottom(), arg0.bottom());
          this.x = Math.min(this.x, arg0.x);
          this.y = Math.min(this.y, arg0.y);
          this.width = right - this.x;
          this.height = bottom - this.y;
        }
      }
      break;
    case 2:
      if (this.isEmpty()) {
        this.x = arg0;
        this.y = arg1;
        this.width = 0;
        this.height = 0;
      } else {
        right = Math.max(this.right(), arg0);
        bottom = Math.max(this.bottom(), arg1);
        this.x = Math.min(this.x, arg0);
        this.y = Math.min(this.y, arg1);
        this.width = right - this.x;
        this.height = bottom - this.y;
      }
      break;
    case 4:
      if (this.isEmpty()) {
        this.x = arg0;
        this.y = arg1;
        this.width = arg2;
        this.height = arg3;
      } else {
        right = Math.max(this.right(), arg0 + arg2);
        bottom = Math.max(this.bottom(), arg1 + arg3);
        this.x = Math.min(this.x, arg0);
        this.y = Math.min(this.y, arg1);
        this.width = right - this.x;
        this.height = bottom - this.y;
      }
      break;
  }
  return this;
};
Rect.prototype.getCSS = function(units) {
  units = units !== void 0 ? units : "px";
  var result = {
    left: this.x + units,
    top: this.y + units,
    width: this.width + units,
    height: this.height + units
  };
  return result;
};
Rect.prototype.toString = function(units) {
  var result = "";
  units = units !== void 0 ? units : "px";
  result += "left:" + this.x + units + ";";
  result += "top:" + this.y + units + ";";
  result += "width:" + this.width + units + ";";
  result += "height:" + this.height + units + ";";
  return result;
};
Rect.prototype.validate = function() {
  if (isNaN(this.x) || isNaN(this.y) || isNaN(this.width) || isNaN(this.height)) {
    throw "Invalid rect position.";
  }
};
Rect.prototype.equalTo = function(rect) {
  return this.x == rect.x && this.y == rect.y && this.width == rect.width && this.height == rect.height;
};
Rect.prototype.getProjectionPoint = function(point) {
  var result = null;
  if (!this.contains(point)) {
    var vector = new Vector(this.centerPoint(), point);
    this.loopEdges(function(edge) {
      result = vector.getIntersectionPoint(edge, true, 1);
      return result != null;
    });
  }
  return result;
};
Rect.prototype.verticalInterval = function() {
  return new Interval(this.y, this.bottom());
};

// node_modules/basicprimitives/src/graphics/structs/Thickness.js
function Thickness(arg0, arg1, arg2, arg3) {
  this.left = 0;
  this.top = 0;
  this.right = 0;
  this.bottom = 0;
  switch (arguments.length) {
    case 1:
      if (arg0 !== null && typeof arg0 == "object") {
        this.left = arg0.left;
        this.top = arg0.top;
        this.right = arg0.right;
        this.bottom = arg0.bottom;
      } else {
        this.left = arg0;
        this.top = arg0;
        this.right = arg0;
        this.bottom = arg0;
      }
      break;
    case 4:
      this.left = arg0;
      this.top = arg1;
      this.right = arg2;
      this.bottom = arg3;
      break;
  }
  return this;
}
Thickness.prototype.isEmpty = function() {
  return this.left === 0 && this.top === 0 && this.right === 0 && this.bottom === 0;
};
Thickness.prototype.isPositive = function() {
  return this.left > 0 || this.top > 0 || this.right > 0 || this.bottom > 0;
};
Thickness.prototype.isNegative = function() {
  return this.left < 0 || this.top < 0 || this.right < 0 || this.bottom < 0;
};
Thickness.prototype.maxThickness = function(thickness) {
  this.left = Math.max(this.left, thickness.left);
  this.top = Math.max(this.top, thickness.top);
  this.right = Math.max(this.right, thickness.right);
  this.bottom = Math.max(this.bottom, thickness.bottom);
  return this;
};
Thickness.prototype.addThickness = function(arg0, arg1, arg2, arg3) {
  switch (arguments.length) {
    case 1:
      if (arg0 !== null && typeof arg0 == "object") {
        this.left += arg0.left;
        this.top += arg0.top;
        this.right += arg0.right;
        this.bottom += arg0.bottom;
      } else {
        this.left += arg0;
        this.top += arg0;
        this.right += arg0;
        this.bottom += arg0;
      }
      break;
    case 4:
      this.left += arg0;
      this.top += arg1;
      this.right += arg2;
      this.bottom += arg3;
      break;
  }
  return this;
};
Thickness.prototype.scale = function(scale) {
  this.left = this.left * scale;
  this.top = this.top * scale;
  this.right = this.right * scale;
  this.bottom = this.bottom * scale;
  return this;
};
Thickness.prototype.toString = function(units) {
  units = units !== void 0 ? units : "px";
  return this.top + units + " " + this.right + units + " " + this.bottom + units + " " + this.left + units;
};

// node_modules/basicprimitives/src/algorithms/binarySearch.js
function binarySearch(items, callback, startMinimum, startMaximum) {
  var result = null, distance, bestDistance, minimum = startMinimum || 0, maximum = startMaximum || items.length - 1, middle, item;
  if (items.length > 0) {
    item = items[minimum];
    result = { index: minimum, item };
    distance = callback(item, minimum);
    if (distance > 0) {
      bestDistance = Math.abs(distance);
      item = items[maximum];
      distance = callback(item, maximum);
      if (distance >= 0) {
        result = { index: maximum, item };
      } else {
        distance = Math.abs(distance);
        if (bestDistance > distance) {
          bestDistance = distance;
          result = { index: maximum, item };
        }
        while (minimum + 1 < maximum) {
          middle = Math.round((minimum + maximum) / 2);
          item = items[middle];
          distance = callback(item, middle);
          if (distance === 0) {
            result = { index: middle, item };
            break;
          } else {
            if (distance > 0) {
              minimum = middle;
            } else {
              maximum = middle;
            }
            distance = Math.abs(distance);
            if (bestDistance > distance) {
              bestDistance = distance;
              result = { index: middle, item };
            }
          }
        }
      }
    }
  }
  return result;
}

// node_modules/basicprimitives/src/algorithms/SortedList.js
function SortedList() {
  var _rootNode = null;
  function Node(value, context) {
    this.value = value;
    this.context = context;
    this.left = null;
    this.right = null;
    this.balance = 0;
  }
  function _rebalance(node) {
    var balance;
    if (node.balance == 2) {
      var right = node.right;
      balance = right.balance;
      if (balance >= 0) {
        _rotateSmallLeft(right, node);
      } else {
        _rotateBigLeft(right, node);
      }
    } else if (node.balance == -2) {
      var left = node.left;
      balance = left.balance;
      if (balance <= 0) {
        _rotateSmallRight(node.left, node);
      } else {
        _rotateBigRight(node.left, node);
      }
    }
    return balance;
  }
  function _rotateSmallLeft(node, parent) {
    _rotateLeft(node, parent);
    if (node.balance == 1) {
      parent.balance = 0;
      node.balance = 0;
    } else {
      parent.balance = -1;
      node.balance = 1;
    }
  }
  function _rotateLeft(node, parent) {
    _swap(node, parent);
    parent.right = node.right;
    node.right = node.left;
    node.left = parent.left;
    parent.left = node;
  }
  function _rotateSmallRight(node, parent) {
    _rotateRight(node, parent);
    if (node.balance == -1) {
      parent.balance = 0;
      node.balance = 0;
    } else {
      parent.balance = 1;
      node.balance = -1;
    }
  }
  function _rotateRight(node, parent) {
    _swap(node, parent);
    parent.left = node.left;
    node.left = node.right;
    node.right = parent.right;
    parent.right = node;
  }
  function _rotateBigLeft(node, parent) {
    var bottom = node.left;
    _rotateRight(bottom, node);
    _rotateLeft(node, parent);
    parent.balance = 0;
    switch (bottom.balance) {
      case 1:
        node.balance = -1;
        bottom.balance = 0;
        break;
      case 0:
        bottom.balance = 0;
        node.balance = 0;
        break;
      default:
        bottom.balance = 1;
        node.balance = 0;
        break;
    }
  }
  function _rotateBigRight(node, parent) {
    var bottom = node.right;
    _rotateLeft(bottom, node);
    _rotateRight(node, parent);
    parent.balance = 0;
    switch (bottom.balance) {
      case -1:
        bottom.balance = 0;
        node.balance = 1;
        break;
      case 0:
        bottom.balance = 0;
        node.balance = 0;
        break;
      default:
        bottom.balance = -1;
        node.balance = 0;
        break;
    }
  }
  function add(value, context, thisArg, onDuplicate) {
    if (_rootNode == null) {
      _rootNode = new Node(value, context);
    } else {
      var trace = [];
      var node = null;
      var next = _rootNode;
      while (next != null) {
        if (node != null) {
          trace.push(node);
        }
        node = next;
        if (node.value == value) {
          if (onDuplicate != null) {
            onDuplicate.call(thisArg, node.context);
          } else {
            throw "Structure does not support duplicates.";
          }
        } else {
          if (node.value > value) {
            next = node.left;
          } else {
            next = node.right;
          }
        }
      }
      trace.push(node);
      var newNode = new Node(value, context);
      if (node.value > value) {
        node.left = newNode;
      } else {
        node.right = newNode;
      }
      node = newNode;
      while ((next = trace.pop()) != null) {
        if (node.value < next.value) {
          if (next.balance < 0) {
            next.balance -= 1;
            _rebalance(next);
            break;
          } else {
            if (next.balance > 0) {
              next.balance -= 1;
              break;
            }
            next.balance -= 1;
          }
        } else {
          if (next.balance > 0) {
            next.balance += 1;
            _rebalance(next);
            break;
          } else {
            if (next.balance < 0) {
              next.balance += 1;
              break;
            }
            next.balance += 1;
          }
        }
        node = next;
      }
    }
  }
  function _delete(node, parent) {
    var child = node.right != null ? node.right : node.left;
    if (parent != null) {
      if (parent.value > node.value) {
        parent.left = child;
      } else {
        parent.right = child;
      }
    } else {
      _rootNode = child;
    }
  }
  function _swap(node1, node2) {
    var value = node1.value;
    node1.value = node2.value;
    node2.value = value;
    var context = node1.context;
    node1.context = node2.context;
    node2.context = context;
  }
  function _copy(fromNode, toNode) {
    toNode.value = fromNode.value;
    toNode.context = fromNode.context;
  }
  function remove(value) {
    var trace = [];
    var node = _rootNode;
    while (node != null) {
      if (node.value == value) {
        if (node.right != null && node.left != null) {
          trace.push(node);
          var next = node.right;
          while (next.left != null) {
            trace.push(next);
            next = next.left;
          }
          _copy(next, node);
          _delete(next, trace[trace.length - 1]);
          trace.push(next);
        } else {
          _delete(node, trace[trace.length - 1]);
          trace.push(node);
        }
        for (var index = trace.length - 2; index >= 0; index -= 1) {
          var parent = trace[index];
          node = trace[index + 1];
          if (parent.value > node.value) {
            if (parent.balance > 0) {
              parent.balance += 1;
              if (_rebalance(parent) === 0) {
                break;
              }
            } else {
              if (parent.balance === 0) {
                parent.balance += 1;
                break;
              }
              parent.balance += 1;
            }
          } else {
            if (parent.balance < 0) {
              parent.balance -= 1;
              if (_rebalance(parent) === 0) {
                break;
              }
            } else {
              if (parent.balance === 0) {
                parent.balance -= 1;
                break;
              }
              parent.balance -= 1;
            }
          }
        }
        break;
      } else {
        trace.push(node);
        if (node.value > value) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
    }
  }
  function nextContext(fromValue) {
    var result = null;
    loopForward(this, fromValue, function(value, context) {
      result = context;
      return true;
    });
    return result;
  }
  function loopForward(thisArg, fromValue, onItem) {
    if (onItem != null) {
      var trace = [];
      var node = null;
      var next = _rootNode;
      while (next != null) {
        node = next;
        if (node.value >= fromValue || fromValue == null) {
          trace.push(node);
          next = node.left;
        } else {
          next = node.right;
        }
      }
      while ((node = trace.pop()) != null) {
        if (onItem.call(thisArg, node.value, node.context)) {
          return;
        }
        next = node.right;
        while (next != null) {
          node = next;
          if (node.left != null) {
            trace.push(node);
            next = node.left;
          } else {
            if (onItem.call(thisArg, node.value, node.context)) {
              return;
            }
            next = node.right;
          }
        }
      }
    }
  }
  function previousContext(fromValue) {
    var result = null;
    loopBackward(this, fromValue, function(nextValue, context) {
      result = context;
      return true;
    });
    return result;
  }
  function loopBackward(thisArg, fromValue, onItem) {
    if (onItem != null) {
      var trace = [];
      var node = null;
      var next = _rootNode;
      while (next != null) {
        node = next;
        if (node.value <= fromValue || fromValue == null) {
          trace.push(node);
          next = node.right;
        } else {
          next = node.left;
        }
      }
      while ((node = trace.pop()) != null) {
        if (onItem.call(thisArg, node.value, node.context)) {
          return;
        }
        next = node.left;
        while (next != null) {
          node = next;
          if (node.right != null) {
            trace.push(node);
            next = node.right;
          } else {
            if (onItem.call(thisArg, node.value, node.context)) {
              return;
            }
            next = node.left;
          }
        }
      }
    }
  }
  function _getValidationDepth(node) {
    var level = [], result = 0;
    if (node != null) {
      level.push(node);
      while (level.length > 0) {
        var newLevel = [];
        for (var index = 0; index < level.length; index += 1) {
          node = level[index];
          if (node.left != null) {
            newLevel.push(node.left);
          }
          if (node.right != null) {
            newLevel.push(node.right);
          }
        }
        level = newLevel;
        result += 1;
      }
    }
    return result;
  }
  function validate() {
    if (_rootNode != null) {
      var level = [_rootNode];
      while (level.length > 0) {
        var newLevel = [];
        for (var index = 0; index < level.length; index += 1) {
          var node = level[index];
          if (node.value == null) {
            return false;
          }
          if (node.left != null) {
            newLevel.push(node.left);
            if (node.left.value >= node.value) {
              return false;
            }
          }
          if (node.right != null) {
            newLevel.push(node.right);
            if (node.right.value <= node.value) {
              return false;
            }
          }
          if (node.balance != _getValidationDepth(node.right) - _getValidationDepth(node.left)) {
            console.log("Disbalanced node: " + node.value + " - " + JSON.stringify(_rootNode));
            return false;
          }
        }
        level = newLevel;
      }
    }
    return true;
  }
  return {
    add,
    remove,
    loopForward,
    loopBackward,
    nextContext,
    previousContext,
    validate
  };
}

// node_modules/basicprimitives/src/algorithms/getCrossingRectangles.js
function getCrossingRectangles(thisArg, rectangles, onCrossing) {
  function Action(isStart, index3, x, rect2) {
    this.isStart = isStart;
    this.index = index3;
    this.x = x;
    this.rect = rect2;
  }
  function Level() {
    this.count = 0;
    this.rectangles = {};
    this.add = function(index3) {
      this.count += 1;
      this.rectangles[index3] = true;
    };
    this.remove = function(index3) {
      this.count -= 1;
      delete this.rectangles[index3];
      return this.count == 0;
    };
  }
  function _findCrossedRectangles(buffer2, from, to, rectIndex, rect2) {
    buffer2.loopForward(this, from, function(value2, level2) {
      if (value2 > to) {
        return true;
      }
      for (var index3 in level2.rectangles) {
        if (level2.rectangles.hasOwnProperty(index3)) {
          var key = rectIndex > index3 ? rectIndex + "-" + index3 : index3 + "-" + rectIndex;
          if (!processed.hasOwnProperty(key)) {
            processed[key] = true;
            onCrossing.call(thisArg, rect2, rectangles[index3]);
          }
        }
      }
    });
  }
  if (onCrossing != null) {
    var actions = [];
    for (var index = 0; index < rectangles.length; index += 1) {
      var rect = rectangles[index];
      actions.push(new Action(1, index, rect.x, rect));
      actions.push(new Action(0, index, rect.right(), rect));
    }
    actions.sort(function(a, b) {
      if (a.x == b.x) {
        return b.isStart - a.isStart;
      }
      return a.x - b.x;
    });
    var buffer = SortedList();
    var levels = {};
    var processed = {};
    for (index = 0; index < actions.length; index += 1) {
      var action = actions[index];
      var actionLevels = [action.rect.y, action.rect.bottom()];
      if (action.isStart == 1) {
        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);
        for (var index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {
          var value = actionLevels[index2];
          var level = levels[value];
          if (level == null) {
            level = new Level();
            levels[value] = level;
            buffer.add(value, level);
          }
          level.add(action.index);
        }
      } else {
        for (index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {
          value = actionLevels[index2];
          level = levels[value];
          if (level.remove(action.index)) {
            delete levels[value];
            buffer.remove(value);
          }
        }
        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);
      }
    }
  }
}

// node_modules/basicprimitives/src/algorithms/getFamilyLoops.js
function Edge(from, to) {
  this.from = from;
  this.to = to;
}
function getFamilyLoops(family, debug) {
  var loops = [], loop2, index, len, index2, len2, fromNode, toNode, edge;
  var tempFamily = family.clone();
  family.loopTopo(this, function(itemid) {
    tempFamily.removeNode(itemid);
  });
  family.loopTopoReversed(this, function(itemid) {
    tempFamily.removeNode(itemid);
  });
  var cleanFamily = tempFamily.clone();
  cleanFamily.loop(this, function(itemid) {
    if (tempFamily.node(itemid) != null) {
      tempFamily.loopParents(this, itemid, function(parentid) {
        loops.push(new Edge(parentid, itemid));
        tempFamily.removeChildRelation(parentid, itemid);
        return tempFamily.SKIP;
      });
      var itemsToRemove = [];
      tempFamily.loopTopo(this, function(itemid2) {
        itemsToRemove.push(itemid2);
      });
      tempFamily.loopTopoReversed(this, function(itemid2) {
        itemsToRemove.push(itemid2);
      });
      for (var index3 = 0; index3 < itemsToRemove.length; index3 += 1) {
        tempFamily.removeNode(itemsToRemove[index3]);
      }
    }
  });
  for (index = 0, len = loops.length; index < len; index += 1) {
    loop2 = loops[index];
    if (!cleanFamily.removeChildRelation(loop2.from, loop2.to)) {
      throw "Relation does not exists";
    }
  }
  if (debug && cleanFamily.hasLoops()) {
    throw "Failed to clean loops in family";
  }
  var graph = cleanFamily.getGraph(this, function(from2, to2) {
    return { from: from2, to: to2, capacity: 1, flow: 0 };
  });
  var from = "__1000__";
  var to = "__2000__";
  var defaultMinimalFlow = loops.length;
  for (index = 0, len = loops.length; index < len; index += 1) {
    loop2 = loops[index];
    edge = graph.edge(loop2.from, to);
    if (edge == null) {
      graph.addEdge(loop2.from, to, { from: loop2.from, to, capacity: 1, flow: 0, tos: [loop2.to] });
    } else {
      edge.capacity += 1;
      edge.tos.push(loop2.to);
    }
    edge = graph.edge(from, loop2.to);
    if (edge == null) {
      graph.addEdge(from, loop2.to, { from, to: loop2.to, capacity: 1, flow: 0, froms: [loop2.from] });
    } else {
      edge.capacity += 1;
      edge.froms.push(loop2.from);
    }
  }
  var totalFlow = 0;
  var levelGraph = null;
  while (true) {
    levelGraph = graph.getLevelGraph(this, from, function(fromNode2, toNode2, edge2) {
      if (fromNode2 == edge2.from) {
        return edge2.capacity > edge2.flow;
      } else {
        return edge2.flow > 0;
      }
    });
    if (!levelGraph.hasNode(to)) {
      break;
    }
    while (true) {
      var connectionPath = graph.dfsPath(this, from, to, function(fromNode2, toNode2, edge2) {
        if (fromNode2 == edge2.from) {
          return edge2.capacity > edge2.flow;
        } else {
          return edge2.flow > 0;
        }
      });
      if (connectionPath.length == 0) {
        break;
      }
      var flow = Infinity;
      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {
        fromNode = connectionPath[index];
        toNode = connectionPath[index + 1];
        edge = graph.edge(fromNode, toNode);
        var edgeFlow = 0;
        if (edge.from == fromNode) {
          edgeFlow = edge.capacity - edge.flow;
        } else {
          edgeFlow = edge.flow;
        }
        if (edgeFlow == 0) {
          throw "Broken flow path";
        }
        flow = Math.min(flow, edgeFlow);
      }
      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {
        fromNode = connectionPath[index];
        toNode = connectionPath[index + 1];
        edge = graph.edge(fromNode, toNode);
        if (edge.from == fromNode) {
          edge.flow += flow;
        } else {
          edge.flow -= flow;
        }
      }
      totalFlow += flow;
    }
  }
  if (totalFlow < defaultMinimalFlow) {
    var residueGraph = graph.getLevelGraph(this, from, function(fromNode2, toNode2, edge2) {
      if (fromNode2 == edge2.from) {
        return edge2.capacity > edge2.flow;
      }
      return false;
    });
    var edgesToBreak = [];
    residueGraph.loopNodes(this, from, function(nodeid) {
      graph.loopNodeEdges(this, nodeid, function(toNode2, edge2) {
        if (edge2.to == toNode2) {
          if (!residueGraph.hasNode(toNode2)) {
            var isIsolated = false;
            graph.dfsLoop(this, toNode2, function(fromNode2, toNode22, edge3) {
              if (edge3.from == fromNode2 && !residueGraph.hasNode(fromNode2)) {
                return true;
              }
              return false;
            }, function(foundid) {
              if (foundid == to) {
                isIsolated = true;
                return true;
              }
              return false;
            });
            if (isIsolated) {
              edgesToBreak.push(new Edge(nodeid, toNode2));
            }
          }
        }
      });
    });
    var optimizedLoops = [];
    var validatedFlow = 0;
    for (index = 0, len = edgesToBreak.length; index < len; index += 1) {
      var edgeToBreak = edgesToBreak[index];
      if (edgeToBreak.from == from) {
        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);
        for (index2 = 0, len2 = edge.froms.length; index2 < len2; index2 += 1) {
          optimizedLoops.push(new Edge(edge.froms[index2], edgeToBreak.to));
          validatedFlow += 1;
        }
      } else if (edgeToBreak.to == to) {
        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);
        for (index2 = 0, len2 = edge.tos.length; index2 < len2; index2 += 1) {
          optimizedLoops.push(new Edge(edgeToBreak.from, edge.tos[index2]));
          validatedFlow += 1;
        }
      } else {
        optimizedLoops.push(edgeToBreak);
        validatedFlow += 1;
      }
    }
    if (validatedFlow == totalFlow) {
      loops = optimizedLoops;
    }
  }
  return loops;
}

// node_modules/basicprimitives/src/algorithms/getFamilyUnits.js
function getFamilyUnits(family) {
  var familyUnits = [], familyUnitByParent = {}, index, len;
  function FamilySiblings() {
    this.fromIndex = 0;
    this.toIndex = 0;
    this.items = [];
    this.hash = {};
  }
  function FamilyUnit(id) {
    this.id = id;
    this.parents = new FamilySiblings();
    this.children = new FamilySiblings();
    this.loopSiblings = function(thisArg, itemid, onItem) {
      this._loop(thisArg, this.parents.hash.hasOwnProperty(itemid) ? this.parents.items : this.children.items, onItem);
    };
    this.loopNonSiblings = function(thisArg, itemid, onItem) {
      this._loop(thisArg, !this.parents.hash.hasOwnProperty(itemid) ? this.parents.items : this.children.items, onItem);
    };
    this.loop = function(thisArg, onItem) {
      this._loop(thisArg, this.parents.items, onItem);
      this._loop(thisArg, this.children.items, onItem);
    };
    this._loop = function(thisArg, items, onItem) {
      if (onItem != null) {
        for (var index2 = 0, len2 = items.length; index2 < len2; index2 += 1) {
          var sibling = items[index2];
          onItem.call(thisArg, sibling);
        }
      }
    };
    this.addParent = function(itemid) {
      this._add(itemid, this.parents);
    };
    this.addChild = function(itemid) {
      this._add(itemid, this.children);
    };
    this._add = function(itemid, siblings) {
      if (!siblings.hash.hasOwnProperty(itemid)) {
        siblings.items.push(itemid);
        siblings.hash[itemid] = true;
      }
    };
  }
  index = 0;
  family.loop(this, function(itemid, item) {
    var childrenCount = family.countChildren(itemid);
    if (childrenCount > 0) {
      if (!familyUnitByParent.hasOwnProperty(itemid)) {
        var familyUnit2 = new FamilyUnit(index);
        index += 1;
        familyUnit2.addParent(itemid);
        family.loopChildren(this, itemid, function(childid, child) {
          familyUnit2.addChild(childid);
          if (childrenCount == 1) {
            family.loopParents(this, childid, function(parentid) {
              familyUnit2.addParent(parentid);
              familyUnitByParent[parentid] = familyUnit2;
              return family.SKIP;
            });
          }
          return family.SKIP;
        });
        familyUnits.push(familyUnit2);
        familyUnitByParent[itemid] = familyUnit2;
      }
    }
  });
  var familyUnitByItemId = {};
  for (index = 0, len = familyUnits.length; index < len; index += 1) {
    var familyUnit = familyUnits[index];
    familyUnit.loop(this, function(itemid) {
      if (!familyUnitByItemId.hasOwnProperty(itemid)) {
        familyUnitByItemId[itemid] = [familyUnit];
      } else {
        familyUnitByItemId[itemid].push(familyUnit);
      }
    });
  }
  return familyUnitByItemId;
}

// node_modules/basicprimitives/src/algorithms/getLiniarBreaks.js
function getLiniarBreaks(values) {
  var _leftTotal = [], _len = values.length;
  var total = 0;
  for (var index = 0; index < _len; index += 1) {
    total += values[index];
    _leftTotal[index] = total;
  }
  function getLinearDeviation(leftIndex2, rightIndex2) {
    var result = 0;
    var avg = (_leftTotal[rightIndex2] - _leftTotal[leftIndex2] + values[leftIndex2]) / (rightIndex2 - leftIndex2 + 1);
    var median = binarySearch(values, function(item) {
      return avg - item;
    }, leftIndex2, rightIndex2);
    if (median.item <= avg) {
      result += avg * (median.index + 1 - leftIndex2) - (_leftTotal[median.index] - _leftTotal[leftIndex2] + values[leftIndex2]);
      result += _leftTotal[rightIndex2] - _leftTotal[median.index] - avg * (rightIndex2 - median.index);
    } else {
      result += avg * (median.index - leftIndex2) - (_leftTotal[median.index] - _leftTotal[leftIndex2] - values[median.index] + values[leftIndex2]);
      result += _leftTotal[rightIndex2] - _leftTotal[median.index] + values[median.index] - avg * (rightIndex2 - median.index + 1);
    }
    return result;
  }
  function getScore(leftIndex2, rightIndex2) {
    var score2 = 0;
    score2 += getLinearDeviation(0, leftIndex2);
    if (rightIndex2 > leftIndex2 + 1) {
      score2 += getLinearDeviation(leftIndex2 + 1, rightIndex2 - 1);
    }
    score2 += getLinearDeviation(rightIndex2, _len - 1);
    return score2;
  }
  var leftIndex = 0, rightIndex = _len - 1;
  var score = getScore(leftIndex, rightIndex);
  while (leftIndex < rightIndex + 1) {
    var leftScore = getScore(leftIndex + 1, rightIndex);
    var rightScore = getScore(leftIndex, rightIndex - 1);
    if (leftScore < rightScore) {
      if (leftScore >= score) {
        break;
      }
      leftIndex += 1;
      score = leftScore;
    } else {
      if (rightScore >= score) {
        break;
      }
      rightIndex -= 1;
      score = rightScore;
    }
  }
  return [leftIndex, rightIndex - 1, _len - 1];
}

// node_modules/basicprimitives/src/algorithms/LinkedHashItems.js
function LinkedHashItems() {
  var segmentsHash = {}, nextKeys = {}, prevKeys = {}, startSegmentKey = null, endSegmentKey = null;
  function add(key, item2) {
    if (segmentsHash.hasOwnProperty(key)) {
      throw "Duplicate segments are not supported!";
    }
    segmentsHash[key] = item2;
    nextKeys[key] = null;
    if (endSegmentKey == null) {
      startSegmentKey = key;
      prevKeys[key] = null;
    } else {
      nextKeys[endSegmentKey] = key;
      prevKeys[key] = endSegmentKey;
    }
    endSegmentKey = key;
  }
  function isEmpty() {
    return startSegmentKey == null;
  }
  function item(key) {
    return segmentsHash[key];
  }
  function nextKey(key) {
    return nextKeys[key];
  }
  function prevKey(key) {
    return prevKeys[key];
  }
  function startKey() {
    return startSegmentKey;
  }
  function endKey() {
    return endSegmentKey;
  }
  function unshift(key, item2) {
    if (segmentsHash.hasOwnProperty(key)) {
      throw "Duplicate segments are not supported!";
    }
    segmentsHash[key] = item2;
    prevKeys[key] = null;
    if (startSegmentKey == null) {
      endSegmentKey = key;
      nextKeys[key] = null;
    } else {
      prevKeys[startSegmentKey] = key;
      nextKeys[key] = startSegmentKey;
    }
    startSegmentKey = key;
  }
  function insertAfter(afterKey, key, item2) {
    if (segmentsHash.hasOwnProperty(key)) {
      throw "Duplicate segments are not supported!";
    }
    if (afterKey == null) {
      unshift(key, item2);
    } else {
      var nextKey2 = nextKeys[afterKey];
      if (nextKey2 == null) {
        add(key, item2);
      } else {
        segmentsHash[key] = item2;
        nextKeys[afterKey] = key;
        nextKeys[key] = nextKey2;
        prevKeys[nextKey2] = key;
        prevKeys[key] = afterKey;
      }
    }
  }
  function insertBefore(beforeKey, key, item2) {
    if (segmentsHash.hasOwnProperty(key)) {
      throw "Duplicate segments are not supported!";
    }
    if (beforeKey == null || !segmentsHash.hasOwnProperty(beforeKey)) {
      throw "Before key should be defined!";
    }
    var prevKey2 = prevKeys[beforeKey];
    if (prevKey2 == null) {
      unshift(key, item2);
    } else {
      insertAfter(prevKey2, key, item2);
    }
  }
  function remove(key) {
    var prevKey2 = prevKeys[key], nextKey2 = nextKeys[key];
    if (prevKey2 != null) {
      nextKeys[prevKey2] = nextKey2;
    } else {
      startSegmentKey = nextKey2;
    }
    if (nextKey2 != null) {
      prevKeys[nextKey2] = prevKey2;
    } else {
      endSegmentKey = prevKey2;
    }
    delete segmentsHash[key];
    delete nextKeys[key];
    delete prevKeys[key];
  }
  function empty() {
    segmentsHash = {};
    nextKeys = {};
    prevKeys = {};
    startSegmentKey = null;
    endSegmentKey = null;
  }
  function _iterate(forward, onItem, startKey2, endKey2) {
    var key = startKey2, segment;
    if (key == null) {
      key = forward ? startSegmentKey : endSegmentKey;
    }
    if (onItem != null) {
      while (key != null) {
        segment = segmentsHash[key];
        if (segment != null) {
          if (onItem(segment, key)) {
            return;
          }
        }
        if (key == endKey2) {
          key = null;
        } else {
          key = forward ? nextKeys[key] : prevKeys[key];
        }
      }
    }
  }
  function attach(list) {
    list.iterate(function(segment, key) {
      add(key, segment);
    });
  }
  function iterate(onItem, startKey2, endKey2) {
    _iterate(true, onItem, startKey2, endKey2);
  }
  function iterateBack(onItem, startKey2, endKey2) {
    _iterate(false, onItem, startKey2, endKey2);
  }
  function validate(info) {
    var key, prevKey2, nextKey2;
    for (key in segmentsHash) {
      if (segmentsHash.hasOwnProperty(key)) {
        if (!nextKeys.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {
          if (info != null) {
            info.message = "Orphant key found!";
          }
          return false;
        }
      }
    }
    if (!segmentsHash.hasOwnProperty(startSegmentKey) || !segmentsHash.hasOwnProperty(endSegmentKey)) {
      if (info != null) {
        info.message = "Start or end values are missing!";
      }
      return false;
    }
    for (key in nextKeys) {
      if (nextKeys.hasOwnProperty(key)) {
        if (!segmentsHash.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {
          if (info != null) {
            info.message = "Orphant key found!";
          }
          return false;
        }
        nextKey2 = nextKeys[key];
        if (nextKey2 && !nextKeys.hasOwnProperty(nextKey2)) {
          if (info != null) {
            info.message = "Next key not found!";
          }
          return false;
        }
      }
    }
    for (key in prevKeys) {
      if (prevKeys.hasOwnProperty(key)) {
        if (!segmentsHash.hasOwnProperty(key) || !nextKeys.hasOwnProperty(key)) {
          if (info != null) {
            info.message = "Orphant key found!";
          }
          return false;
        }
        prevKey2 = prevKeys[key];
        if (prevKey2 && !prevKeys.hasOwnProperty(prevKey2)) {
          if (info != null) {
            info.message = "Prev key not found!";
          }
          return false;
        }
      }
    }
    return true;
  }
  function toArray() {
    var result = [];
    iterate(function(item2) {
      result.push(item2);
    });
    return result;
  }
  return {
    add,
    item,
    nextKey,
    prevKey,
    startKey,
    endKey,
    unshift,
    insertAfter,
    insertBefore,
    remove,
    isEmpty,
    attach,
    iterate,
    iterateBack,
    empty,
    toArray,
    validate
  };
}

// node_modules/basicprimitives/src/algorithms/getMergedRectangles.js
function getMergedRectangles(thisArg, items, onItem) {
  var index, len, index2, len2, point;
  items.sort(function(a, b) {
    if (a.x == b.x) {
      return a.y - b.y;
    }
    return a.x - b.x;
  });
  var points = [];
  var pointsHash = {};
  for (index = 0, len = items.length; index < len; index += 1) {
    var item = items[index];
    var xs = [item.x, item.right()];
    for (var k = 0; k < xs.length; k += 1) {
      var x = xs[k];
      point = pointsHash[x];
      if (point == null) {
        point = {
          x,
          add: [],
          remove: []
        };
        pointsHash[x] = point;
        points.push(point);
      }
      if (x == item.x) {
        point.add.push(index);
      } else {
        point.remove.push(index);
      }
    }
  }
  points.sort(function(a, b) {
    return a.x - b.x;
  });
  function Range(start2, end2) {
    this.start = start2;
    this.startHead = null;
    this.end = end2;
    this.endHead = null;
    this.overlap = function(range) {
      return !(this.end < range.start || this.start > range.end);
    };
  }
  function Stripe(x2, ranges2) {
    this.x = x2;
    this.ranges = ranges2;
  }
  var active = {};
  var stripes = [];
  stripes.push(new Stripe(null, []));
  for (index = 0, len = points.length; index < len; index += 1) {
    point = points[index];
    for (index2 = 0, len2 = point.add.length; index2 < len2; index2 += 1) {
      active[point.add[index2]] = true;
    }
    for (index2 = 0, len2 = point.remove.length; index2 < len2; index2 += 1) {
      delete active[point.remove[index2]];
    }
    var activeRects = [];
    for (var key in active) {
      if (active.hasOwnProperty(key)) {
        activeRects.push(items[key]);
      }
    }
    activeRects.sort(function(a, b) {
      return a.y - b.y;
    });
    var ranges = [];
    var start = null;
    var end = null;
    for (index2 = 0, len2 = activeRects.length; index2 < len2; index2 += 1) {
      var activeRect = activeRects[index2];
      if (start == null) {
        start = activeRect.y;
        end = activeRect.bottom();
      } else {
        if (end < activeRect.y) {
          ranges.push(new Range(start, end));
          start = activeRect.y;
          end = activeRect.bottom();
        } else {
          end = Math.max(end, activeRect.bottom());
        }
      }
    }
    if (start != null) {
      ranges.push(new Range(start, end));
    }
    stripes.push(new Stripe(point.x, ranges));
  }
  var lists = [];
  var heads = {};
  var counter = 1;
  function Head(isHead, list2) {
    this.isHead = isHead;
    this.list = list2;
    if (!heads.hasOwnProperty(list2)) {
      heads[list2] = [];
    }
    heads[list2].push(this);
    this.add = function(segment) {
      if (!segment.from.equalTo(segment.to)) {
        if (this.isHead) {
          lists[this.list].add(counter, segment);
          counter += 1;
        } else {
          lists[this.list].unshift(counter, segment);
          counter += 1;
        }
      }
    };
    this.getTail = function() {
      return new Head(!this.isHead, this.list);
    };
    this.attach = function(head) {
      if (this.list != head.list) {
        lists[this.list].attach(lists[head.list]);
        var refs = heads[head.list];
        delete heads[head.list];
        if (refs != null) {
          for (var index3 = 0, len3 = refs.length; index3 < len3; index3 += 1) {
            var ref = refs[index3];
            if (ref != head) {
              ref.list = this.list;
              heads[this.list].push(ref);
            }
          }
        }
      }
    };
  }
  function createHead(isHead) {
    lists.push(new LinkedHashItems());
    return new Head(isHead, lists.length - 1);
  }
  for (index = 1, len = stripes.length; index < len; index += 1) {
    var prev = stripes[index - 1];
    var curr = stripes[index];
    var pi = 0, ci = 0;
    while (pi < prev.ranges.length || ci < curr.ranges.length) {
      var pr = pi < prev.ranges.length ? prev.ranges[pi] : null;
      var cr = ci < curr.ranges.length ? curr.ranges[ci] : null;
      if (cr == null) {
        points = [
          new Point(prev.x, pr.end),
          new Point(curr.x, pr.end),
          new Point(curr.x, pr.start),
          new Point(prev.x, pr.start)
        ];
        for (var pindex = 1; pindex < points.length; pindex += 1) {
          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));
        }
        pr.endHead.attach(pr.startHead);
        pi += 1;
        continue;
      }
      if (pr == null) {
        cr.endHead = createHead(true);
        cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));
        cr.startHead = cr.endHead.getTail();
        ci += 1;
        continue;
      }
      if (!cr.overlap(pr)) {
        if (pr.start < cr.start) {
          points = [
            new Point(prev.x, pr.end),
            new Point(curr.x, pr.end),
            new Point(curr.x, pr.start),
            new Point(prev.x, pr.start)
          ];
          for (pindex = 1; pindex < points.length; pindex += 1) {
            pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));
          }
          pr.endHead.attach(pr.startHead);
          pi += 1;
          continue;
        } else {
          cr.endHead = createHead(true);
          cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));
          cr.startHead = cr.endHead.getTail();
          ci += 1;
          continue;
        }
      } else {
        points = [
          new Point(prev.x, pr.start),
          new Point(curr.x, pr.start),
          new Point(curr.x, cr.start)
        ];
        for (pindex = 1; pindex < points.length; pindex += 1) {
          pr.startHead.add(new Vector(points[pindex], points[pindex - 1]));
        }
        cr.startHead = pr.startHead;
        var loop2 = true;
        while (loop2) {
          loop2 = false;
          if (pr.end > cr.end) {
            var nextcr = ci + 1 < curr.ranges.length ? curr.ranges[ci + 1] : null;
            if (nextcr != null && nextcr.overlap(pr)) {
              var p1 = new Point(curr.x, nextcr.start);
              var p2 = new Point(curr.x, cr.end);
              cr.endHead = createHead(true);
              cr.endHead.add(new Vector(p1, p2));
              nextcr.startHead = cr.endHead.getTail();
              ci += 1;
              cr = nextcr;
              loop2 = true;
            }
          } else {
            var nextpr = pi + 1 < prev.ranges.length ? prev.ranges[pi + 1] : null;
            if (nextpr != null && nextpr.overlap(cr)) {
              points = [
                new Point(prev.x, pr.end),
                new Point(curr.x, pr.end),
                new Point(curr.x, nextpr.start),
                new Point(prev.x, nextpr.start)
              ];
              for (pindex = 1; pindex < points.length; pindex += 1) {
                pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));
              }
              pr.endHead.attach(nextpr.startHead);
              pi += 1;
              pr = nextpr;
              loop2 = true;
            }
          }
        }
        points = [
          new Point(prev.x, pr.end),
          new Point(curr.x, pr.end),
          new Point(curr.x, cr.end)
        ];
        for (pindex = 1; pindex < points.length; pindex += 1) {
          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));
        }
        cr.endHead = pr.endHead;
        pi += 1;
        ci += 1;
      }
    }
  }
  if (onItem != null) {
    for (index = 0; index < lists.length; index += 1) {
      if (heads.hasOwnProperty(index)) {
        var list = lists[index];
        points = [];
        list.iterate(function(segment, key2) {
          if (points.length == 0) {
            points.push(segment.from);
            points.push(segment.to);
          } else {
            points.push(segment.to);
          }
        });
        onItem.call(thisArg, points);
      }
    }
  }
}

// node_modules/basicprimitives/src/algorithms/getMinimumCrossingRows.js
function getMinimumCrossingRows(thisArg, rectangles, onItem) {
  var from = null;
  var to = null;
  if (onItem != null) {
    rectangles.sort(function(a, b) {
      return a.y - b.y;
    });
    for (var index = 0; index < rectangles.length; index += 1) {
      var rect = rectangles[index];
      var bottom = rect.bottom();
      if (from === null) {
        from = rect.y;
        to = bottom;
      } else {
        if (rect.y >= to) {
          onItem.call(thisArg, from);
          from = rect.y;
          to = bottom;
        } else {
          if (rect.y > from) {
            from = rect.y;
          }
          if (bottom < to) {
            to = bottom;
          }
        }
      }
    }
    if (from !== null) {
      onItem.call(thisArg, from);
    }
  }
}

// node_modules/basicprimitives/src/algorithms/mergeSort.js
function mergeSort(arrays, getItemWeight, ignoreDuplicates) {
  var result = null, firstArray, secondArray, mergedArray, arrayIndex, firstIndex, secondIndex, firstLen, secondLen, firstItem, secondItem, firstItemWeight, secondItemWeight, currentValue;
  switch (arrays.length) {
    case 0:
      result = [];
      break;
    default:
      firstArray = [];
      for (arrayIndex = 0; arrayIndex < arrays.length; arrayIndex += 1) {
        secondArray = arrays[arrayIndex];
        mergedArray = [];
        firstLen = firstArray.length;
        secondLen = secondArray.length;
        firstIndex = 0;
        secondIndex = 0;
        firstItem = null;
        firstItemWeight = null;
        secondItem = null;
        secondItemWeight = null;
        if (firstLen > 0) {
          firstItem = firstArray[firstIndex];
          firstItemWeight = !getItemWeight ? firstItem : getItemWeight(firstItem);
        }
        if (secondLen > 0) {
          secondItem = secondArray[secondIndex];
          secondItemWeight = !getItemWeight ? secondItem : getItemWeight(secondItem);
        }
        currentValue = null;
        while (firstIndex < firstLen || secondIndex < secondLen) {
          if (firstIndex >= firstLen) {
            if (!ignoreDuplicates || currentValue != secondItem) {
              mergedArray.push(secondItem);
              currentValue = secondItem;
            }
            secondIndex += 1;
            if (secondIndex < secondLen) {
              secondItem = secondArray[secondIndex];
              secondItemWeight = !getItemWeight ? secondItem : getItemWeight(secondItem);
            }
          } else {
            if (secondIndex >= secondLen) {
              if (!ignoreDuplicates || currentValue != firstItem) {
                mergedArray.push(firstItem);
                currentValue = firstItem;
              }
              firstIndex += 1;
              if (firstIndex < firstLen) {
                firstItem = firstArray[firstIndex];
                firstItemWeight = !getItemWeight ? firstItem : getItemWeight(firstItem);
              }
            } else {
              if (firstItemWeight < secondItemWeight) {
                if (!ignoreDuplicates || currentValue != firstItem) {
                  mergedArray.push(firstItem);
                  currentValue = firstItem;
                }
                firstIndex += 1;
                if (firstIndex < firstLen) {
                  firstItem = firstArray[firstIndex];
                  firstItemWeight = !getItemWeight ? firstItem : getItemWeight(firstItem);
                }
              } else {
                if (!ignoreDuplicates || currentValue != secondItem) {
                  mergedArray.push(secondItem);
                  currentValue = secondItem;
                }
                secondIndex += 1;
                if (secondIndex < secondLen) {
                  secondItem = secondArray[secondIndex];
                  secondItemWeight = !getItemWeight ? secondItem : getItemWeight(secondItem);
                }
              }
            }
          }
        }
        firstArray = mergedArray;
      }
      result = firstArray;
      break;
  }
  return result;
}

// node_modules/basicprimitives/src/algorithms/getMergedIntervals.js
function IntervalPoint(value, index, isStart) {
  this.value = value;
  this.index = index;
  this.isStart = isStart;
}
function getMergedIntervals(thisArg, items, onItem) {
  var points = [];
  for (var index = 0; index < items.length; index += 1) {
    var item = items[index];
    points.push(new IntervalPoint(item.from, index, true));
    points.push(new IntervalPoint(item.to, index, false));
  }
  points.sort(function(a, b) {
    if (a.value === b.value) {
      return b.isStart - a.isStart;
    }
    return a.value - b.value;
  });
  var counter = 0;
  var interval = null;
  var logicalIndex = null;
  for (var index = 0, len = points.length; index < len; index += 1) {
    var point = points[index];
    if (interval == null) {
      interval = new Interval(items[point.index]);
    }
    interval.to = point.value;
    if (point.isStart) {
      counter++;
      if (logicalIndex === null || logicalIndex > point.index) {
        logicalIndex = point.index;
        interval.context = items[point.index].context;
      }
    } else {
      counter--;
    }
    if (!counter) {
      if (onItem != null) {
        onItem.call(thisArg, interval);
      }
      interval = null;
      logicalIndex = null;
    }
  }
}

// node_modules/basicprimitives/src/algorithms/Tree.js
function Tree(source) {
  var _nodes = {}, _parents = {}, _children = {}, _roots = {}, _rootChildren = {}, BREAK = 1, SKIP = 2;
  _init(source);
  function _init(source2) {
    if (isObject(source2)) {
      _nodes = cloneObject(source2.nodes, true);
      _parents = cloneObject(source2.parents, true);
      _children = cloneObject(source2.children, false);
      _roots = cloneObject(source2.roots, false);
      _rootChildren = cloneObject(source2.rootChildren, true);
    }
  }
  function loop2(thisArg, onItem) {
    var item;
    if (onItem != null) {
      for (item in _nodes) {
        if (_nodes.hasOwnProperty(item)) {
          if (onItem.call(thisArg, item, _nodes[item])) {
            break;
          }
        }
      }
    }
  }
  function loopLevels(thisArg, arg0, arg1) {
    var levelIndex = 0, items = [], itemid, onItem, newItems, key, index, len;
    switch (arguments.length) {
      case 2:
        onItem = arg0;
        break;
      case 3:
        itemid = arg0;
        onItem = arg1;
        break;
    }
    if (onItem != null) {
      if (itemid == null) {
        for (key in _rootChildren) {
          if (_rootChildren.hasOwnProperty(key)) {
            items = items.concat(_rootChildren[key]);
          }
        }
      } else {
        if (_children[itemid] != null) {
          items = items.concat(_children[itemid]);
        }
      }
      while (items.length > 0) {
        newItems = [];
        for (index = 0, len = items.length; index < len; index += 1) {
          itemid = items[index];
          switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {
            case BREAK:
              newItems = [];
              break;
            case SKIP:
              break;
            default:
              if (_children[itemid] != null) {
                newItems = newItems.concat(_children[itemid]);
              }
              break;
          }
        }
        items = newItems;
        levelIndex += 1;
      }
    }
  }
  function loopPostOrder(thisArg, onItem) {
    var stack = [], nodeid, key, index, prevParent, children;
    if (onItem != null) {
      for (key in _rootChildren) {
        if (_rootChildren.hasOwnProperty(key)) {
          stack = stack.concat(_rootChildren[key]);
        }
      }
      while (stack.length > 0) {
        nodeid = stack[stack.length - 1];
        if (nodeid != prevParent && (children = _children[nodeid]) != null) {
          for (index = children.length - 1; index >= 0; index -= 1) {
            stack.push(children[index]);
          }
        } else {
          stack.pop();
          prevParent = _parents[nodeid];
          if (onItem.call(thisArg, nodeid, _nodes[nodeid], prevParent, _nodes[prevParent])) {
            break;
          }
        }
      }
    }
  }
  function loopPreOrder(thisArg, arg0, arg1) {
    var stack = [], nodeid, key, index, parentid2, prevParent, children, startNodeId, onItem;
    switch (arguments.length) {
      case 2:
        onItem = arg0;
        break;
      case 3:
        startNodeId = arg0;
        onItem = arg1;
        break;
    }
    if (onItem != null) {
      if (!node(startNodeId)) {
        for (key in _rootChildren) {
          if (_rootChildren.hasOwnProperty(key)) {
            stack = stack.concat(_rootChildren[key]);
          }
        }
      } else {
        stack.push(startNodeId);
      }
      while (stack.length > 0) {
        nodeid = stack[stack.length - 1];
        if (nodeid != prevParent) {
          parentid2 = _parents[nodeid];
          if (onItem.call(thisArg, nodeid, _nodes[nodeid], parentid2, _nodes[parentid2])) {
            break;
          }
        }
        if (nodeid != prevParent && (children = _children[nodeid]) != null) {
          for (index = children.length - 1; index >= 0; index -= 1) {
            stack.push(children[index]);
          }
        } else {
          stack.pop();
          prevParent = _parents[nodeid];
        }
      }
    }
  }
  function loopEulerWalk(thisArg, onItem) {
    var stack = [], nodeid, levels = [], level = 0, key, index, len, prevParent, children;
    if (onItem != null) {
      for (key in _rootChildren) {
        if (_rootChildren.hasOwnProperty(key)) {
          children = _rootChildren[key];
          for (index = 0, len = children.length; index < len; index += 1) {
            stack.push(children[index]);
            levels.push(0);
          }
        }
      }
      while (stack.length > 0) {
        index = stack.length - 1;
        nodeid = stack[index];
        level = levels[index];
        if (onItem.call(thisArg, nodeid, _nodes[nodeid], level)) {
          break;
        }
        if (nodeid != prevParent && (children = _children[nodeid]) != null) {
          for (index = children.length - 1; index >= 0; index -= 1) {
            stack.push(children[index]);
            levels.push(level + 1);
            if (index > 0) {
              stack.push(nodeid);
              levels.push(level);
            }
          }
        } else {
          stack.pop();
          levels.pop();
          prevParent = _parents[nodeid];
        }
      }
    }
  }
  function zipUp(thisArg, firstNodeId, secondNodeid, onZip) {
    var firstParentId, secondParentId;
    if (onZip != null) {
      while (firstNodeId != null && secondNodeid != null && firstNodeId != secondNodeid) {
        firstParentId = _parents[firstNodeId];
        secondParentId = _parents[secondNodeid];
        if (onZip.call(thisArg, firstNodeId, firstParentId, secondNodeid, secondParentId)) {
          break;
        }
        firstNodeId = firstParentId;
        secondNodeid = secondParentId;
      }
    }
  }
  function loopParents(thisArg, nodeid, onItem, includingStartItem) {
    var parentid2 = nodeid;
    if (_nodes[parentid2] != null) {
      if (onItem != null) {
        if (includingStartItem === true) {
          if (onItem.call(thisArg, parentid2, _nodes[parentid2])) {
            return;
          }
        }
        while ((parentid2 = _parents[parentid2]) != null) {
          if (onItem.call(thisArg, parentid2, _nodes[parentid2])) {
            break;
          }
        }
      }
    }
  }
  function loopChildren(thisArg, nodeid, onItem) {
    var items, itemid, index, len;
    if (_nodes[nodeid] != null) {
      items = _children[nodeid];
      if (items != null) {
        for (index = 0, len = items.length; index < len; index += 1) {
          itemid = items[index];
          if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {
            break;
          }
        }
      }
    }
  }
  function loopChildrenRange(thisArg, nodeid, fromIndex, toIndex, onItem) {
    var items, itemid, index, len;
    if (_nodes[nodeid] != null) {
      items = _children[nodeid];
      if (items != null) {
        if (fromIndex < toIndex) {
          fromIndex = Math.max(fromIndex, 0);
          toIndex = Math.min(toIndex, items.length - 1);
          for (index = fromIndex; index <= toIndex; index += 1) {
            itemid = items[index];
            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {
              break;
            }
          }
        } else {
          fromIndex = Math.min(fromIndex, items.length - 1);
          toIndex = Math.max(0, toIndex);
          for (index = fromIndex; index >= toIndex; index -= 1) {
            itemid = items[index];
            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {
              break;
            }
          }
        }
      }
    }
  }
  function loopChildrenReversed(thisArg, nodeid, onItem) {
    var items, itemid, index, lastIndex;
    if (_nodes[nodeid] != null) {
      items = _children[nodeid];
      lastIndex = items.length - 1;
      if (items != null) {
        for (index = lastIndex; index >= 0; index -= 1) {
          itemid = items[index];
          if (onItem.call(thisArg, itemid, _nodes[itemid], index, lastIndex)) {
            break;
          }
        }
      }
    }
  }
  function arrangeChildren(nodeid, children) {
    var childid, index, len;
    children = children.slice(0);
    if (_nodes[nodeid] != null) {
      if (_children[nodeid] != null) {
        if (_children[nodeid].length == children.length) {
          for (index = 0, len = children.length; index < len; index += 1) {
            childid = children[index];
            if (_parents[childid] != nodeid) {
              throw "Child " + childid + " does not belong to given node!";
            }
          }
          _children[nodeid] = children;
        } else {
          throw "Collections of children don't match each other!";
        }
      } else {
        if (children.length > 0) {
          throw "Collections of children don't match each other!";
        }
      }
    }
  }
  function add(parentid2, nodeid, node2, position) {
    var index, len, children, childid;
    if (_nodes[nodeid] != null) {
      throw "Node already exists";
    }
    if (nodeid != null && node2 != null && _nodes[nodeid] == null) {
      if (_nodes[parentid2] != null) {
        _parents[nodeid] = parentid2;
        if (_children[parentid2] != null) {
          if (position == null) {
            _children[parentid2].push(nodeid);
          } else {
            _children[parentid2].splice(position, 0, nodeid);
          }
        } else {
          _children[parentid2] = [nodeid];
        }
      } else {
        _roots[nodeid] = parentid2;
        if (_rootChildren[parentid2] != null) {
          if (position == null) {
            _rootChildren[parentid2].push(nodeid);
          } else {
            _rootChildren[parentid2].splice(position, 0, nodeid);
          }
        } else {
          _rootChildren[parentid2] = [nodeid];
        }
      }
      _nodes[nodeid] = node2;
      if (_rootChildren[nodeid] != null) {
        _children[nodeid] = _rootChildren[nodeid];
        delete _rootChildren[nodeid];
        children = _children[nodeid];
        for (index = 0, len = children.length; index < len; index += 1) {
          childid = children[index];
          delete _roots[childid];
          _parents[childid] = nodeid;
        }
      }
    }
  }
  function insert(nodeid, bundleid, bundle) {
    if (_nodes[nodeid] != null && bundleid != null && _nodes[bundleid] == null && bundle != null) {
      _nodes[bundleid] = bundle;
      if (_children[nodeid] != null) {
        _children[bundleid] = _children[nodeid];
      }
      _children[nodeid] = [bundleid];
      loopChildren(this, bundleid, function(childid, node2, index) {
        _parents[childid] = bundleid;
      });
      _parents[bundleid] = nodeid;
    }
  }
  function moveChildren(fromNodeid, toNodeId) {
    if (_nodes[fromNodeid] != null && _nodes[toNodeId] != null && fromNodeid != toNodeId) {
      if (_children[fromNodeid] != null) {
        loopChildren(this, fromNodeid, function(childid, node2, index) {
          _parents[childid] = toNodeId;
        });
        if (_children[toNodeId] != null) {
          _children[toNodeId] = _children[toNodeId].concat(_children[fromNodeid]);
        } else {
          _children[toNodeId] = _children[fromNodeid];
        }
        delete _children[fromNodeid];
      }
    }
  }
  function hasNodes() {
    return !isEmptyObject(_rootChildren);
  }
  function parentid(nodeid) {
    var result = null;
    if (_parents[nodeid] != null) {
      result = _parents[nodeid];
    }
    return result;
  }
  function parent(nodeid) {
    var result = null;
    if (_parents[nodeid] != null) {
      result = _nodes[_parents[nodeid]];
    }
    return result;
  }
  function hasChildren(nodeid) {
    return _children[nodeid] != null;
  }
  function countChildren(nodeid) {
    return _children[nodeid] != null ? _children[nodeid].length : 0;
  }
  function countSiblings(nodeid) {
    var parent2 = parentid(nodeid);
    return parent2 != null ? _children[parent2].length : 0;
  }
  function indexOf(nodeid) {
    var parent2 = parentid(nodeid);
    return parent2 != null ? _children[parent2].findIndex((itemid) => itemid === nodeid) : null;
  }
  function getChild(parentid2, index) {
    var result = null, children;
    if ((children = _children[parentid2]) != null) {
      result = _nodes[children[index]];
    }
    return result;
  }
  function _splice(collection, nodeid) {
    var index, len = collection.length;
    for (index = 0; index < len; index += 1) {
      if (collection[index] == nodeid) {
        collection.splice(index, 1);
        return len - 1;
      }
    }
    return len;
  }
  function adopt(parentid2, nodeid) {
    if (_nodes[parentid2] != null && _nodes[nodeid] != null) {
      if (parentid2 != nodeid) {
        if (_roots.hasOwnProperty(nodeid)) {
          if (!_splice(_rootChildren[_roots[nodeid]], nodeid)) {
            delete _rootChildren[_roots[nodeid]];
          }
          delete _roots[nodeid];
        }
        if (_parents.hasOwnProperty(nodeid)) {
          if (!_splice(_children[_parents[nodeid]], nodeid)) {
            delete _children[_parents[nodeid]];
          }
        }
        _parents[nodeid] = parentid2;
        if (_children[parentid2] != null) {
          _children[parentid2].push(nodeid);
        } else {
          _children[parentid2] = [nodeid];
        }
      } else {
        throw "Item cannot be parent of itself!";
      }
    } else {
      throw "Both parent and child should be in hierarchy!";
    }
  }
  function node(nodeid) {
    return _nodes[nodeid];
  }
  function validate() {
    var result = true, key;
    for (key in _roots) {
      if (_roots.hasOwnProperty(key)) {
        if (_roots[key] != null) {
          result = false;
          break;
        }
      }
    }
    return result;
  }
  function clone() {
    return Tree({
      nodes: _nodes,
      parents: _parents,
      children: _children,
      roots: _roots,
      rootChildren: _rootChildren
    });
  }
  function loopNeighbours(thisArg, itemid, distance, onItem) {
    var processed = {}, margin = [itemid], newMargin, currentDistance = 0;
    if (onItem != null) {
      if (_nodes.hasOwnProperty(itemid)) {
        processed[itemid] = true;
        while (margin.length > 0) {
          newMargin = [];
          for (var index = 0, len = margin.length; index < len; index += 1) {
            var marginid = margin[index];
            if (currentDistance > 0) {
              if (onItem.call(thisArg, marginid, _nodes[marginid], currentDistance)) {
                return;
              }
            }
            if (currentDistance < distance) {
              _loopNeighbours(this, marginid, function(neighbourid, neighbour) {
                if (!processed.hasOwnProperty(neighbourid)) {
                  newMargin.push(neighbourid);
                  processed[neighbourid] = true;
                }
              });
            }
          }
          margin = newMargin;
          currentDistance += 1;
        }
      }
    }
  }
  function _loopNeighbours(thisArg, itemid, onItem) {
    if (onItem != null) {
      if (_nodes.hasOwnProperty(itemid)) {
        var parentItemId = parentid(itemid);
        if (parentItemId != null) {
          if (onItem.call(thisArg, parentItemId, _nodes[parentItemId])) {
            return;
          }
        }
        loopChildren(thisArg, parentItemId, function(childItemId, childItem) {
          if (childItemId != itemid) {
            if (onItem.call(thisArg, childItemId, childItem)) {
              return;
            }
          }
        });
        loopChildren(thisArg, itemid, function(childItemId, childItem) {
          if (onItem.call(thisArg, childItemId, childItem)) {
            return;
          }
        });
      }
    }
  }
  return {
    loop: loop2,
    loopLevels,
    loopParents,
    loopChildren,
    loopChildrenRange,
    loopChildrenReversed,
    loopPostOrder,
    /* children first - parent last */
    loopPreOrder,
    /* parent first - children next */
    loopEulerWalk,
    /* pre order loop with every parent revisited for every child */
    loopNeighbours,
    /* loop items by distance. Siblings are as far as parent and children */
    zipUp,
    parentid,
    parent,
    adopt,
    moveChildren,
    node,
    add,
    insert,
    hasNodes,
    hasChildren,
    countChildren,
    countSiblings,
    indexOf,
    getChild,
    arrangeChildren,
    /* force validation */
    validate,
    clone,
    // callback return codes
    BREAK,
    // break loop immidiatly
    SKIP
    // skip loop of current node children 
  };
}

// node_modules/basicprimitives/src/algorithms/FibonacciHeap.js
function HeapResult(node) {
  this.key = node.key;
  this.priority = node.priority;
  this.item = node.item;
}
function FibonacciHeap(isMaximum) {
  var root = null, count = 0, nodes = {};
  function Node(key, priority, item) {
    this.key = key;
    this.priority = priority;
    this.item = item;
    this.degree = 0;
    this.marked = false;
    this.parent = null;
    this.child = null;
    this.left = null;
    this.right = null;
  }
  function validate() {
    var totalNodes = 0;
    for (var key in nodes) {
      if (nodes.hasOwnProperty(key)) {
        var node = nodes[key];
        totalNodes += 1;
        if (node.child != null) {
          if (!nodes.hasOwnProperty(node.child)) {
            throw "Child does not exists";
          }
          var ref = nodes[node.child];
          if (ref.parent != node.key) {
            throw "Child references wrong parent";
          }
        }
        if (node.parent != null) {
          if (!nodes.hasOwnProperty(node.parent)) {
            throw "Parent does not exists";
          }
        }
        if (node.left != null) {
          if (!nodes.hasOwnProperty(node.left)) {
            throw "Left does not exists";
          }
          ref = nodes[node.left];
          if (ref.right != node.key) {
            throw "Left references wrong right";
          }
        }
        if (node.right != null) {
          if (!nodes.hasOwnProperty(node.right)) {
            throw "Right does not exists";
          }
          ref = nodes[node.right];
          if (ref.left != node.key) {
            throw "Right references wrong left";
          }
        }
      }
    }
    if (root == null && totalNodes > 0) {
      throw "Orphans";
    }
    if (root != null) {
      if (!nodes.hasOwnProperty(root)) {
        throw "Root node does not exists";
      }
      node = nodes[root];
      if (node.parent != null) {
        throw "Root node has parent reference";
      }
      var children = [root];
      var processed = {};
      var totalChildren = 0;
      while (children.length > 0) {
        var newChildren = [];
        for (var index = 0, len = children.length; index < len; index += 1) {
          var child = nodes[children[index]];
          while (!processed.hasOwnProperty(child.key)) {
            processed[child.key] = true;
            totalChildren += 1;
            if (child.child != null) {
              newChildren.push(child.child);
            }
            child = nodes[child.right];
          }
        }
        children = newChildren;
      }
      if (totalNodes != totalChildren) {
        throw "Tree has loops or orpants";
      }
    }
  }
  function add(key, priority, item) {
    if (nodes.hasOwnProperty(key)) {
      throw "Duplicate keys are not supported!";
    }
    var newNode = new Node(key, priority, item);
    nodes[key] = newNode;
    if (root == null) {
      newNode.left = key;
      newNode.right = key;
      root = key;
    } else {
      var rootNode = nodes[root];
      _insert(rootNode, newNode);
      if (isMaximum ? rootNode.priority < newNode.priority : rootNode.priority > newNode.priority) {
        root = key;
      }
    }
    count += 1;
  }
  function _insert(node, newNode) {
    var rightNode = nodes[node.right];
    newNode.right = node.right;
    newNode.left = node.key;
    node.right = newNode.key;
    rightNode.left = newNode.key;
  }
  function _exclude(node) {
    var prevNode = nodes[node.left], nextNode = nodes[node.right];
    prevNode.right = nextNode.key;
    nextNode.left = prevNode.key;
    node.right = node.key;
    node.left = node.key;
  }
  function getPriority(key) {
    var result = null;
    if (nodes.hasOwnProperty(key)) {
      result = nodes[key].priority;
    }
    return result;
  }
  function heapRoot() {
    var result = null;
    if (root != null) {
      result = new HeapResult(nodes[root]);
    }
    return result;
  }
  function extractRoot() {
    var result = heapRoot();
    if (result != null) {
      var rootNode = nodes[root], nextNode = nodes[rootNode.right];
      if (rootNode.child != null) {
        var childNode = nodes[rootNode.child], childNodeLeft = nodes[childNode.left];
        rootNode.right = childNode.key;
        nextNode.left = childNodeLeft.key;
        childNode.left = rootNode.key;
        childNodeLeft.right = nextNode.key;
        _exclude(rootNode);
        delete nodes[rootNode.key];
        root = null;
        _consolidate(childNode.key);
      } else {
        _exclude(rootNode);
        delete nodes[rootNode.key];
        root = null;
        if (nextNode.key != rootNode.key) {
          _consolidate(nextNode.key);
        }
      }
      count -= 1;
    }
    return result;
  }
  function _consolidate(startKey) {
    var pairs = [], pairedNode, processed = {}, key = startKey;
    while (!processed.hasOwnProperty(key)) {
      var node = nodes[key], nextKey = node.right;
      processed[key] = true;
      node.parent = null;
      while ((pairedNode = pairs[node.degree]) != null) {
        if (isMaximum ? node.priority > pairedNode.priority : node.priority < pairedNode.priority) {
          _union(node, pairedNode);
        } else {
          _union(pairedNode, node);
          node = pairedNode;
        }
        pairs[node.degree - 1] = null;
      }
      pairs[node.degree] = node;
      if (root == null || nodes[root] == null || (isMaximum ? nodes[root].priority <= node.priority : nodes[root].priority >= node.priority)) {
        root = node.key;
      }
      key = nextKey;
    }
  }
  function _union(node1, node2) {
    node1.degree += 1;
    _exclude(node2);
    var child = nodes[node1.child];
    if (child != null) {
      _insert(child, node2);
      if (isMaximum ? child.priority < node2.priority : child.priority > node2.priority) {
        node1.child = node2.key;
      }
    } else {
      node1.child = node2.key;
    }
    node2.parent = node1.key;
  }
  function setPriority(key, priority) {
    var node = nodes[key];
    if (isMaximum ? node.priority > priority : node.priority < priority) {
      throw "Priority increase is not supported";
    }
    node.priority = priority;
    if (node.parent != null) {
      var parentNode = nodes[node.parent];
      if (isMaximum ? parentNode.priority < node.priority : parentNode.priority > node.priority) {
        _cut(parentNode, node);
        _cascadeCut(parentNode);
      }
    }
    if (isMaximum ? nodes[root].priority < node.priority : nodes[root].priority > node.priority) {
      root = node.key;
    }
  }
  function _cut(parentNode, node) {
    node.marked = false;
    node.parent = null;
    if (node.right == node.key) {
      parentNode.child = null;
    } else {
      parentNode.child = node.right;
      _exclude(node);
    }
    parentNode.degree -= 1;
    _insert(nodes[root], node);
  }
  function _cascadeCut(node) {
    if (node.parent != null) {
      if (node.marked) {
        var parentNode = nodes[node.parent];
        _cut(parentNode, node);
        _cascadeCut(parentNode);
      } else {
        node.marked = true;
      }
    }
  }
  function deleteKey(key) {
    setPriority(key, isMaximum ? Infinity : -1);
    extractRoot();
  }
  return {
    add,
    getPriority,
    setPriority,
    heapRoot,
    extractRoot,
    deleteKey,
    validate
  };
}

// node_modules/basicprimitives/src/algorithms/Graph.js
function Graph() {
  var _edges = {}, MAXIMUMTOTALWEIGHT = 1, MINIMUMWEIGHT = 2;
  function addEdge(from, to, edge2) {
    if ((_edges[from] == null || _edges[from][to] == null) && edge2 != null) {
      if (_edges[from] == null) {
        _edges[from] = {};
      }
      _edges[from][to] = edge2;
      if (_edges[to] == null) {
        _edges[to] = {};
      }
      _edges[to][from] = edge2;
    }
  }
  function edge(from, to) {
    var result = null;
    if (_edges[from] != null && _edges[from][to]) {
      result = _edges[from][to];
    }
    return result;
  }
  function hasNode(from) {
    return _edges.hasOwnProperty(from);
  }
  function loopNodeEdges(thisArg, itemid, onEdge) {
    var neighbours, neighbourKey;
    if (onEdge != null) {
      neighbours = _edges[itemid];
      if (neighbours != null) {
        for (neighbourKey in neighbours) {
          if (neighbours.hasOwnProperty(neighbourKey)) {
            onEdge.call(thisArg, neighbourKey, neighbours[neighbourKey]);
          }
        }
      }
    }
  }
  function loopNodes(thisArg, startNode, onItem) {
    var processed = {};
    if (startNode == null) {
      for (startNode in _edges) {
        if (_edges.hasOwnProperty(startNode)) {
          if (!processed.hasOwnProperty[startNode]) {
            _loopNodes(thisArg, startNode, processed, onItem);
          }
        }
      }
    } else {
      _loopNodes(thisArg, startNode, processed, onItem);
    }
  }
  function _loopNodes(thisArg, startNode, processed, onItem) {
    var margin = [], marginKey, newMargin, index, len, neighbours, neighbourKey;
    margin.push(startNode);
    processed[startNode] = true;
    if (onItem != null) {
      while (margin.length > 0) {
        newMargin = [];
        for (index = 0, len = margin.length; index < len; index += 1) {
          marginKey = margin[index];
          if (onItem.call(thisArg, marginKey)) {
            return;
          }
          neighbours = _edges[marginKey];
          for (neighbourKey in neighbours) {
            if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {
              processed[neighbourKey] = true;
              newMargin.push(neighbourKey);
            }
          }
        }
        margin = newMargin;
      }
    }
  }
  function getSpanningTree(startNode, getWeightFunc) {
    var result = Tree(), margin = FibonacciHeap(true), marginNode, parents = {}, neighbours, neighbourKey, neighbourWeight, currentWeight;
    margin.add(
      startNode,
      0,
      null
      /*parent of root node is null*/
    );
    parents[startNode] = null;
    while ((marginNode = margin.extractRoot()) != null) {
      neighbours = _edges[marginNode.key];
      for (neighbourKey in neighbours) {
        if (neighbours.hasOwnProperty(neighbourKey) && !result.node(neighbourKey)) {
          neighbourWeight = getWeightFunc != null ? getWeightFunc(neighbours[neighbourKey]) : neighbours[neighbourKey];
          currentWeight = margin.getPriority(neighbourKey);
          if (currentWeight == null) {
            margin.add(neighbourKey, neighbourWeight, null);
            parents[neighbourKey] = marginNode.key.toString();
          } else {
            if (currentWeight <= neighbourWeight) {
              margin.setPriority(neighbourKey, neighbourWeight);
              parents[neighbourKey] = marginNode.key.toString();
            }
          }
        }
      }
      result.add(parents[marginNode.key], marginNode.key.toString(), {});
    }
    return result;
  }
  function _findStartNode(thisArg, onEdgeWeight) {
    var result = null, fromItem, toItems, toItem, weight = 0, maxWeight = null;
    for (fromItem in _edges) {
      if (_edges.hasOwnProperty(fromItem)) {
        toItems = _edges[fromItem];
        weight = 0;
        for (toItem in toItems) {
          if (toItems.hasOwnProperty(toItem)) {
            weight += onEdgeWeight.call(thisArg, toItems[toItem], fromItem, toItem);
          }
        }
        if (weight > maxWeight || maxWeight == null) {
          result = fromItem;
          maxWeight = weight;
        }
      }
    }
    return result;
  }
  function getTotalWeightGrowthSequence(thisArg, onEdgeWeight, onItem) {
    var startNode = _findStartNode(thisArg, onEdgeWeight);
    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MAXIMUMTOTALWEIGHT);
  }
  function getMinimumWeightGrowthSequence(thisArg, startNode, onEdgeWeight, onItem) {
    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MINIMUMWEIGHT);
  }
  function _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, growsMode) {
    var margin = {}, marginKey, itemsToRemove = [], hasNeighbours, processed = {}, marginLength = 0, nextMarginKey, nextMarginWeight, bestWeight, neighbours, neighbourKey, neighbourWeight, index, len;
    if (onEdgeWeight != null && onItem != null) {
      if (startNode == null) {
        startNode = _findStartNode(thisArg, onEdgeWeight);
      }
      if (startNode != null) {
        onItem.call(thisArg, startNode);
        margin[startNode] = true;
        marginLength += 1;
        processed[startNode] = null;
        while (marginLength > 0) {
          itemsToRemove = [];
          nextMarginKey = null;
          nextMarginWeight = null;
          bestWeight = {};
          for (marginKey in margin) {
            if (margin.hasOwnProperty(marginKey)) {
              neighbours = _edges[marginKey];
              hasNeighbours = false;
              for (neighbourKey in neighbours) {
                if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {
                  neighbourWeight = onEdgeWeight.call(thisArg, neighbours[neighbourKey], marginKey, neighbourKey);
                  hasNeighbours = true;
                  switch (growsMode) {
                    case MAXIMUMTOTALWEIGHT:
                      if (bestWeight[neighbourKey] == null) {
                        bestWeight[neighbourKey] = 0;
                      }
                      bestWeight[neighbourKey] += neighbourWeight;
                      if (!nextMarginWeight || bestWeight[neighbourKey] > nextMarginWeight) {
                        nextMarginKey = neighbourKey;
                        nextMarginWeight = bestWeight[neighbourKey];
                      }
                      break;
                    case MINIMUMWEIGHT:
                      if (bestWeight[neighbourKey] == null) {
                        bestWeight[neighbourKey] = neighbourWeight;
                      } else {
                        bestWeight[neighbourKey] = Math.min(bestWeight[neighbourKey], neighbourWeight);
                      }
                      if (!nextMarginWeight || bestWeight[neighbourKey] < nextMarginWeight) {
                        nextMarginKey = neighbourKey;
                        nextMarginWeight = bestWeight[neighbourKey];
                      }
                      break;
                  }
                }
              }
              if (!hasNeighbours) {
                itemsToRemove.push(marginKey);
              }
            }
          }
          if (nextMarginKey == null) {
            break;
          } else {
            margin[nextMarginKey] = true;
            marginLength += 1;
            processed[nextMarginKey] = true;
            onItem.call(thisArg, nextMarginKey);
          }
          for (index = 0, len = itemsToRemove.length; index < len; index += 1) {
            delete margin[itemsToRemove[index]];
            marginLength -= 1;
          }
        }
      }
    }
  }
  function getShortestPath(thisArg, startNode, endNodes, getWeightFunc, onPathFound) {
    var margin = FibonacciHeap(false), distance = {}, breadcramps = {}, bestNodeOnMargin, key, children, newDistance, weight, path, currentNode, endNodesHash = {}, index, len, endsCount = 0, endsFound = 0;
    for (index = 0, len = endNodes.length; index < len; index += 1) {
      key = endNodes[index];
      if (!endNodesHash.hasOwnProperty(key)) {
        endsCount += 1;
        endNodesHash[key] = true;
      }
    }
    margin.add(startNode, 0, null);
    breadcramps[startNode] = null;
    while ((bestNodeOnMargin = margin.extractRoot()) != null) {
      children = _edges[bestNodeOnMargin.key];
      for (key in children) {
        if (children.hasOwnProperty(key)) {
          weight = 1;
          if (getWeightFunc != null) {
            weight = getWeightFunc.call(thisArg, children[key], bestNodeOnMargin, key);
            newDistance = bestNodeOnMargin.priority + weight;
          } else {
            newDistance = bestNodeOnMargin.priority + 1;
          }
          if (weight >= 0) {
            distance = margin.getPriority(key);
            if (distance != null) {
              if (distance > newDistance) {
                margin.setPriority(key, newDistance);
                breadcramps[key] = bestNodeOnMargin.key;
              }
            } else {
              if (!breadcramps.hasOwnProperty(key)) {
                margin.add(key, newDistance, null);
                breadcramps[key] = bestNodeOnMargin.key;
              }
            }
          }
        }
      }
      if (endNodesHash.hasOwnProperty(bestNodeOnMargin.key)) {
        path = [];
        currentNode = bestNodeOnMargin.key;
        while (currentNode != null) {
          path.push(currentNode);
          currentNode = breadcramps[currentNode];
        }
        onPathFound.call(thisArg, path, bestNodeOnMargin.key);
        endsFound += 1;
        if (endsFound >= endsCount) {
          break;
        }
      }
    }
  }
  function dfsPath(thisArg, startNode, endNode, onEdge) {
    var margin = [], backtrace = {};
    margin.push(startNode);
    backtrace[startNode] = null;
    if (startNode != endNode) {
      while (margin.length > 0 && !backtrace.hasOwnProperty(endNode)) {
        var currentNode = margin[margin.length - 1];
        margin.length -= 1;
        var neighbours = _edges[currentNode];
        for (var neighbour in neighbours) {
          if (neighbours.hasOwnProperty(neighbour)) {
            if (!backtrace.hasOwnProperty(neighbour)) {
              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {
                margin.push(neighbour);
                backtrace[neighbour] = currentNode;
                if (neighbour == endNode) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    currentNode = endNode;
    var path = [];
    while (backtrace.hasOwnProperty(currentNode)) {
      path.push(currentNode);
      currentNode = backtrace[currentNode];
    }
    var result = [];
    if (path.length > 0) {
      for (var index = path.length - 1; index >= 0; index -= 1) {
        result.push(path[index]);
      }
    }
    return result;
  }
  function getLevelGraph(thisArg, startNode, onEdge) {
    var level = {}, margin = [], currentNode, currentLevel, neighbours;
    margin.push(startNode);
    level[startNode] = 1;
    while (margin.length > 0) {
      var newMargin = [];
      for (var index = 0, len = margin.length; index < len; index += 1) {
        currentNode = margin[index];
        currentLevel = level[currentNode];
        neighbours = _edges[currentNode];
        for (var neighbour in neighbours) {
          if (neighbours.hasOwnProperty(neighbour)) {
            if (!level.hasOwnProperty(neighbour)) {
              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {
                newMargin.push(neighbour);
                level[neighbour] = currentLevel + 1;
              }
            }
          }
        }
      }
      margin = newMargin;
    }
    var levelGraph = Graph();
    for (currentNode in _edges) {
      if (level.hasOwnProperty(currentNode)) {
        currentLevel = level[currentNode];
        neighbours = _edges[currentNode];
        for (neighbour in neighbours) {
          if (level.hasOwnProperty(neighbour)) {
            var neighbourLevel = level[neighbour];
            if (currentLevel + 1 == neighbourLevel) {
              levelGraph.addEdge(currentNode, neighbour, neighbours[neighbour]);
            }
          }
        }
      }
    }
    return levelGraph;
  }
  function dfsLoop(thisArg, startNode, onEdge, onNode) {
    var margin = [], visited = {}, currentNode;
    margin.push(startNode);
    visited[startNode] = true;
    while (margin.length > 0) {
      currentNode = margin[margin.length - 1];
      margin.length -= 1;
      var neighbours = _edges[currentNode];
      for (var neighbour in neighbours) {
        if (neighbours.hasOwnProperty(neighbour)) {
          if (!visited.hasOwnProperty(neighbour)) {
            if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {
              margin.push(neighbour);
              visited[neighbour] = true;
              if (onNode.call(thisArg, neighbour)) {
                return;
              }
            }
          }
        }
      }
    }
  }
  return {
    addEdge,
    edge,
    hasNode,
    loopNodes,
    loopNodeEdges,
    getSpanningTree,
    getTotalWeightGrowthSequence,
    getMinimumWeightGrowthSequence,
    getShortestPath,
    dfsPath,
    getLevelGraph,
    dfsLoop
  };
}

// node_modules/basicprimitives/src/algorithms/Family.js
function FamilyNode(id, node) {
  this.id = id;
  this.node = node;
}
function Family(source) {
  var _roots = {}, _rootsCount = {}, _children = {}, _childrenCount = {}, _parents = {}, _parentsCount = {}, _nodes = {}, BREAK = 1, SKIP = 2;
  _init(source);
  function _init(source2) {
    if (isObject(source2)) {
      _roots = cloneObject(source2.roots, false);
      _rootsCount = cloneObject(source2.rootsCount, true);
      _children = cloneObject(source2.children, false);
      _childrenCount = cloneObject(source2.childrenCount, true);
      _parents = cloneObject(source2.parents, false);
      _parentsCount = cloneObject(source2.parentsCount, true);
      _nodes = cloneObject(source2.nodes, true);
    }
  }
  function _loop(thisArg, collection, itemid, onItem) {
    var item, items;
    if (onItem != null) {
      items = collection[itemid];
      if (items != null) {
        for (item in items) {
          if (items.hasOwnProperty(item)) {
            if (onItem.call(thisArg, item, items[item])) {
              break;
            }
          }
        }
      }
    }
  }
  function add(parents, nodeid, node2) {
    var index, len, parentid, processed = {};
    if (!parents || parents.length === 0) {
      parents = [null];
    }
    if (_nodes[nodeid] == null && node2 != null) {
      _nodes[nodeid] = node2;
      for (index = 0, len = parents.length; index < len; index += 1) {
        parentid = parents[index];
        if (processed[parentid] == null && parentid != nodeid) {
          processed[parentid] = true;
          if (_nodes[parentid] != null) {
            if (_parents[nodeid] == null) {
              _parents[nodeid] = {};
              _parentsCount[nodeid] = 0;
            }
            if (!_parents[nodeid][parentid]) {
              _parents[nodeid][parentid] = true;
              _parentsCount[nodeid] += 1;
            }
            if (_children[parentid] == null) {
              _children[parentid] = {};
              _childrenCount[parentid] = 0;
            }
            if (!_children[parentid][nodeid]) {
              _children[parentid][nodeid] = true;
              _childrenCount[parentid] += 1;
            }
          } else {
            if (_roots[parentid] == null) {
              _roots[parentid] = {};
              _rootsCount[parentid] = 0;
            }
            if (!_roots[parentid][nodeid]) {
              _roots[parentid][nodeid] = true;
              _rootsCount[parentid] += 1;
            }
          }
        }
      }
      if (_roots[nodeid] != null) {
        _children[nodeid] = _roots[nodeid];
        _childrenCount[nodeid] = _rootsCount[nodeid];
        delete _roots[nodeid];
        delete _rootsCount[nodeid];
        _loop(this, _children, nodeid, function(itemid) {
          if (_parents[itemid] == null) {
            _parents[itemid] = {};
            _parentsCount[itemid] = 0;
          }
          if (!_parents[itemid][nodeid]) {
            _parents[itemid][nodeid] = true;
            _parentsCount[itemid] += 1;
          }
        });
      }
    }
  }
  function node(nodeid) {
    return _nodes[nodeid];
  }
  function adopt(parents, nodeid) {
    var index, len, parentid;
    if (_nodes[nodeid] != null) {
      for (index = 0, len = parents.length; index < len; index += 1) {
        parentid = parents[index];
        if (_parents[nodeid] == null) {
          _parents[nodeid] = {};
          _parentsCount[nodeid] = 0;
        }
        if (parentid != nodeid && _nodes[parentid] != null) {
          if (!_parents[nodeid][parentid]) {
            _parents[nodeid][parentid] = true;
            _parentsCount[nodeid] += 1;
          }
          if (_children[parentid] == null) {
            _children[parentid] = {};
            _childrenCount[parentid] = 0;
          }
          if (!_children[parentid][nodeid]) {
            _children[parentid][nodeid] = true;
            _childrenCount[parentid] += 1;
          }
        } else {
          throw "Item cannot be parent of itself and parent should exist in the structure!";
        }
      }
    } else {
      throw "Child should be in hierarchy!";
    }
  }
  function removeNode(nodeid) {
    if (_nodes[nodeid] != null) {
      _loop(this, _children, nodeid, function(itemid) {
        delete _parents[itemid][nodeid];
        _parentsCount[itemid] -= 1;
        if (!_parentsCount[itemid]) {
          delete _parents[itemid];
          delete _parentsCount[itemid];
          if (_roots[null] == null) {
            _roots[null] = {};
            _rootsCount[null] = 0;
          }
          if (!_roots[null][itemid]) {
            _roots[null][itemid] = true;
            _rootsCount[null] += 1;
          }
        }
      });
      _loop(this, _parents, nodeid, function(itemid) {
        delete _children[itemid][nodeid];
        _childrenCount[itemid] -= 1;
        if (!_childrenCount[itemid]) {
          delete _children[itemid];
          delete _childrenCount[itemid];
        }
      });
      if (_roots[null] != null && _roots[null][nodeid] != null) {
        delete _roots[null][nodeid];
        _rootsCount[null] -= 1;
        if (!_rootsCount[null]) {
          delete _roots[null];
          delete _rootsCount[null];
        }
      }
      delete _children[nodeid];
      delete _childrenCount[nodeid];
      delete _parents[nodeid];
      delete _parentsCount[nodeid];
      delete _nodes[nodeid];
    }
  }
  function _removeChildReference(parentid, childid) {
    var result = false;
    if (_children[parentid] != null && _children[parentid][childid] != null) {
      delete _children[parentid][childid];
      _childrenCount[parentid] -= 1;
      delete _parents[childid][parentid];
      _parentsCount[childid] -= 1;
      if (!_childrenCount[parentid]) {
        delete _children[parentid];
        delete _childrenCount[parentid];
      }
      if (!_parents[childid]) {
        delete _parents[childid];
        delete _parentsCount[childid];
        if (_roots[null] == null) {
          _roots[null] = {};
          _rootsCount[null] = 0;
        }
        _roots[null][childid] = true;
        _rootsCount[null] += 1;
      }
      result = true;
    }
    return result;
  }
  function removeRelation(fromid, toid) {
    var result = false;
    if (_nodes[fromid] != null && _nodes[toid] != null) {
      result = _removeChildReference(fromid, toid) || _removeChildReference(toid, fromid);
    }
    return result;
  }
  function removeChildRelation(parentid, childid) {
    var result = false;
    if (_nodes[parentid] != null && _nodes[childid] != null) {
      result = _removeChildReference(parentid, childid);
    }
    return result;
  }
  function hasNodes() {
    return !isEmptyObject(_nodes);
  }
  function loop2(thisArg, onItem) {
    var item;
    if (onItem != null) {
      for (item in _nodes) {
        if (_nodes.hasOwnProperty(item)) {
          if (onItem.call(thisArg, item, _nodes[item])) {
            break;
          }
        }
      }
    }
  }
  function _loopItems(thisArg, collection, items, onItem) {
    var newItems, itemid, processed = {}, levelIndex = 0, hasItems = true;
    while (hasItems) {
      newItems = {};
      hasItems = false;
      for (itemid in items) {
        if (items.hasOwnProperty(itemid)) {
          if (!processed[itemid]) {
            processed[itemid] = true;
            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {
              case 1:
                newItems = {};
                hasItems = false;
                break;
              case 2:
                break;
              default:
                _loop(this, collection, itemid, function(newItemId) {
                  if (!processed[newItemId]) {
                    newItems[newItemId] = true;
                    hasItems = true;
                  }
                });
                break;
            }
          }
        }
      }
      items = newItems;
      levelIndex += 1;
    }
  }
  function loopChildren(thisArg, nodeid, onItem) {
    if (onItem != null) {
      if (nodeid != null && _nodes[nodeid] != null && _children[nodeid] != null) {
        _loopItems(thisArg, _children, _children[nodeid], onItem);
      }
    }
  }
  function loopParents(thisArg, nodeid, onItem) {
    if (onItem != null) {
      if (nodeid != null && _nodes[nodeid] != null && _parents[nodeid] != null) {
        _loopItems(thisArg, _parents, _parents[nodeid], onItem);
      }
    }
  }
  function _loopTopo(thisArg, backwardCol, backwardCount, forwardCol, forwardCount, onItem) {
    var index, len, nodeid, references, queue, newQueue, position;
    if (onItem != null) {
      queue = [];
      references = {};
      for (nodeid in _nodes) {
        if (_nodes.hasOwnProperty(nodeid)) {
          references[nodeid] = backwardCount[nodeid] || 0;
          if (!references[nodeid]) {
            queue.push(nodeid);
          }
        }
      }
      position = 0;
      while (queue.length > 0) {
        newQueue = [];
        for (index = 0, len = queue.length; index < len; index += 1) {
          nodeid = queue[index];
          if (onItem.call(thisArg, nodeid, _nodes[nodeid], position)) {
            newQueue = [];
            break;
          }
          position += 1;
          _loop(this, forwardCol, nodeid, function(itemid) {
            references[itemid] -= 1;
            if (references[itemid] === 0) {
              newQueue.push(itemid);
            }
          });
        }
        queue = newQueue;
      }
    }
  }
  function loopTopo(thisArg, onItem) {
    _loopTopo(thisArg, _parents, _parentsCount, _children, _childrenCount, onItem);
  }
  function loopTopoReversed(thisArg, onItem) {
    _loopTopo(thisArg, _children, _childrenCount, _parents, _parentsCount, onItem);
  }
  function loopLevels(thisArg, parentAligned, onItem) {
    var topoSorted = [], topoSortedPositions = {}, processed = {}, margin = [], levels = {}, levelIndex, groups = {}, hasGroups, newGroups, groupIndex, group, itemsAtLevel, itemid, minimumLevel = null, loopFunc = parentAligned ? loopTopo : loopTopoReversed, index, len, mIndex, mLen, mItem, mLevel, topoSortedItem, bestPosition, bestItem, bestLevel, bestIsParent, newMargin, hasNeighbours;
    function Group() {
      this.items = {};
      this.minimumLevel = null;
    }
    Group.prototype.addItemToLevel = function(itemid2, level) {
      var items = this.items[level];
      if (!items) {
        items = [itemid2];
        this.items[level] = items;
      } else {
        items.push(itemid2);
      }
      this.minimumLevel = this.minimumLevel == null ? level : Math.min(this.minimumLevel, level);
    };
    function addItemToLevel(itemid2, index2, level) {
      var group2 = groups[index2];
      if (!group2) {
        group2 = new Group();
        groups[index2] = group2;
      }
      group2.addItemToLevel(itemid2, level);
      minimumLevel = minimumLevel == null ? level : Math.min(minimumLevel, level);
      levels[itemid2] = level;
      processed[itemid2] = true;
    }
    if (onItem != null) {
      loopFunc(this, function(itemid2, item, position) {
        topoSorted.push(itemid2);
        topoSortedPositions[itemid2] = position;
      });
      for (index = 0, len = topoSorted.length; index < len; index += 1) {
        topoSortedItem = topoSorted[index];
        if (processed[topoSortedItem] == null) {
          margin.push(topoSortedItem);
          addItemToLevel(topoSortedItem, index, 0);
          while (margin.length > 0) {
            bestPosition = null;
            bestItem = null;
            bestLevel = null;
            bestIsParent = !parentAligned;
            newMargin = [];
            for (mIndex = 0, mLen = margin.length; mIndex < mLen; mIndex += 1) {
              mItem = margin[mIndex];
              mLevel = levels[mItem];
              hasNeighbours = false;
              if (parentAligned) {
                _loop(this, _parents, mItem, function(parentid) {
                  var topoSortedPosition;
                  if (!processed[parentid]) {
                    hasNeighbours = true;
                    topoSortedPosition = topoSortedPositions[parentid];
                    if (bestPosition == null || !bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1) {
                      bestPosition = topoSortedPosition;
                      bestItem = parentid;
                      bestLevel = mLevel - 1;
                      bestIsParent = true;
                    }
                  }
                });
                _loop(this, _children, mItem, function(childid) {
                  var topoSortedPosition;
                  if (!processed[childid]) {
                    hasNeighbours = true;
                    topoSortedPosition = topoSortedPositions[childid];
                    if (bestPosition == null || !bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1)) {
                      bestPosition = topoSortedPosition;
                      bestItem = childid;
                      bestLevel = mLevel + 1;
                      bestIsParent = false;
                    }
                  }
                });
              } else {
                _loop(this, _children, mItem, function(childid) {
                  var topoSortedPosition;
                  if (!processed[childid]) {
                    hasNeighbours = true;
                    topoSortedPosition = topoSortedPositions[childid];
                    if (bestPosition == null || bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1) {
                      bestPosition = topoSortedPosition;
                      bestItem = childid;
                      bestLevel = mLevel + 1;
                      bestIsParent = false;
                    }
                  }
                });
                _loop(this, _parents, mItem, function(parentid) {
                  var topoSortedPosition;
                  if (!processed[parentid]) {
                    hasNeighbours = true;
                    topoSortedPosition = topoSortedPositions[parentid];
                    if (bestPosition == null || bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1)) {
                      bestPosition = topoSortedPosition;
                      bestItem = parentid;
                      bestLevel = mLevel - 1;
                      bestIsParent = true;
                    }
                  }
                });
              }
              if (hasNeighbours) {
                newMargin.push(mItem);
              }
            }
            if (bestItem != null) {
              newMargin.push(bestItem);
              addItemToLevel(bestItem, index, bestLevel);
            }
            margin = newMargin;
          }
        }
      }
      hasGroups = true;
      levelIndex = minimumLevel;
      while (hasGroups) {
        newGroups = {};
        hasGroups = false;
        for (groupIndex in groups) {
          if (groups.hasOwnProperty(groupIndex)) {
            group = groups[groupIndex];
            itemsAtLevel = group.items[group.minimumLevel - minimumLevel + levelIndex];
            if (itemsAtLevel != null) {
              newGroups[groupIndex] = group;
              hasGroups = true;
              for (index = 0, len = itemsAtLevel.length; index < len; index += 1) {
                itemid = itemsAtLevel[index];
                if (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex - minimumLevel)) {
                  hasGroups = false;
                  return true;
                }
              }
            }
          }
        }
        groups = newGroups;
        levelIndex += 1;
      }
    }
  }
  function loopRoots(thisArg, onItem) {
    var result = null, minimum, counter = 0, famMembers = {}, famCount = {}, isRoot, roots = {}, processed = {}, famItemId, member, members, rootid, membersRoots, memberRoots, memberRoot, index, len;
    loopTopoReversed(this, function(famItemId2, famItem, position) {
      if (!famMembers.hasOwnProperty(famItemId2)) {
        famMembers[famItemId2] = {};
        famCount[famItemId2] = 0;
      }
      famMembers[famItemId2][famItemId2] = true;
      famCount[famItemId2] += 1;
      isRoot = true;
      loopParents(this, famItem.id, function(parentid, parent, levelIndex) {
        var items, itemid;
        isRoot = false;
        if (!famMembers.hasOwnProperty(parentid)) {
          famMembers[parentid] = {};
          famCount[parentid] = 0;
        }
        if (!famCount[parentid] && _parentsCount[famItemId2] == 1) {
          famMembers[parentid] = famMembers[famItemId2];
          famCount[parentid] = famCount[famItemId2];
        } else {
          items = famMembers[famItemId2];
          for (itemid in items) {
            if (items.hasOwnProperty(itemid)) {
              if (!famMembers[parentid][itemid]) {
                famMembers[parentid][itemid] = true;
                famCount[parentid] += 1;
              }
            }
          }
        }
        return SKIP;
      });
      if (isRoot) {
        roots[famItemId2] = true;
        counter += 1;
      }
    });
    membersRoots = {};
    for (rootid in roots) {
      if (roots.hasOwnProperty(rootid)) {
        members = famMembers[rootid];
        for (member in members) {
          if (members.hasOwnProperty(member)) {
            if (!membersRoots[member]) {
              membersRoots[member] = [];
            }
            membersRoots[member].push(rootid.toString());
          }
        }
      }
    }
    while (counter > 0) {
      minimum = null;
      for (famItemId in roots) {
        if (roots.hasOwnProperty(famItemId)) {
          if (!minimum || famCount[famItemId] < minimum) {
            minimum = famCount[famItemId];
            result = famItemId;
          }
        }
      }
      if (result != null) {
        if (onItem != null) {
          onItem.call(thisArg, result, _nodes[result]);
        }
        members = famMembers[result];
        for (member in members) {
          if (members.hasOwnProperty(member)) {
            if (!processed[member]) {
              memberRoots = membersRoots[member];
              for (index = 0, len = memberRoots.length; index < len; index += 1) {
                memberRoot = memberRoots[index];
                famCount[memberRoot] -= 1;
              }
              processed[member] = true;
            }
          }
        }
        delete roots[result];
        counter -= 1;
      }
    }
  }
  function findLargestRoot() {
    var result = null, maximum, famMembers = {}, famCount = {}, isRoot;
    maximum = null;
    loopTopoReversed(this, function(famItemId, famItem, position) {
      if (!famMembers.hasOwnProperty(famItemId)) {
        famMembers[famItemId] = {};
        famCount[famItemId] = 0;
      }
      famMembers[famItemId][famItemId] = true;
      famCount[famItemId] += 1;
      isRoot = true;
      loopParents(this, famItem.id, function(parentid, parent, levelIndex) {
        var items, itemid;
        isRoot = false;
        if (!famMembers.hasOwnProperty(parentid)) {
          famMembers[parentid] = {};
          famCount[parentid] = 0;
        }
        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {
          famMembers[parentid] = famMembers[famItemId];
          famCount[parentid] = famCount[famItemId];
        } else {
          items = famMembers[famItemId];
          for (itemid in items) {
            if (items.hasOwnProperty(itemid)) {
              famMembers[parentid][itemid] = true;
              famCount[parentid] += 1;
            }
          }
        }
        return SKIP;
      });
      if (isRoot && (!maximum || famCount[famItemId] > maximum)) {
        maximum = famCount[famItemId];
        result = famItemId;
      }
    });
    return result;
  }
  function hasCommonChild(parents) {
    var result = false, parentsHash, childrenHash, parentsCount, pIndex, pLen, parent, child;
    parentsHash = {};
    parentsCount = 0;
    for (pIndex = 0, pLen = parents.length; pIndex < pLen; pIndex += 1) {
      parent = parents[pIndex];
      if (_nodes[parent] != null && !parentsHash[parent]) {
        parentsHash[parent] = true;
        parentsCount += 1;
      }
    }
    childrenHash = {};
    for (parent in parentsHash) {
      if (parentsHash.hasOwnProperty(parent)) {
        _loop(this, _children, parent, function(child2) {
          if (!childrenHash[child2]) {
            childrenHash[child2] = 1;
          } else {
            childrenHash[child2] += 1;
          }
        });
      }
    }
    for (child in childrenHash) {
      if (childrenHash.hasOwnProperty(child)) {
        if (_parents[child] != null && (_parentsCount[child] || 0) == childrenHash[child] && childrenHash[child] == parentsCount) {
          result = true;
          break;
        }
      }
    }
    return result;
  }
  function _bundleNodes(fromItem, items, bundleItemId, bundleItem, backwardCol, backwardCount, forwardCol, forwardCount, checkChildren) {
    var isValid = false, index, len, child;
    if (_nodes[fromItem] != null && forwardCol[fromItem] != null) {
      isValid = true;
      if (checkChildren) {
        for (index = 0, len = items.length; index < len; index += 1) {
          child = items[index];
          if (_nodes[child] == null || forwardCol[fromItem][child] == null) {
            isValid = false;
          }
        }
      }
      if (isValid) {
        if (bundleItem != null) {
          _nodes[bundleItemId] = bundleItem;
        }
        if (_nodes[bundleItemId] != null) {
          if (!backwardCol[bundleItemId]) {
            backwardCol[bundleItemId] = {};
            backwardCount[bundleItemId] = 0;
          }
          if (!forwardCol[bundleItemId]) {
            forwardCol[bundleItemId] = {};
            forwardCount[bundleItemId] = 0;
          }
          if (!backwardCol[bundleItemId][fromItem]) {
            backwardCol[bundleItemId][fromItem] = true;
            backwardCount[bundleItemId] += 1;
          }
          if (!forwardCol[fromItem][bundleItemId]) {
            forwardCol[fromItem][bundleItemId] = true;
            forwardCount[fromItem] += 1;
          }
          for (index = 0, len = items.length; index < len; index += 1) {
            child = items[index];
            if (bundleItemId != child) {
              if (forwardCol[fromItem][child] != null) {
                delete forwardCol[fromItem][child];
                forwardCount[fromItem] -= 1;
              }
              if (backwardCol[child][fromItem] != null) {
                delete backwardCol[child][fromItem];
                backwardCount[child] -= 1;
              }
              if (!backwardCol[child][bundleItemId]) {
                backwardCol[child][bundleItemId] = true;
                backwardCount[child] += 1;
              }
              if (!forwardCol[bundleItemId][child]) {
                forwardCol[bundleItemId][child] = true;
                forwardCount[bundleItemId] += 1;
              }
            }
          }
        }
      }
    }
    return isValid;
  }
  function bundleChildren(parent, children, bundleItemId, bundleItem) {
    return _bundleNodes(parent, children, bundleItemId, bundleItem, _parents, _parentsCount, _children, _childrenCount, true);
  }
  function bundleParents(child, parents, bundleItemId, bundleItem) {
    return _bundleNodes(child, parents, bundleItemId, bundleItem, _children, _childrenCount, _parents, _parentsCount, true);
  }
  function ReferenceItem() {
    this.id = "";
    this.key = "";
    this.children = [];
    this.childrenHash = {};
    this.processed = false;
  }
  function ReferencesEdge(arg0) {
    this.items = [];
    this.weight = 0;
    this.difference = 0;
    if (arguments.length > 0) {
      this.difference = arg0;
    }
  }
  function _getReferencesGraph(currentItems) {
    var result = Graph(), item, parents, index1, index2, len, from, to, difference, processed = {};
    for (item in currentItems) {
      if (currentItems.hasOwnProperty(item)) {
        _loop(this, _children, item, function(child) {
          if (!processed.hasOwnProperty(child)) {
            processed[child] = true;
            parents = [];
            _loop(this, _parents, child, function(parent) {
              parents.push(parent);
            });
            for (index1 = 0, len = parents.length; index1 < len - 1; index1 += 1) {
              from = parents[index1];
              if (currentItems.hasOwnProperty(from)) {
                for (index2 = index1 + 1; index2 < len; index2 += 1) {
                  to = parents[index2];
                  if (currentItems.hasOwnProperty(to)) {
                    difference = Math.abs(currentItems[from].children.length - currentItems[to].children.length);
                    var edge = result.edge(from, to);
                    if (edge == null) {
                      edge = new ReferencesEdge(difference);
                      result.addEdge(from, to, edge);
                    }
                    edge.items.push(child);
                    edge.weight += 1;
                  }
                }
              }
            }
          }
        });
      }
    }
    return result;
  }
  function optimizeReferences(onNewBundleItem) {
    var sharedItemsByKey = {}, sharedItemsById = {}, currentItems = {}, nodeid, newReferenceItem, nextItems, graph, node2, maximumTree, counter = 0, power = 10, processed;
    if (onNewBundleItem != null) {
      for (nodeid in _nodes) {
        counter += 1;
        if (_nodes.hasOwnProperty(nodeid)) {
          newReferenceItem = new ReferenceItem();
          _loop(this, _children, nodeid, function(child) {
            newReferenceItem.children.push(child);
            newReferenceItem.childrenHash[child] = true;
          });
          newReferenceItem.children.sort();
          newReferenceItem.id = nodeid;
          newReferenceItem.key = newReferenceItem.children.join(",");
          currentItems[newReferenceItem.id] = newReferenceItem;
        }
      }
      power = Math.pow(10, counter.toString().length);
      while (!isEmptyObject(currentItems)) {
        nextItems = {};
        processed = {};
        graph = _getReferencesGraph(currentItems);
        for (nodeid in currentItems) {
          if (currentItems.hasOwnProperty(nodeid)) {
            node2 = currentItems[nodeid];
            if (!node2.processed) {
              maximumTree = graph.getSpanningTree(nodeid, function(edge) {
                return edge.weight * power + power - edge.difference;
              });
              maximumTree.loopLevels(this, function(treeKey, treeKeyNode, levelid) {
                currentItems[treeKey].processed = true;
                maximumTree.loopChildren(this, treeKey, function(child, childNode) {
                  var relation = graph.edge(treeKey, child), nextBundleItem = null, newItem, key, index, len, childrenToBind, isSharedItem, relationItem;
                  currentItems[child].processed = true;
                  if (relation.weight > 1) {
                    relation.items.sort();
                    key = relation.items.join(",");
                    if (!sharedItemsByKey.hasOwnProperty(key)) {
                      newItem = onNewBundleItem();
                      _nodes[newItem.id] = newItem;
                      nextBundleItem = new ReferenceItem();
                      nextBundleItem.id = newItem.id;
                      nextBundleItem.key = key;
                      for (index = 0, len = relation.items.length; index < len; index += 1) {
                        relationItem = relation.items[index];
                        nextBundleItem.children.push(relationItem);
                        nextBundleItem.childrenHash[relationItem] = true;
                        processed[relationItem] = true;
                      }
                      nextBundleItem.children.sort();
                      sharedItemsByKey[nextBundleItem.key] = nextBundleItem;
                      sharedItemsById[nextBundleItem.id] = nextBundleItem;
                      nextItems[nextBundleItem.id] = nextBundleItem;
                      processed[nextBundleItem.id] = nextBundleItem;
                      childrenToBind = nextBundleItem.children.slice(0);
                      loopChildren(this, treeKeyNode.replacementItem || treeKey, function(childid, child2, level) {
                        if (!nextBundleItem.childrenHash[childid] && sharedItemsById[childid] != null) {
                          isSharedItem = true;
                          loopChildren(this, childid, function(childid2, child3, level2) {
                            if (!nextBundleItem.childrenHash[childid2]) {
                              isSharedItem = false;
                              return 1;
                            }
                            if (!processed.hasOwnProperty(childid2)) {
                              return SKIP;
                            }
                          });
                          if (isSharedItem) {
                            childrenToBind.push(childid);
                          }
                        }
                        return 2;
                      });
                      _bundleNodes(treeKeyNode.replacementItem || treeKey, childrenToBind, nextBundleItem.id, newItem, _parents, _parentsCount, _children, _childrenCount, false);
                      if ((_childrenCount[treeKey] || 0) <= 1 && treeKeyNode.replacementItem == null) {
                        treeKeyNode.replacementItem = nextBundleItem.id;
                      }
                    } else {
                      nextBundleItem = sharedItemsByKey[key];
                    }
                    if (nextBundleItem.id != child) {
                      childrenToBind = nextBundleItem.children.slice(0);
                      loopChildren(this, childNode.replacementItem || child, function(childid, child2, level) {
                        if (sharedItemsById[childid] != null && !nextBundleItem.childrenHash[childid]) {
                          isSharedItem = true;
                          loopChildren(this, childid, function(childid2, child3, level2) {
                            if (!nextBundleItem.childrenHash[childid2]) {
                              isSharedItem = false;
                              return 1;
                            }
                            if (!processed.hasOwnProperty(childid2)) {
                              return 2;
                            }
                            return SKIP;
                          });
                          if (isSharedItem) {
                            childrenToBind.push(childid);
                          }
                        }
                        return 2;
                      });
                      _bundleNodes(childNode.replacementItem || child, childrenToBind, nextBundleItem.id, null, _parents, _parentsCount, _children, _childrenCount, false);
                      if ((_childrenCount[child] || 0) <= 1 && childNode.replacementItem == null) {
                        childNode.replacementItem = nextBundleItem.id;
                      }
                    }
                  }
                });
              });
            }
          }
        }
        currentItems = nextItems;
      }
    }
  }
  function eliminateManyToMany(onNewBundleItem) {
    var parent, bundleNode;
    for (parent in _children) {
      if (_children.hasOwnProperty(parent)) {
        if ((_childrenCount[parent] || 0) > 1) {
          _loop(this, _children, parent, function(child) {
            if ((_parentsCount[child] || 0) > 1) {
              bundleNode = onNewBundleItem();
              bundleChildren(parent, [child], bundleNode.id, bundleNode);
            }
          });
        }
      }
    }
  }
  function FamilyEdge(parentid, childid) {
    this.parentid = parentid;
    this.childid = childid;
    this.key = parentid + "," + childid;
  }
  function getPlanarFamily(treeLevels) {
    var result = new Family(), familyEdgeIndex, familyEdgeLen, familyEdgeKey;
    treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
      var sequence = new LinkedHashItems(), crossings = {}, familyEdges = {}, firstBucket = [];
      treeLevels.loopLevelItems(this, levelIndex, function(parentid, parentItem, position) {
        loopChildren(this, parentid, function(childid2, childItem) {
          var childPosition = treeLevels.getItemPosition(childid2);
          var familyEdge3 = new FamilyEdge(parentid, childid2);
          familyEdges[familyEdge3.key] = familyEdge3;
          var crossEdges2 = [];
          if (sequence.isEmpty()) {
            sequence.add(childPosition, [familyEdge3]);
          } else {
            sequence.iterateBack(function(sequenceItem, itemPosition) {
              if (itemPosition < childPosition) {
                sequence.insertAfter(itemPosition, childPosition, [familyEdge3]);
                return true;
              } else if (itemPosition == childPosition) {
                sequenceItem.push(familyEdge3);
                return true;
              } else {
                for (var crossEdgesIndex3 = 0, crossEdgesLen3 = sequenceItem.length; crossEdgesIndex3 < crossEdgesLen3; crossEdgesIndex3 += 1) {
                  var crossEdge = sequenceItem[crossEdgesIndex3];
                  if (crossEdge.parentid != parentid) {
                    crossEdges2.push(crossEdge);
                  }
                }
              }
            });
            if (sequence.startKey() > childPosition) {
              sequence.unshift(childPosition, [familyEdge3]);
            }
          }
          crossings[familyEdge3.key] = crossEdges2;
          for (var crossEdgesIndex2 = 0, crossEdgesLen2 = crossEdges2.length; crossEdgesIndex2 < crossEdgesLen2; crossEdgesIndex2 += 1) {
            crossings[crossEdges2[crossEdgesIndex2].key].push(familyEdge3);
          }
          return SKIP;
        });
        if (countChildren(parentid) == 1) {
          var childid = firstChild(parentid);
          if (countParents(childid) == 1) {
            var familyEdge2 = new FamilyEdge(parentid, childid);
            firstBucket.push(familyEdge2.key);
          }
        }
      });
      var buckets = [], crossEdges;
      for (var familyEdgeKey2 in crossings) {
        crossEdges = crossings[familyEdgeKey2];
        var len = crossEdges.length;
        if (buckets[len] != null) {
          buckets[len].push(familyEdgeKey2);
        } else {
          buckets[len] = [familyEdgeKey2];
        }
      }
      var processed = {};
      buckets.unshift(firstBucket);
      for (var bucketIndex = 0, bucketsLen = buckets.length; bucketIndex < bucketsLen; bucketIndex += 1) {
        var bucket = buckets[bucketIndex];
        if (bucket != null) {
          for (familyEdgeIndex = 0, familyEdgeLen = bucket.length; familyEdgeIndex < familyEdgeLen; familyEdgeIndex += 1) {
            familyEdgeKey2 = bucket[familyEdgeIndex];
            if (!processed.hasOwnProperty(familyEdgeKey2)) {
              processed[familyEdgeKey2] = true;
              var familyEdge = familyEdges[familyEdgeKey2];
              if (result.node(familyEdge.parentid) == null) {
                result.add(null, familyEdge.parentid, {});
              }
              if (result.node(familyEdge.childid) == null) {
                result.add([familyEdge.parentid], familyEdge.childid, {});
              } else {
                result.adopt([familyEdge.parentid], familyEdge.childid);
              }
              crossEdges = crossings[familyEdgeKey2];
              for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {
                processed[crossEdges[crossEdgesIndex].key] = true;
              }
            }
          }
        }
      }
    });
    return result;
  }
  function Link(from, to, distance) {
    this.from = from;
    this.to = to;
    this.distance = 0;
  }
  function getFamilyWithoutGrandParentsRelations() {
    var result = new Family();
    var hash = {};
    var links = [];
    var level = 0;
    for (var from in _parents) {
      if (_parents.hasOwnProperty(from)) {
        _loop(this, _parents, from, function(to) {
          var fromHash = hash[from];
          if (fromHash == null) {
            fromHash = {};
            hash[from] = fromHash;
          }
          if (!fromHash.hasOwnProperty(to)) {
            var link2 = new Link(from, to, level);
            links.push(link2);
            hash[from][to] = link2;
          }
        });
      }
    }
    while (links.length > 0) {
      var newLinks = [];
      level += 1;
      for (var index = 0, len = links.length; index < len; index += 1) {
        var link = links[index];
        from = link.to;
        if (_parents.hasOwnProperty(from)) {
          _loop(this, _parents, from, function(to) {
            var fromHash = hash[link.from];
            if (fromHash == null) {
              fromHash = {};
              hash[link.from] = fromHash;
            }
            if (fromHash.hasOwnProperty(to)) {
              fromHash[to].distance = level;
            } else {
              var newLink = new Link(from, to, level);
              newLinks.push(newLink);
              fromHash[to] = newLink;
            }
          });
        }
      }
      links = newLinks;
    }
    loop2(this, function(nodeid, node2) {
      var parents = [];
      _loop(this, _parents, nodeid, function(to) {
        if (hash[nodeid][to].distance === 0) {
          parents.push(to);
        }
      });
      result.add(parents, nodeid, node2);
    });
    return result;
  }
  function countChildren(parent) {
    return _childrenCount[parent] || 0;
  }
  function countParents(child) {
    return _parentsCount[child] || 0;
  }
  function firstChild(parent) {
    var result = null, children = _children[parent] || {};
    for (result in children) {
      if (children.hasOwnProperty(result)) {
        return result;
      }
    }
    return null;
  }
  function firstParent(child) {
    var result = null, parents = _parents[child] || {};
    for (result in parents) {
      if (parents.hasOwnProperty(result)) {
        return result;
      }
    }
    return null;
  }
  function loopNeighbours(thisArg, itemid, onItem) {
    var processed = {};
    if (onItem != null) {
      loopChildren(this, itemid, function(childid, child, childLevel) {
        if (!processed.hasOwnProperty(childid)) {
          processed[childid] = null;
          if (onItem.call(thisArg, childid, child, 1)) {
            processed[childid] = SKIP;
          }
          loopParents(this, childid, function(parentid, parent, parentLevel) {
            if (!processed.hasOwnProperty(parentid)) {
              processed[parentid] = null;
              if (onItem.call(thisArg, parentid, parent, 2)) {
                processed[parentid] = SKIP;
              }
            }
            return processed[parentid];
          });
        }
        return processed[childid];
      });
      loopParents(this, itemid, function(parentid, parent, parentLevel) {
        if (!processed.hasOwnProperty(parentid)) {
          processed[parentid] = null;
          if (onItem.call(thisArg, parentid, parent, 1)) {
            processed[parentid] = SKIP;
          }
          loopChildren(this, parentid, function(childid, child, childLevel) {
            if (!processed.hasOwnProperty(childid)) {
              processed[childid] = true;
              if (onItem.call(thisArg, childid, child, 2)) {
                processed[childid] = SKIP;
              }
            }
            return processed[childid];
          });
        }
        return processed[parentid];
      });
    }
  }
  function getGraph(thisArg, onEdge) {
    var result = Graph(), from, to;
    for (from in _children) {
      if (_children.hasOwnProperty(from)) {
        _loop(this, _children, from, function(to2) {
          var edge = result.edge(from, to2);
          if (edge == null) {
            if (onEdge == null) {
              edge = new ReferencesEdge({});
            } else {
              edge = onEdge.call(thisArg, from, to2);
            }
            result.addEdge(from, to2, edge);
          }
        });
      }
    }
    return result;
  }
  function GroupBy(parents, children) {
    this.parents = parents;
    this.children = children;
    this.nodes = [];
  }
  function groupBy(thisArg, size, onGroup, onGroupId) {
    if (onGroup != null) {
      var groups = {};
      var processed = {};
      for (var nodeid in _nodes) {
        if (!processed.hasOwnProperty(nodeid)) {
          processed[nodeid] = true;
          if ((_parentsCount[nodeid] || 0) <= 1 && (_childrenCount[nodeid] || 0) <= 1) {
            var nodes = [new FamilyNode(nodeid, _nodes[nodeid])];
            loopChainParents(this, nodeid, (parentId) => {
              processed[parentId] = true;
              nodes.unshift({ id: parentId, node: _nodes[parentId] });
            });
            loopChainChildren(this, nodeid, (childId) => {
              processed[childId] = true;
              nodes.push(new FamilyNode(childId, _nodes[childId]));
            });
            var groupId = null;
            if (onGroupId != null) {
              groupId = onGroupId.call(thisArg, nodes);
            }
            if (groupId !== -1) {
              var parents = [];
              loopParents(this, nodes[0].id, function(parentId, parent, levelIndex) {
                if (levelIndex == 0) {
                  parents.push(parentId);
                  return;
                }
                return BREAK;
              });
              parents.sort();
              var children = [];
              loopChildren(this, nodes[nodes.length - 1].id, function(childId, child, levelIndex) {
                if (levelIndex == 0) {
                  children.push(childId);
                  return;
                }
                return BREAK;
              });
              children.sort();
              var key = parents.join(",") + " * " + children.join(",");
              if (groupId !== null) {
                key += " * " + groupId;
              }
              if (!groups.hasOwnProperty(key)) {
                groups[key] = new GroupBy(parents, children);
              }
              groups[key].nodes.push(nodes);
            }
          }
        }
      }
      for (key in groups) {
        if (groups.hasOwnProperty(key)) {
          var group = groups[key];
          if (group.nodes.length >= size) {
            if (onGroup.call(thisArg, group.parents, group.children, group.nodes)) {
              break;
            }
          }
        }
      }
    }
  }
  function loopChainParents(thisArg, nodeid, onItem) {
    while (_parentsCount[nodeid] === 1) {
      var parentId = firstParent(nodeid);
      if (_childrenCount[parentId] === 1) {
        onItem.call(thisArg, parentId);
        nodeid = parentId;
      } else {
        break;
      }
    }
  }
  function loopChainChildren(thisArg, nodeid, onItem) {
    while (_childrenCount[nodeid] === 1) {
      var childId = firstChild(nodeid);
      if (_parentsCount[childId] === 1) {
        onItem.call(thisArg, childId);
        nodeid = childId;
      } else {
        break;
      }
    }
  }
  function validate(info) {
    var parent, child;
    function _count(items) {
      var result = 0, key;
      if (items != null) {
        for (key in items) {
          if (items.hasOwnProperty(key)) {
            result += 1;
          }
        }
      }
      return result;
    }
    loop2(this, function(nodeId, node2) {
      _loop(this, _children, nodeId, function(child2) {
        if (!_parents.hasOwnProperty(child2) || !_parents[child2].hasOwnProperty(nodeId)) {
          if (info != null) {
            info.message = "Child #" + child2 + " does not reference parent #" + nodeId;
          }
          return false;
        }
      });
      _loop(this, _parents, nodeId, function(parent2) {
        if (!_children.hasOwnProperty(parent2) || !_children[parent2].hasOwnProperty(nodeId)) {
          if (info != null) {
            info.message = "Parent #" + parent2 + " does not reference child #" + nodeId;
          }
          return false;
        }
      });
    });
    for (parent in _parents) {
      if (_parents.hasOwnProperty(parent)) {
        if ((_parentsCount[parent] || 0) != _count(_parents[parent])) {
          if (info != null) {
            info.message = "Parents count for item #" + parent + " missmatch.";
          }
          return false;
        }
        if (_parents.hasOwnProperty(parent) && !_nodes.hasOwnProperty(parent)) {
          if (info != null) {
            info.message = "Orphant parents for item #" + parent;
          }
          return false;
        }
      }
    }
    for (child in _children) {
      if (_children.hasOwnProperty(child)) {
        if ((_childrenCount[child] || 0) != _count(_children[child])) {
          if (info != null) {
            info.message = "Children count for item " + child + " missmatch.";
          }
          return false;
        }
        if (_children.hasOwnProperty(child) && !_nodes.hasOwnProperty(child)) {
          if (info != null) {
            info.message = "Orphant children of item " + child;
          }
          return false;
        }
      }
    }
    for (child in _roots) {
      if (_roots.hasOwnProperty(child)) {
        if ((_rootsCount[child] || 0) != _count(_roots[child])) {
          if (info != null) {
            info.message = "Root children count for item @" + child + " missmatch.";
          }
          return false;
        }
        _loop(this, _roots, child, function(nodeid) {
          if (!_nodes.hasOwnProperty(nodeid)) {
            if (info != null) {
              info.message = "Child #" + nodeid + "of root #" + child + " does not exists.";
            }
            return false;
          }
        });
      }
    }
    return true;
  }
  function hasLoops() {
    var tempFamily = clone();
    loopTopo(this, function(itemid, item, levelIndex) {
      tempFamily.removeNode(itemid);
    });
    return tempFamily.hasNodes();
  }
  function clone() {
    return Family({
      roots: _roots,
      rootsCount: _rootsCount,
      children: _children,
      childrenCount: _childrenCount,
      parents: _parents,
      parentsCount: _parentsCount,
      nodes: _nodes
    });
  }
  return {
    /* family structure modification */
    add,
    adopt,
    bundleChildren,
    bundleParents,
    optimizeReferences,
    eliminateManyToMany,
    groupBy,
    getPlanarFamily,
    getFamilyWithoutGrandParentsRelations,
    getGraph,
    removeNode,
    removeRelation,
    removeChildRelation,
    /* referencing and looping */
    node,
    loop: loop2,
    loopLevels,
    loopTopo,
    loopTopoReversed,
    loopChildren,
    loopParents,
    findLargestRoot,
    loopRoots,
    hasNodes,
    hasCommonChild,
    loopNeighbours,
    countChildren,
    countParents,
    firstParent,
    firstChild,
    /* force validation */
    validate,
    hasLoops,
    clone,
    // callback return codes
    BREAK,
    // break loop immidiatly
    SKIP
    // skip loop of current node children 
  };
}

// node_modules/basicprimitives/src/algorithms/FamilyMargins.js
function FamilyMargins() {
  this.items = [];
  function Margin(left, right, leftIndex, rightIndex) {
    this.left = left;
    this.right = right;
    this.leftIndex = leftIndex;
    this.rightIndex = rightIndex;
  }
  this.add = function(arg0, arg1, arg2, arg3) {
    switch (arguments.length) {
      case 2:
        this.items.push(new Margin(-arg0 / 2, arg0 / 2, arg1, arg1));
        break;
      case 4:
        this.items.push(new Margin(arg0, arg1, arg2, arg3));
        break;
    }
  };
  this.merge = function(from, interval) {
    var distance = this.getDistanceTo(from);
    var leftOffset = 0;
    var rightOffset = 0;
    var len1 = this.items.length;
    var len2 = from.items.length;
    var min = Math.min(len1, len2);
    var max = Math.max(len1, len2);
    for (var index = 0; index < min; index += 1) {
      var leftMargin = this.items[len1 - 1 - index];
      var rightMargin = from.items[len2 - 1 - index];
      if (index === 0) {
        var width = leftMargin.right - leftMargin.left + (distance || 0) + (interval || 0) + rightMargin.right - rightMargin.left;
        leftOffset = width / 2 + leftMargin.left;
        rightOffset = width / 2 - rightMargin.right;
      }
      leftMargin.left -= leftOffset;
      leftMargin.right = rightMargin.right + rightOffset;
      leftMargin.rightIndex = rightMargin.rightIndex;
      this.items[max - 1 - index] = leftMargin;
    }
    for (index = min; index < max; index += 1) {
      leftMargin = this.items[len1 - 1 - index];
      rightMargin = from.items[len2 - 1 - index];
      if (leftMargin == null) {
        this.items[max - 1 - index] = new Margin(
          rightMargin.left + rightOffset,
          rightMargin.right + rightOffset,
          rightMargin.leftIndex,
          rightMargin.rightIndex
        );
      } else {
        leftMargin.left -= leftOffset;
        leftMargin.right -= leftOffset;
      }
    }
    return distance;
  };
  this.attach = function(from, interval) {
    var distance = this.getDistanceTo(from);
    var rightOffset = interval || 0;
    var len1 = this.items.length;
    var len2 = from.items.length;
    var min = Math.min(len1, len2);
    var max = Math.max(len1, len2);
    for (var index = 0; index < min; index += 1) {
      var leftMargin = this.items[len1 - 1 - index];
      var rightMargin = from.items[len2 - 1 - index];
      if (index === 0) {
        rightOffset = leftMargin.right + (distance || 0) + (interval || 0) - rightMargin.left;
      }
      leftMargin.right = rightMargin.right + rightOffset;
      leftMargin.rightIndex = rightMargin.rightIndex;
      this.items[max - 1 - index] = leftMargin;
    }
    for (index = min; index < max; index += 1) {
      leftMargin = this.items[len1 - 1 - index];
      if (leftMargin == null) {
        rightMargin = from.items[len2 - 1 - index];
        this.items[max - 1 - index] = new Margin(
          rightMargin.left + rightOffset,
          rightMargin.right + rightOffset,
          rightMargin.leftIndex,
          rightMargin.rightIndex
        );
      }
    }
    return distance;
  };
  this.getDistanceTo = function(to) {
    var distance = null;
    var baseDistance = 0;
    var len1 = this.items.length;
    var len2 = to.items.length;
    var len = Math.min(len1, len2);
    if (len > 0) {
      for (var index = 0; index < len; index += 1) {
        var leftMargins = this.items[len1 - 1 - index];
        var rightMargins = to.items[len2 - 1 - index];
        if (index === 0) {
          baseDistance = leftMargins.right - rightMargins.left;
          distance = baseDistance;
        } else {
          if (leftMargins.rightIndex < rightMargins.leftIndex) {
            distance = Math.max(distance, leftMargins.right - rightMargins.left);
          }
        }
      }
      distance = distance - baseDistance;
    }
    return distance;
  };
  this.loop = function(thisArg, onItem) {
    if (onItem != null) {
      for (var index = 0, len = this.items.length; index < len; index += 1) {
        var margin = this.items[len - 1 - index];
        if (onItem.call(thisArg, index, margin.left, margin.right, margin.leftIndex, margin.rightIndex)) {
          break;
        }
      }
    }
  };
  this.getLeft = function(level) {
    var maximum = this.items.length - 1;
    if (maximum >= level) {
      return this.items[maximum - level].left;
    }
  };
}

// node_modules/basicprimitives/src/algorithms/FamilyAlignment.js
function FamilyAlignment(thisArg, family, treeLevels, onItemSize) {
  var offsets, sizes = {}, childrenDistances;
  if (onItemSize != null) {
    treeLevels.loopItems(this, function(itemid, item, position, levelIndex, level) {
      sizes[itemid] = onItemSize.call(thisArg, itemid, item);
    });
  }
  childrenDistances = getDistancesBetweenChildren(family, treeLevels);
  offsets = getTreeLevelsOffsets(family, treeLevels, childrenDistances);
  function _getNodeMargins(margins, nodeid) {
    var nodeMargins = margins[nodeid];
    if (nodeMargins == null) {
      nodeMargins = new FamilyMargins();
      margins[nodeid] = nodeMargins;
    }
    return nodeMargins;
  }
  function getDistancesBetweenChildren(family2, treeLevels2) {
    var distances = {};
    var margins = {};
    var levelMargins = null;
    treeLevels2.loopLevelsReversed(this, function(levelIndex, level) {
      var newMargins = new FamilyMargins();
      if (levelMargins != null) {
        levelMargins.add(0, Number.MAX_VALUE);
        newMargins.merge(levelMargins, 0);
      }
      levelMargins = newMargins;
      var previousParentMargins = levelMargins;
      treeLevels2.loopLevelItems(this, levelIndex, function(nodeid, node, position) {
        var nodeMargins = _getNodeMargins(margins, nodeid);
        nodeMargins.add(sizes[nodeid], position);
        switch (family2.countParents(nodeid)) {
          case 0:
            if (previousParentMargins != null) {
              distances[nodeid] = previousParentMargins.attach(nodeMargins);
            }
            break;
          case 1:
            family2.loopParents(this, nodeid, function(parentid2, parent, levelIndex2) {
              var parentMargins2 = _getNodeMargins(margins, parentid2);
              distances[nodeid] = parentMargins2.merge(nodeMargins);
              previousParentMargins = parentMargins2;
              return family2.BREAK;
            });
            break;
          default:
            var totalSize = 0;
            var fromIndex = null;
            var toIndex = null;
            var hash = {};
            family2.loopParents(this, nodeid, function(parentid2, parent, levelIndex2) {
              if (levelIndex2 > 0) {
                return family2.BREAK;
              }
              totalSize += sizes[parentid2];
              var position2 = treeLevels2.getItemPosition(parentid2);
              fromIndex = fromIndex == null ? position2 : Math.min(fromIndex, position2);
              toIndex = toIndex == null ? position2 : Math.max(toIndex, position2);
              hash[position2] = parentid2;
            });
            var offset = -totalSize / 2;
            for (var index = fromIndex; index <= toIndex; index += 1) {
              var parentid = hash[index];
              offset += sizes[parentid] / 2;
              var parentMargins = _getNodeMargins(margins, parentid);
              parentMargins.attach(nodeMargins, -offset);
              previousParentMargins = parentMargins;
              offset += sizes[parentid] / 2;
            }
            break;
        }
      });
    });
    return distances;
  }
  function getTreeLevelsOffsets(family2, treeLevels2, childrenDistances2) {
    var offsets2 = {};
    var familyUnitsById = getFamilyUnits(family2);
    var processedFamilyUnits = {};
    treeLevels2.loopLevels(this, function(levelIndex, level) {
      treeLevels2.loopLevelItems(this, levelIndex, function(nodeid, node, position) {
        if (!offsets2.hasOwnProperty(nodeid)) {
          var offset = 0;
          if (position === 0) {
            if (childrenDistances2[nodeid] != null) {
              offset += childrenDistances2[nodeid] + sizes[nodeid] / 2;
            }
          } else {
            var prevNodeId = treeLevels2.getItemAtPosition(levelIndex, position - 1);
            offset += offsets2[prevNodeId] + sizes[prevNodeId] / 2 + (childrenDistances2[nodeid] || 0) + sizes[nodeid] / 2;
          }
          offsets2[nodeid] = offset;
        }
        var familyUnits = familyUnitsById[nodeid];
        if (familyUnits != null) {
          for (var index = 0; index < familyUnits.length; index += 1) {
            var familyUnit = familyUnits[index];
            if (!processedFamilyUnits.hasOwnProperty(familyUnit.id)) {
              processedFamilyUnits[familyUnit.id] = true;
              setFamilyOffsets(offsets2, nodeid, familyUnit, levelIndex, levelIndex + 1, position, treeLevels2, childrenDistances2);
            }
          }
        }
      });
    });
    return offsets2;
  }
  function setFamilyOffsets(offsets2, itemid, familyUnit, fromLevel, toLevel, itemIndex, treeLevels2, childrenDistances2) {
    var fromIndex = itemIndex;
    var toIndex = itemIndex;
    familyUnit.loopSiblings(this, itemid, function(siblingid2) {
      var position = treeLevels2.getItemPosition(siblingid2);
      fromIndex = Math.min(fromIndex, position);
      toIndex = Math.max(toIndex, position);
    });
    for (var index = itemIndex - 1; index >= fromIndex; index -= 1) {
      var siblingid = treeLevels2.getItemAtPosition(fromLevel, index);
      if (!offsets2.hasOwnProperty(siblingid)) {
        var nodeid = treeLevels2.getItemAtPosition(fromLevel, index + 1);
        offsets2[siblingid] = offsets2[nodeid] - (sizes[siblingid] / 2 + (childrenDistances2[nodeid] || 0) + sizes[nodeid] / 2);
      }
    }
    for (index = itemIndex + 1; index <= toIndex; index += 1) {
      siblingid = treeLevels2.getItemAtPosition(fromLevel, index);
      if (!offsets2.hasOwnProperty(siblingid)) {
        nodeid = treeLevels2.getItemAtPosition(fromLevel, index - 1);
        offsets2[siblingid] = offsets2[nodeid] + (sizes[nodeid] / 2 + (childrenDistances2[siblingid] || 0) + sizes[siblingid] / 2);
      }
    }
    siblingid = treeLevels2.getItemAtPosition(fromLevel, fromIndex);
    var siblingsMedian = offsets2[siblingid] - sizes[siblingid] / 2;
    siblingid = treeLevels2.getItemAtPosition(fromLevel, toIndex);
    siblingsMedian += offsets2[siblingid] + sizes[siblingid] / 2;
    siblingsMedian /= 2;
    fromIndex = null;
    toIndex = null;
    familyUnit.loopNonSiblings(this, itemid, function(siblingid2) {
      var position = treeLevels2.getItemPosition(siblingid2);
      fromIndex = fromIndex != null ? Math.min(fromIndex, position) : position;
      toIndex = toIndex != null ? Math.max(toIndex, position) : position;
    });
    var nonSiblingsWidth = 0;
    for (index = fromIndex; index <= toIndex; index += 1) {
      var relatedItemId = treeLevels2.getItemAtPosition(toLevel, index);
      nonSiblingsWidth += sizes[relatedItemId];
      if (index > fromIndex) {
        nonSiblingsWidth += childrenDistances2[relatedItemId] || 0;
      }
    }
    var offset = siblingsMedian - nonSiblingsWidth / 2;
    relatedItemId = treeLevels2.getItemAtPosition(toLevel, fromIndex);
    if (!offsets2.hasOwnProperty(relatedItemId)) {
      offsets2[relatedItemId] = offset + sizes[relatedItemId] / 2;
    }
    for (index = fromIndex + 1; index <= toIndex; index += 1) {
      relatedItemId = treeLevels2.getItemAtPosition(toLevel, index);
      if (!offsets2.hasOwnProperty(relatedItemId)) {
        nodeid = treeLevels2.getItemAtPosition(toLevel, index - 1);
        offsets2[relatedItemId] = offsets2[nodeid] + (sizes[nodeid] / 2 + (childrenDistances2[relatedItemId] || 0) + sizes[relatedItemId] / 2);
      }
    }
  }
  function getOffset(nodeid) {
    return offsets[nodeid];
  }
  return {
    getOffset
  };
}

// node_modules/basicprimitives/src/algorithms/Pile.js
function Pile() {
  var _items = [];
  function add(from, to, context) {
    if (from < to) {
      _items.push(new Segment(from, to, context, 1));
    } else {
      _items.push(new Segment(to, from, context, -1));
    }
  }
  function resolve(thisArg, onItem) {
    var hash, backtraceNext, backtraceTaken, items, item, rowItems, rows, rowIndex, index, offset = 0;
    if (onItem != null) {
      items = _items.slice(0);
      items.sort(function(a, b) {
        return a.from - b.from;
      });
      rows = [];
      while (items.length > 0) {
        hash = {};
        backtraceNext = {};
        backtraceTaken = {};
        getMax(0, items, hash, backtraceNext, backtraceTaken);
        rowItems = [];
        rows[offset] = [];
        index = 0;
        while (backtraceNext.hasOwnProperty(index)) {
          if (backtraceTaken[index]) {
            rowItems.push(index);
            rows[offset].push(items[index]);
          }
          index = backtraceNext[index];
        }
        for (index = rowItems.length - 1; index >= 0; index -= 1) {
          items.splice(rowItems[index], 1);
        }
        offset += 1;
      }
      for (rowIndex = 0; rowIndex < offset; rowIndex += 1) {
        rowItems = rows[rowIndex];
        for (index = 0; index < rowItems.length; index += 1) {
          item = rowItems[index];
          if (onItem.call(thisArg, item.from, item.to, item.context, rowIndex, offset, item.direction)) {
            return offset;
          }
        }
      }
    }
    return offset;
  }
  function Segment(from, to, context, direction) {
    this.context = context;
    this.from = from;
    this.to = to;
    this.offset = null;
    this.direction = direction;
  }
  function getMax(index, items, hash, backtraceNext, backtraceTaken) {
    var result = 0;
    if (index >= items.length) {
      return 0;
    }
    if (hash.hasOwnProperty(index)) {
      return hash[index];
    }
    var item = items[index];
    var withoutItem = getMax(index + 1, items, hash, backtraceNext, backtraceTaken);
    var nextIndex = index + 1;
    while (nextIndex < items.length) {
      var nextItem = items[nextIndex];
      if (nextItem.from >= item.to) {
        break;
      }
      nextIndex += 1;
    }
    var withItem = 1 + getMax(nextIndex, items, hash, backtraceNext, backtraceTaken);
    if (withItem > withoutItem) {
      hash[index] = withItem;
      backtraceNext[index] = nextIndex;
      backtraceTaken[index] = true;
    } else {
      hash[index] = withoutItem;
      backtraceNext[index] = index + 1;
      backtraceTaken[index] = false;
    }
    return hash[index];
  }
  return {
    add,
    resolve
  };
}

// node_modules/basicprimitives/src/algorithms/QuadTree.js
function QuadTree(minimalSize) {
  var _minimalScale = Math.max(1, scale(minimalSize)), _rootScale = 8, _rootSize = 256, _rootCell = null;
  _rootCell = new Cell(0, 0, _rootScale, _rootSize);
  function Cell(x, y, scale2, size) {
    this.x = x;
    this.y = y;
    this.scale = scale2;
    this.size = size;
    this.quadrants = [];
    this.points = [];
  }
  Cell.prototype.notEnclosed = function(rect) {
    if (this.x < rect.x || this.x + this.size > rect.x + rect.width || this.y < rect.y || this.y + this.size > rect.y + rect.height) {
      return true;
    }
    return false;
  };
  Cell.prototype.overlaps = function(rect) {
    if (this.x + this.size < rect.x || rect.x + rect.width < this.x || this.y + this.size < rect.y || rect.y + rect.height < this.y) {
      return false;
    }
    return true;
  };
  Cell.prototype.getQuadrantIndex = function(x, y) {
    var shift = this.scale - 1;
    return x >> shift & 1 | (y >> shift & 1) << 1;
  };
  function scale(value) {
    return Math.floor(Math.log(value) / Math.log(2));
  }
  function addPoint(point) {
    var x = Math.floor(point.x), y = Math.floor(point.y), size = Math.max(x, y);
    while (_rootSize <= size) {
      _rootScale += 1;
      _rootSize *= 2;
      var parent = new Cell(0, 0, _rootScale, _rootSize);
      _splitCell(parent);
      parent.quadrants[0] = _rootCell;
      _rootCell = parent;
    }
    _addPoint(point);
  }
  function _addPoint(point) {
    var x = Math.floor(point.x), y = Math.floor(point.y), cell = _rootCell;
    if (x < 0 || y < 0) {
      throw "Negative values are not supported in the quad tree.";
    }
    while (cell.points == null || cell.points.length > 0) {
      if (cell.scale == _minimalScale && cell.points != null) {
        break;
      }
      if (cell.points != null && cell.points.length > 0) {
        _splitCell(cell);
      }
      cell = cell.quadrants[cell.getQuadrantIndex(x, y)];
    }
    cell.points.push(point);
  }
  function _splitCell(parent) {
    var size = parent.size / 2;
    parent.quadrants = [
      new Cell(parent.x, parent.y, parent.scale - 1, size),
      new Cell(parent.x + size, parent.y, parent.scale - 1, size),
      new Cell(parent.x, parent.y + size, parent.scale - 1, size),
      new Cell(parent.x + size, parent.y + size, parent.scale - 1, size)
    ];
    for (var index = 0, len = parent.points.length; index < len; index += 1) {
      var point = parent.points[index], x = Math.floor(point.x), y = Math.floor(point.y);
      parent.quadrants[parent.getQuadrantIndex(x, y)].points.push(point);
    }
    parent.points = null;
  }
  function loopArea(thisArg, rect, onItem) {
    var cell, index, len;
    if (onItem != null) {
      var check = [_rootCell], nocheck = [];
      while (check.length > 0 || nocheck.length > 0) {
        var newCheck = [], newNocheck = [];
        for (index = 0, len = check.length; index < len; index += 1) {
          cell = check[index];
          if (cell.overlaps(rect)) {
            if (cell.notEnclosed(rect)) {
              if (cell.points == null) {
                for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {
                  newCheck.push(cell.quadrants[quadrantIndex]);
                }
              } else {
                for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {
                  var point = cell.points[pointIndex];
                  if (rect.contains(point)) {
                    if (onItem.call(thisArg, point)) {
                      return;
                    }
                  }
                }
              }
            } else {
              nocheck.push(cell);
            }
          }
        }
        for (index = 0, len = nocheck.length; index < len; index += 1) {
          cell = nocheck[index];
          if (cell.points == null) {
            for (quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {
              newNocheck.push(cell.quadrants[quadrantIndex]);
            }
          } else {
            for (pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {
              if (onItem.call(thisArg, cell.points[pointIndex])) {
                return;
              }
            }
          }
        }
        check = newCheck;
        nocheck = newNocheck;
      }
    }
  }
  function validate() {
    var level = [_rootCell];
    while (level.length > 0) {
      var newLevel = [];
      for (var index = 0, len = level.length; index < len; index += 1) {
        var cell = level[index];
        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);
        if (cell.points != null && cell.quadrants.length > 0) {
          return false;
        }
        if (cell.points == null) {
          for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {
            newLevel.push(cell.quadrants[quadrantIndex]);
          }
        } else {
          for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {
            var point = cell.points[pointIndex];
            if (!rect.contains(point)) {
              return false;
            }
          }
        }
      }
      level = newLevel;
    }
    return true;
  }
  function getPositions(selection) {
    var result = [];
    var count = 0;
    var level = [_rootCell];
    while (level.length > 0) {
      var newLevel = [];
      for (var index = 0, len = level.length; index < len; index += 1) {
        var cell = level[index];
        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);
        rect.context = {
          isHighlighted: false
        };
        count += 1;
        if (selection != null && selection.overlaps(rect) && cell.points != null && cell.points.length > 0) {
          rect.context.isHighlighted = true;
        }
        result.push(rect);
        for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {
          var quadrant = cell.quadrants[quadrantIndex];
          if (quadrant != null) {
            newLevel.push(quadrant);
          }
        }
      }
      level = newLevel;
    }
    return result;
  }
  return {
    addPoint,
    loopArea,
    validate,
    getPositions
  };
}

// node_modules/basicprimitives/src/algorithms/SpatialIndex.js
function SpatialIndex(sizes) {
  var _buckets = [];
  sizes.sort(function(a, b) {
    return a - b;
  });
  switch (sizes.length) {
    case 0:
      _buckets.push(new Bucket(0, 1e6));
      break;
    case 1:
      var size1 = sizes[0];
      _buckets.push(new Bucket(0, size1));
      break;
    case 2:
      size1 = sizes[0];
      var size2 = sizes[1];
      if (size2 > size1 * 2) {
        _buckets.push(new Bucket(0, size1));
        _buckets.push(new Bucket(size1, size2));
      } else {
        _buckets.push(new Bucket(0, size2));
      }
      break;
    default:
      var breaks = getLiniarBreaks(sizes);
      var minimum = 0;
      for (var index = 0; index < breaks.length; index += 1) {
        var maximum = sizes[breaks[index]];
        _buckets.push(new Bucket(minimum, maximum));
        minimum = maximum;
      }
      break;
  }
  function Bucket(minimum2, maximum2) {
    this.minimum = minimum2;
    this.maximum = maximum2;
    this.quadTree = QuadTree(maximum2 * 2);
  }
  function addRect(rect) {
    var size = Math.max(rect.width, rect.height);
    var point = rect.centerPoint();
    for (var index2 = 0, len = _buckets.length; index2 < len; index2 += 1) {
      var bucket = _buckets[index2];
      if (size <= bucket.maximum || index2 == len - 1) {
        point.context = rect;
        bucket.quadTree.addPoint(point);
        break;
      }
    }
  }
  function loopArea(thisArg, rect, onItem) {
    if (onItem != null) {
      for (var index2 = 0, len = _buckets.length; index2 < len; index2 += 1) {
        var bucket = _buckets[index2];
        var bucketRect = new Rect(rect);
        bucketRect.offset(bucket.maximum / 2);
        bucket.quadTree.loopArea(this, bucketRect, function(point) {
          var pointRect = point.context;
          if (rect.overlaps(pointRect)) {
            return onItem.call(thisArg, pointRect);
          }
        });
      }
    }
  }
  function validate() {
    var result = true;
    for (var index2 = 0, len = _buckets.length; index2 < len; index2 += 1) {
      var bucket = _buckets[index2];
      result = result && bucket.quadTree.validate();
    }
    return result;
  }
  function getPositions(selection) {
    var result = [];
    for (var index2 = 0, len = _buckets.length; index2 < len; index2 += 1) {
      var bucket = _buckets[index2];
      result = result.concat(bucket.quadTree.getPositions(selection));
    }
    return result;
  }
  return {
    addRect,
    loopArea,
    validate,
    getPositions
  };
}

// node_modules/basicprimitives/src/algorithms/TreeLevels.js
function TreeLevels(source) {
  var _levels = [], _items = {}, _minimum = null, _maximum = null;
  _init(source);
  function _init(source2) {
    if (isObject(source2)) {
      _levels = cloneObject(source2.levels, true);
      _items = cloneObject(source2.items, true);
      _minimum = cloneObject(source2.minimum, true);
      _maximum = cloneObject(source2.maximum, true);
    }
  }
  function LevelContext(context) {
    this.context = context;
    this.items = [];
  }
  function ItemContext(context, position, level) {
    this.context = context;
    this.positions = {};
    this.positions[level] = position;
    this.startLevel = level;
    this.endLevel = level;
  }
  function isEmpty() {
    return !_levels.length;
  }
  function length() {
    return _levels.length;
  }
  function addLevel(level, context) {
    var treeLevel = createLevel(level);
    treeLevel.context = context;
  }
  function getStartLevelIndex(itemid) {
    return _items.hasOwnProperty(itemid) ? _items[itemid].startLevel : null;
  }
  function getEndLevelIndex(itemid) {
    return _items.hasOwnProperty(itemid) ? _items[itemid].endLevel : null;
  }
  function getItemPosition(itemid, level) {
    var context = _items[itemid];
    if (context != null) {
      if (level != null) {
        return context.positions[level];
      } else {
        return context.positions[context.startLevel];
      }
    }
    return null;
  }
  function getItemAtPosition(levelIndex, position) {
    var level = _levels[levelIndex], itemid = null;
    if (level != null) {
      itemid = level.items[position];
    }
    return itemid;
  }
  function getPrevItem(itemid, itemLevel) {
    var result = null;
    if (_items.hasOwnProperty(itemid)) {
      var item = _items[itemid];
      itemLevel = itemLevel || item.startLevel;
      var level = _levels[itemLevel];
      result = level.items[item.positions[itemLevel] - 1];
    }
    return result;
  }
  function getNextItem(itemid, itemLevel) {
    var result = null;
    if (_items.hasOwnProperty(itemid)) {
      var item = _items[itemid];
      itemLevel = itemLevel || item.startLevel;
      var level = _levels[itemLevel];
      result = level.items[item.positions[itemLevel] + 1];
    }
    return result;
  }
  function hasItem(itemid) {
    return _items.hasOwnProperty(itemid);
  }
  function hasLevel(levelIndex) {
    return _levels[levelIndex] != null;
  }
  function getItemContext(itemid) {
    var result = null;
    if (_items.hasOwnProperty(itemid)) {
      result = _items[itemid].context;
    }
    return result;
  }
  function createLevel(index) {
    if (_levels[index] == null) {
      _levels[index] = new LevelContext(null);
      _minimum = _minimum === null ? index : Math.min(_minimum, index);
      _maximum = _maximum === null ? index : Math.max(_maximum, index);
    }
    return _levels[index];
  }
  function addItem(levelIndex, itemid, context) {
    var level, itemContext;
    if (!_items.hasOwnProperty(itemid)) {
      level = createLevel(levelIndex);
      level.items.push(itemid);
      _items[itemid] = new ItemContext(context, level.items.length - 1, levelIndex);
    } else {
      level = createLevel(levelIndex);
      level.items.push(itemid);
      itemContext = _items[itemid];
      itemContext.positions[levelIndex] = level.items.length - 1;
      itemContext.startLevel = Math.min(itemContext.startLevel, levelIndex);
      itemContext.endLevel = Math.max(itemContext.endLevel, levelIndex);
    }
  }
  function loopLevels(thisArg, onItem) {
    var index, level;
    if (onItem != null) {
      for (index = _minimum; index <= _maximum; index += 1) {
        level = _levels[index];
        if (level != null) {
          if (onItem.call(thisArg, index, level.context)) {
            break;
          }
        }
      }
    }
  }
  function loopLevelsReversed(thisArg, onItem) {
    var index, level;
    if (onItem != null) {
      for (index = _maximum; index >= _minimum; index -= 1) {
        level = _levels[index];
        if (level != null) {
          if (onItem.call(thisArg, index, level.context)) {
            break;
          }
        }
      }
    }
  }
  function getLevelLength(levelIndex) {
    var result = 0, level = _levels[levelIndex];
    if (level != null) {
      result = level.items.length;
    }
    return result;
  }
  function loopLevelItems(thisArg, levelIndex, onItem) {
    var index, len, level, itemid;
    if (onItem != null) {
      level = _levels[levelIndex];
      if (level != null) {
        for (index = 0, len = level.items.length; index < len; index += 1) {
          itemid = level.items[index];
          if (onItem.call(thisArg, itemid, _items[itemid].context, index)) {
            break;
          }
        }
      }
    }
  }
  function loopItems(thisArg, onItem) {
    var index, len, level, levelIndex, items, itemid, processed = {};
    if (onItem != null) {
      for (levelIndex = _minimum; levelIndex <= _maximum; levelIndex += 1) {
        level = _levels[levelIndex];
        if (level != null) {
          items = level.items;
          for (index = 0, len = items.length; index < len; index += 1) {
            itemid = items[index];
            if (!processed.hasOwnProperty(itemid)) {
              processed[itemid] = true;
              if (onItem.call(thisArg, itemid, _items[itemid].context, index, levelIndex, level.context)) {
                return;
              }
            }
          }
        }
      }
    }
  }
  function binarySearch2(thisArg, levelIndex, onGetDistance) {
    var result = null, level;
    if (onGetDistance != null) {
      level = _levels[levelIndex];
      if (level != null) {
        result = binarySearch(level.items, function(itemid) {
          return onGetDistance.call(thisArg, itemid, _items[itemid].context);
        });
      }
    }
    return result.item;
  }
  function loopMerged(thisArg, getItemWeight, onItem) {
    var index, len, level, itemid, levelsItems = [], sortedItems;
    for (index = 0, len = _levels.length; index < len; index += 1) {
      level = _levels[index];
      if (level != null) {
        levelsItems.push(level.items);
      }
    }
    sortedItems = mergeSort(levelsItems, getItemWeight, true);
    if (onItem != null) {
      for (index = 0, len = sortedItems.length; index < len; index += 1) {
        itemid = sortedItems[index];
        if (onItem.call(thisArg, itemid, _items[itemid].context)) {
          break;
        }
      }
    }
  }
  function loopFromItem(thisArg, itemid, isLeft, onItem, level) {
    var context, index, len, items, nextItemId, itemLevel, position;
    if (_items.hasOwnProperty(itemid)) {
      context = _items[itemid];
      itemLevel = level || context.startLevel;
      items = _levels[itemLevel].items;
      position = context.positions[itemLevel];
      if (onItem != null) {
        if (isLeft) {
          for (index = position - 1; index >= 0; index -= 1) {
            nextItemId = items[index];
            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {
              break;
            }
          }
        } else {
          for (index = position + 1, len = items.length; index < len; index += 1) {
            nextItemId = items[index];
            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {
              break;
            }
          }
        }
      }
    }
  }
  function loopLevelsFromItem(thisArg, itemid, isBelow, onItem) {
    var context, index, len, items, item, nextItemId, nextLevels, level;
    if (_items.hasOwnProperty(itemid)) {
      context = _items[itemid];
      if (onItem != null) {
        if (isBelow) {
          for (index = context.endLevel + 1; index <= _maximum; index += 1) {
            level = _levels[index];
            if (onItem.call(thisArg, index, level != null ? level.context : null)) {
              break;
            }
          }
        } else {
          for (index = context.startLevel - 1; index >= _minimum; index -= 1) {
            level = _levels[index];
            if (onItem.call(thisArg, index, level != null ? level.context : null)) {
              break;
            }
          }
        }
      }
    }
  }
  function clone() {
    return TreeLevels({
      levels: _levels,
      items: _items,
      minimum: _minimum,
      maximum: _maximum
    });
  }
  return {
    addlevel: addLevel,
    hasLevel,
    hasItem,
    addItem,
    getItemContext,
    getLevelIndex: getStartLevelIndex,
    getEndLevelIndex,
    getItemPosition,
    getItemAtPosition,
    loopLevels,
    loopLevelsReversed,
    loopLevelItems,
    getLevelLength,
    loopItems,
    binarySearch: binarySearch2,
    loopMerged,
    loopFromItem,
    loopLevelsFromItem,
    getPrevItem,
    getNextItem,
    length,
    isEmpty,
    clone
  };
}

// node_modules/basicprimitives/src/configs/OrgConfig.js
function OrgConfig(name2) {
  this.name = name2 !== void 0 ? name2 : "OrgDiagram";
  this.classPrefix = "orgdiagram";
  this.navigationMode = NavigationMode.Default;
  this.pageFitMode = PageFitMode.FitToPage;
  this.minimalVisibility = Visibility.Dot;
  this.minimumVisibleLevels = 1;
  this.orientationType = OrientationType.Top;
  this.horizontalAlignment = HorizontalAlignmentType.Center;
  this.verticalAlignment = VerticalAlignmentType.Middle;
  this.arrowsDirection = GroupByType.None;
  this.showExtraArrows = false;
  this.extraArrowsMinimumSpace = 30;
  this.connectorType = ConnectorType.Squared;
  this.bevelSize = 4;
  this.elbowType = ElbowType.None;
  this.elbowDotSize = 4;
  this.emptyDiagramMessage = "Diagram is empty.";
  this.items = [];
  this.annotations = [];
  this.cursorItem = null;
  this.highlightItem = null;
  this.highlightGravityRadius = 40;
  this.selectedItems = [];
  this.hasSelectorCheckbox = Enabled.Auto;
  this.selectCheckBoxLabel = "Selected";
  this.selectionPathMode = SelectionPathMode.FullStack;
  this.showFrame = false;
  this.frameInnerPadding = new Thickness(2, 2, 2, 2);
  this.frameOuterPadding = new Thickness(2, 2, 2, 2);
  this.padding = new Thickness(10, 10, 10, 10);
  this.templates = [];
  this.defaultTemplateName = null;
  this.hasButtons = Enabled.Auto;
  this.onButtonsRender = null;
  this.onHighlightChanging = null;
  this.onHighlightChanged = null;
  this.onCursorChanging = null;
  this.onCursorChanged = null;
  this.onSelectionChanging = null;
  this.onSelectionChanged = null;
  this.onButtonClick = null;
  this.onMouseClick = null;
  this.onMouseDblClick = null;
  this.onItemRender = null;
  this.onHighlightRender = null;
  this.onCursorRender = null;
  this.normalLevelShift = 20;
  this.dotLevelShift = 20;
  this.lineLevelShift = 10;
  this.normalItemsInterval = 10;
  this.dotItemsInterval = 1;
  this.lineItemsInterval = 2;
  this.cousinsIntervalMultiplier = 5;
  this.itemTitleFirstFontColor = Colors.White;
  this.itemTitleSecondFontColor = Colors.Navy;
  this.minimizedItemShapeType = ShapeType.None;
  this.linesColor = Colors.Silver;
  this.linesWidth = 1;
  this.linesType = LineType.Solid;
  this.highlightLinesColor = Colors.Red;
  this.highlightLinesWidth = 1;
  this.highlightLinesType = LineType.Solid;
  this.showCallout = true;
  this.calloutMaximumVisibility = Visibility.Dot;
  this.calloutPlacementOffset = 100;
  this.defaultCalloutTemplateName = null;
  this.calloutfillColor = "#000000";
  this.calloutBorderColor = null;
  this.calloutOffset = 4;
  this.calloutCornerRadius = 4;
  this.calloutPointerWidth = "10%";
  this.calloutLineWidth = 1;
  this.calloutOpacity = 0.2;
  this.alignBranches = false;
  this.childrenPlacementType = ChildrenPlacementType.Horizontal;
  this.leavesPlacementType = ChildrenPlacementType.Horizontal;
  this.placeAssistantsAboveChildren = true;
  this.placeAdvisersAboveChildren = true;
  this.maximumColumnsInMatrix = 6;
  this.buttonsPanelSize = 28;
  this.groupTitlePanelSize = 24;
  this.checkBoxPanelSize = 24;
  this.groupTitlePlacementType = AdviserPlacementType.Left;
  this.groupTitleOrientation = TextOrientationType.RotateRight;
  this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
  this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
  this.groupTitleFontSize = "12px";
  this.groupTitleFontFamily = "Arial";
  this.groupTitleColor = Colors.RoyalBlue;
  this.groupTitleFontWeight = "normal";
  this.groupTitleFontStyle = "normal";
  this.onGroupTitleRender = null;
  this.levelTitlePanelSize = 24;
  this.levelTitlePlacementType = AdviserPlacementType.Left;
  this.levelTitlePlaceInside = false;
  this.levelTitleOrientation = TextOrientationType.Auto;
  this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
  this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
  this.levelTitleFontSize = "12px";
  this.levelTitleFontFamily = "Arial";
  this.levelTitleFontColor = Colors.White;
  this.levelTitleColor = Colors.RoyalBlue;
  this.levelTitleFontWeight = "normal";
  this.levelTitleFontStyle = "normal";
  this.onLevelTitleRender = null;
  this.onLevelBackgroundRender = null;
  this.distance = 3;
  this.scale = 1;
  this.minimumScale = 0.5;
  this.maximumScale = 2;
  this.showLabels = Enabled.Auto;
  this.labelSize = new Size(80, 24);
  this.labelOffset = 1;
  this.labelOrientation = TextOrientationType.Horizontal;
  this.labelPlacement = PlacementType.Top;
  this.labelFontSize = "10px";
  this.labelFontFamily = "Arial";
  this.labelColor = Colors.Black;
  this.labelFontWeight = "normal";
  this.labelFontStyle = "normal";
  this.enablePanning = true;
  this.autoSizeMinimum = new Size(800, 600);
  this.autoSizeMaximum = new Size(1024, 768);
}

// node_modules/basicprimitives/src/configs/OrgItemConfig.js
function OrgItemConfig(arg0, arg1, arg2, arg3, arg4) {
  var property;
  this.id = null;
  this.parent = null;
  this.title = null;
  this.description = null;
  this.image = null;
  this.context = null;
  this.itemTitleColor = Colors.RoyalBlue;
  this.minimizedItemShapeType = null;
  this.groupTitle = null;
  this.groupTitleColor = Colors.RoyalBlue;
  this.isVisible = true;
  this.isActive = true;
  this.hasSelectorCheckbox = Enabled.Auto;
  this.hasButtons = Enabled.Auto;
  this.itemType = ItemType.Regular;
  this.levelOffset = null;
  this.adviserPlacementType = AdviserPlacementType.Auto;
  this.childrenPlacementType = ChildrenPlacementType.Auto;
  this.placeAssistantsAboveChildren = Enabled.Auto;
  this.placeAdvisersAboveChildren = Enabled.Auto;
  this.templateName = null;
  this.showCallout = Enabled.Auto;
  this.calloutTemplateName = null;
  this.label = null;
  this.showLabel = Enabled.Auto;
  this.labelSize = null;
  this.labelOrientation = TextOrientationType.Auto;
  this.labelPlacement = PlacementType.Auto;
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
    case 5:
      this.id = arg0;
      this.parent = arg1;
      this.title = arg2;
      this.description = arg3;
      this.image = arg4;
      break;
  }
}

// node_modules/basicprimitives/src/configs/FamConfig.js
function FamConfig(name2) {
  this.name = name2 !== void 0 ? name2 : "FamDiagram";
  this.classPrefix = "famdiagram";
  this.navigationMode = NavigationMode.Default;
  this.pageFitMode = PageFitMode.FitToPage;
  this.minimalVisibility = Visibility.Dot;
  this.minimumVisibleLevels = 0;
  this.orientationType = OrientationType.Top;
  this.verticalAlignment = VerticalAlignmentType.Middle;
  this.arrowsDirection = GroupByType.None;
  this.showExtraArrows = true;
  this.extraArrowsMinimumSpace = 30;
  this.groupByType = GroupByType.Children;
  this.alignBylevels = true;
  this.enableMatrixLayout = false;
  this.minimumMatrixSize = 4;
  this.maximumColumnsInMatrix = 6;
  this.hideGrandParentsConnectors = false;
  this.elbowType = ElbowType.Round;
  this.bevelSize = 4;
  this.elbowDotSize = 4;
  this.emptyDiagramMessage = "Diagram is empty.";
  this.items = [];
  this.annotations = [];
  this.cursorItem = null;
  this.highlightItem = null;
  this.highlightGravityRadius = 40;
  this.selectedItems = [];
  this.hasSelectorCheckbox = Enabled.Auto;
  this.selectCheckBoxLabel = "Selected";
  this.selectionPathMode = SelectionPathMode.None;
  this.neighboursSelectionMode = NeighboursSelectionMode.ParentsAndChildren;
  this.showFrame = false;
  this.frameInnerPadding = new Thickness(2, 2, 2, 2);
  this.frameOuterPadding = new Thickness(2, 2, 2, 2);
  this.padding = new Thickness(10, 10, 10, 10);
  this.templates = [];
  this.defaultTemplateName = null;
  this.defaultLabelAnnotationTemplate = null;
  this.hasButtons = Enabled.Auto;
  this.onButtonsRender = null;
  this.onHighlightChanging = null;
  this.onHighlightChanged = null;
  this.onCursorChanging = null;
  this.onCursorChanged = null;
  this.onSelectionChanging = null;
  this.onSelectionChanged = null;
  this.onButtonClick = null;
  this.onMouseClick = null;
  this.onMouseDblClick = null;
  this.onItemRender = null;
  this.onHighlightRender = null;
  this.onCursorRender = null;
  this.normalLevelShift = 20;
  this.dotLevelShift = 20;
  this.lineLevelShift = 10;
  this.normalItemsInterval = 10;
  this.dotItemsInterval = 1;
  this.lineItemsInterval = 2;
  this.cousinsIntervalMultiplier = 5;
  this.itemTitleFirstFontColor = Colors.White;
  this.itemTitleSecondFontColor = Colors.Navy;
  this.minimizedItemShapeType = ShapeType.None;
  this.linesColor = Colors.Silver;
  this.linesWidth = 1;
  this.linesType = LineType.Solid;
  this.showNeigboursConnectorsHighlighted = false;
  this.highlightLinesColor = Colors.Red;
  this.highlightLinesWidth = 1;
  this.highlightLinesType = LineType.Solid;
  this.linesPalette = [];
  this.showCallout = true;
  this.calloutMaximumVisibility = Visibility.Dot;
  this.calloutPlacementOffset = 100;
  this.defaultCalloutTemplateName = null;
  this.calloutfillColor = "#000000";
  this.calloutBorderColor = null;
  this.calloutOffset = 4;
  this.calloutCornerRadius = 4;
  this.calloutPointerWidth = "10%";
  this.calloutLineWidth = 1;
  this.calloutOpacity = 0.2;
  this.buttonsPanelSize = 28;
  this.groupTitlePanelSize = 24;
  this.checkBoxPanelSize = 24;
  this.groupTitlePlacementType = AdviserPlacementType.Left;
  this.groupTitleOrientation = TextOrientationType.RotateRight;
  this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
  this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
  this.groupTitleFontSize = "12px";
  this.groupTitleFontFamily = "Arial";
  this.groupTitleColor = Colors.RoyalBlue;
  this.groupTitleFontWeight = "normal";
  this.groupTitleFontStyle = "normal";
  this.onGroupTitleRender = null;
  this.levelTitlePanelSize = 24;
  this.levelTitlePlacementType = AdviserPlacementType.Left;
  this.levelTitlePlaceInside = false;
  this.levelTitleOrientation = TextOrientationType.Auto;
  this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
  this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
  this.levelTitleFontSize = "12px";
  this.levelTitleFontFamily = "Arial";
  this.levelTitleFontColor = Colors.White;
  this.levelTitleColor = Colors.RoyalBlue;
  this.levelTitleFontWeight = "normal";
  this.levelTitleFontStyle = "normal";
  this.onLevelTitleRender = null;
  this.onLevelBackgroundRender = null;
  this.distance = 3;
  this.scale = 1;
  this.minimumScale = 0.5;
  this.maximumScale = 1;
  this.showLabels = Enabled.Auto;
  this.labelSize = new Size(80, 24);
  this.labelOffset = 1;
  this.labelOrientation = TextOrientationType.Horizontal;
  this.labelPlacement = PlacementType.Top;
  this.labelFontSize = "10px";
  this.labelFontFamily = "Arial";
  this.labelColor = Colors.Black;
  this.labelFontWeight = "normal";
  this.labelFontStyle = "normal";
  this.enablePanning = true;
  this.autoSizeMinimum = new Size(800, 600);
  this.autoSizeMaximum = new Size(1024, 768);
}

// node_modules/basicprimitives/src/configs/FamItemConfig.js
function FamItemConfig(arg0, arg1, arg2, arg3, arg4) {
  var property;
  this.id = null;
  this.parents = [];
  this.relativeItem = null;
  this.placementType = AdviserPlacementType.Right;
  this.position = null;
  this.primaryParent = null;
  this.title = null;
  this.description = null;
  this.image = null;
  this.context = null;
  this.itemTitleColor = Colors.RoyalBlue;
  this.minimizedItemShapeType = null;
  this.groupTitle = null;
  this.groupTitleColor = Colors.RoyalBlue;
  this.matrixId = null;
  this.addToMatrix = true;
  this.isActive = true;
  this.hasSelectorCheckbox = Enabled.Auto;
  this.hasButtons = Enabled.Auto;
  this.templateName = null;
  this.showCallout = Enabled.Auto;
  this.calloutTemplateName = null;
  this.label = null;
  this.showLabel = Enabled.Auto;
  this.labelSize = null;
  this.labelOrientation = TextOrientationType.Auto;
  this.labelPlacement = PlacementType.Auto;
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
    case 5:
      this.id = arg0;
      this.parents = arg1;
      this.title = arg2;
      this.description = arg3;
      this.image = arg4;
      break;
  }
}

// node_modules/basicprimitives/src/configs/BackgroundAnnotationConfig.js
function BackgroundAnnotationConfig(arg0) {
  var property;
  this.annotationType = AnnotationType.Background;
  this.items = [];
  this.includeChildren = false;
  this.zOrderType = ZOrderType.Auto;
  this.offset = new Thickness(18, 18, 18, 18);
  this.lineWidth = 2;
  this.opacity = 1;
  this.borderColor = null;
  this.fillColor = null;
  this.lineType = LineType.Solid;
  this.selectItems = false;
  switch (arguments.length) {
    case 1:
      if (arg0 !== null) {
        if (arg0 instanceof Array) {
          this.items = arg0;
        } else if (typeof arg0 == "object") {
          for (property in arg0) {
            if (arg0.hasOwnProperty(property)) {
              this[property] = arg0[property];
            }
          }
        }
      }
      break;
  }
}

// node_modules/basicprimitives/src/configs/ConnectorAnnotationConfig.js
function ConnectorAnnotationConfig(arg0, arg1) {
  var property;
  this.annotationType = AnnotationType.Connector;
  this.zOrderType = ZOrderType.Foreground;
  this.fromItem = null;
  this.toItem = null;
  this.connectorShapeType = ConnectorShapeType.OneWay;
  this.connectorPlacementType = ConnectorPlacementType.Offbeat;
  this.labelPlacementType = ConnectorLabelPlacementType.Between;
  this.offset = new Thickness(0, 0, 0, 0);
  this.lineWidth = 2;
  this.color = Colors.Black;
  this.lineType = LineType.Solid;
  this.selectItems = true;
  this.label = null;
  this.labelSize = new Size(60, 30);
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
    case 2:
      this.fromItem = arg0;
      this.toItem = arg1;
      break;
  }
}

// node_modules/basicprimitives/src/configs/HighlightPathAnnotationConfig.js
function HighlightPathAnnotationConfig(arg0) {
  var property;
  this.annotationType = AnnotationType.HighlightPath;
  this.zOrderType = ZOrderType.Foreground;
  this.items = [];
  this.lineWidth = 2;
  this.color = Colors.Red;
  this.lineType = LineType.Solid;
  this.opacity = 1;
  this.showArrows = true;
  this.selectItems = false;
  switch (arguments.length) {
    case 1:
      if (arg0 !== null) {
        if (arg0 instanceof Array) {
          this.items = arg0;
        } else if (typeof arg0 == "object") {
          for (property in arg0) {
            if (arg0.hasOwnProperty(property)) {
              this[property] = arg0[property];
            }
          }
        }
      }
      break;
  }
}

// node_modules/basicprimitives/src/configs/LabelAnnotationConfig.js
function LabelAnnotationConfig(arg0, arg1) {
  var property;
  this.annotationType = AnnotationType.Label;
  this.fromItem = null;
  this.toItems = [];
  this.title = null;
  this.itemTitleColor = Colors.RoyalBlue;
  this.templateName = null;
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
    case 2:
      this.fromItem = arg0;
      this.toItem = arg1;
      break;
  }
}

// node_modules/basicprimitives/src/configs/PaletteItemConfig.js
function PaletteItemConfig(arg0, arg1, arg2) {
  var property;
  this.lineColor = Colors.Silver;
  this.lineWidth = 1;
  this.lineType = LineType.Solid;
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
    case 3:
      this.lineColor = arg0;
      this.lineWidth = arg1;
      this.lineType = arg2;
      break;
  }
}

// node_modules/basicprimitives/src/configs/ShapeAnnotationConfig.js
function ShapeAnnotationConfig(arg0) {
  var property;
  this.annotationType = AnnotationType.Shape;
  this.zOrderType = ZOrderType.Auto;
  this.items = [];
  this.shapeType = ShapeType.Rectangle;
  this.offset = new Thickness(0, 0, 0, 0);
  this.lineWidth = 2;
  this.cornerRadius = "10%";
  this.opacity = 1;
  this.borderColor = null;
  this.fillColor = null;
  this.lineType = LineType.Solid;
  this.selectItems = false;
  this.label = null;
  this.labelSize = new Size(60, 30);
  this.labelPlacement = PlacementType.Auto;
  this.labelOffset = 4;
  switch (arguments.length) {
    case 1:
      if (arg0 !== null) {
        if (arg0 instanceof Array) {
          this.items = arg0;
        } else if (typeof arg0 == "object") {
          for (property in arg0) {
            if (arg0.hasOwnProperty(property)) {
              this[property] = arg0[property];
            }
          }
        }
      }
      break;
  }
}

// node_modules/basicprimitives/src/configs/LevelAnnotationConfig.js
function LevelAnnotationConfig(arg0) {
  var property;
  this.annotationType = AnnotationType.Level;
  this.levels = [];
  this.title = null;
  this.titleFontColor = null;
  this.titleColor = null;
  this.offset = new Thickness(0, 0, 0, 0);
  this.lineWidth = new Thickness(0, 0, 0, 0);
  this.opacity = 1;
  this.borderColor = null;
  this.fillColor = "#D4D4D4";
  this.lineType = LineType.Solid;
  switch (arguments.length) {
    case 1:
      if (arg0 !== null) {
        if (arg0 instanceof Array) {
          this.items = arg0;
        } else if (typeof arg0 == "object") {
          for (property in arg0) {
            if (arg0.hasOwnProperty(property)) {
              this[property] = arg0[property];
            }
          }
        }
      }
      break;
  }
}

// node_modules/basicprimitives/src/configs/TemplateConfig.js
function TemplateConfig() {
  this.name = null;
  this.isActive = true;
  this.itemSize = new Size(120, 100);
  this.itemBorderWidth = 1;
  this.itemTemplate = null;
  this.minimizedItemShapeType = null;
  this.minimizedItemSize = new Size(4, 4);
  this.minimizedItemCornerRadius = null;
  this.minimizedItemLineWidth = 1;
  this.minimizedItemBorderColor = null;
  this.minimizedItemLineType = LineType.Solid;
  this.minimizedItemFillColor = null;
  this.minimizedItemOpacity = 1;
  this.highlightPadding = new Thickness(2, 2, 2, 2);
  this.highlightBorderWidth = 1;
  this.highlightTemplate = null;
  this.cursorPadding = new Thickness(3, 3, 3, 3);
  this.cursorBorderWidth = 2;
  this.cursorTemplate = null;
  this.hasButtons = Enabled.Auto;
  this.onButtonsRender = null;
}

// node_modules/basicprimitives/src/graphics/EnumValues.js
function getTextAlign(alignment) {
  var result = null;
  switch (alignment) {
    case HorizontalAlignmentType.Center:
      result = "center";
      break;
    case HorizontalAlignmentType.Left:
      result = "left";
      break;
    case HorizontalAlignmentType.Right:
      result = "right";
      break;
  }
  return result;
}
function getVerticalAlignment(alignment) {
  var result = null;
  switch (alignment) {
    case VerticalAlignmentType.Middle:
      result = "middle";
      break;
    case VerticalAlignmentType.Top:
      result = "top";
      break;
    case VerticalAlignmentType.Bottom:
      result = "bottom";
      break;
  }
  return result;
}

// node_modules/basicprimitives/src/managers/DependencyManager.js
function DependencyManager() {
  var hash = {};
  function register(key, value) {
    hash[key] = value;
    return value;
  }
  function resolve() {
    var args = [], deps = arguments[0], func = arguments[1], scope = arguments[2] || {};
    return function() {
      var a = Array.prototype.slice.call(arguments, 0);
      for (var i = 0; i < deps.length; i += 1) {
        var d = deps[i];
        args.push(hash.hasOwnProperty(d) && d !== "" ? hash[d] : a.shift());
      }
      args = args.concat(a);
      return func.apply(scope || {}, args);
    };
  }
  return {
    register,
    resolve
  };
}

// node_modules/basicprimitives/src/managers/TaskManager.js
function TaskManager() {
  var _taskFamily = new Family();
  var _dependencies = new DependencyManager();
  var _tasks = [];
  function TaskInfo(name2, dependencies, factory, color) {
    this.name = name2;
    this.dependencies = dependencies;
    this.factory = factory;
    this.task = null;
    this.color = color;
  }
  function addTask(taskName, taskDependencies, factory, color) {
    if (_tasks.length > 0) {
      throw "Task Manager is already initialized";
    }
    _taskFamily.add(taskDependencies, taskName, new TaskInfo(taskName, taskDependencies, factory, color));
  }
  function getTask(taskName) {
    var taskInfo = _taskFamily.node(taskName);
    return taskInfo && taskInfo.task;
  }
  function addDependency(name2, dependency) {
    if (_tasks.length > 0) {
      throw "Task Manager is already initialized";
    }
    _dependencies.register(name2, dependency);
  }
  function process(startTask, stopTask, debug) {
    var hasChanges = false, logtime = debug;
    if (_tasks.length === 0) {
      _taskFamily.loopTopo(this, function(taskName, taskInfo2) {
        taskInfo2.task = _dependencies.register(taskName, _dependencies.resolve(taskInfo2.dependencies, taskInfo2.factory)());
        _tasks.push(taskInfo2);
      });
    }
    if (debug) {
      console.log("-- process --");
    }
    var isRequired = {};
    for (var index = 0, len = _tasks.length; index < len; index += 1) {
      var taskInfo = _tasks[index], dependents = [];
      if (taskInfo.name == startTask || isRequired.hasOwnProperty(taskInfo.name)) {
        if (logtime) {
          var startAt = performance.now();
        }
        if (hasChanges = taskInfo.task.process(debug)) {
          _taskFamily.loopChildren(this, taskInfo.name, function(childTaskName, childTaskInfo) {
            isRequired[childTaskName] = true;
            if (debug) {
              dependents.push(childTaskName);
            }
            return _taskFamily.SKIP;
          });
        }
        if (logtime) {
          var endAt = performance.now();
        }
        if (debug) {
          var spentTime = Math.round(endAt - startAt, 2);
          console.log(index + ". " + taskInfo.name + (", " + spentTime + " ms. ") + (hasChanges ? " - forces: " + dependents.toString() : ""));
        }
      }
      if (taskInfo.name == stopTask) {
        return;
      }
    }
  }
  function getProcessDiagramConfig() {
    var result = [];
    if (_tasks.length === 0) {
      _taskFamily.loopTopo(this, function(taskName, taskInfo2) {
        taskInfo2.task = _dependencies.register(taskName, _dependencies.resolve(taskInfo2.dependencies, taskInfo2.factory)());
        _tasks.push(taskInfo2);
      });
    }
    for (var index = 0, len = _tasks.length; index < len; index += 1) {
      var taskInfo = _tasks[index];
      var itemConfig = {
        id: taskInfo.name,
        title: splitCamelCaseName(taskInfo.name).join(" "),
        description: taskInfo.task.description || "",
        itemTitleColor: taskInfo.color,
        parents: []
      };
      _taskFamily.loopParents(this, taskInfo.name, function(parentTaskName, parentTaskInfo) {
        itemConfig.parents.push(parentTaskName);
        return _taskFamily.SKIP;
      });
      result.push(itemConfig);
    }
    return result;
  }
  return {
    addTask,
    addDependency,
    getTask,
    process,
    getProcessDiagramConfig
  };
}

// node_modules/basicprimitives/src/tasks/options/OptionsTask.js
function OptionsTask(getOptions) {
  function process() {
    return true;
  }
  return {
    process,
    getOptions,
    description: "Raw options."
  };
}

// node_modules/basicprimitives/src/readers/ArrayReader.js
function ArrayReader(itemTemplate, containsUniqueItems, uniquePropertyKey, createSourceHash, isOrdered) {
  this.itemTemplate = itemTemplate;
  this.containsUniqueItems = containsUniqueItems;
  this.uniquePropertyKey = uniquePropertyKey;
  this.containsPrimitiveValues = isNullOrEmpty(uniquePropertyKey);
  this.createSourceHash = createSourceHash;
  this.isOrdered = isOrdered;
}
ArrayReader.prototype.read = function(target, source, path, context) {
  var result = [], resultHash = {}, hash, sequence, resultSequence = {}, sourceHash = {}, item, itemid, index, len, newHashObject, sequencePath = path + "-seq";
  if (!source || !Array.isArray(source)) {
    source = [];
  }
  hash = context.hash.hasOwnProperty(path) ? context.hash[path] : {};
  sequence = context.hash.hasOwnProperty(sequencePath) ? context.hash[sequencePath] : {};
  for (index = 0, len = source.length; index < len; index += 1) {
    item = source[index];
    itemid = this.containsUniqueItems ? this.containsPrimitiveValues ? item : item[this.uniquePropertyKey] : index;
    if (!resultHash.hasOwnProperty(itemid)) {
      newHashObject = this.itemTemplate.read(hash.hasOwnProperty(itemid) ? hash[itemid] : {}, item, path + "-" + index, context);
      result.push(newHashObject);
      resultHash[itemid] = newHashObject;
      resultSequence[index] = itemid;
      if (this.createSourceHash) {
        sourceHash[itemid] = item;
      }
      if (this.isOrdered) {
        if (sequence[index] != resultSequence[index]) {
          context.isChanged = true;
        }
      }
    }
  }
  context.hash[path] = resultHash;
  context.hash[sequencePath] = resultSequence;
  if (this.createSourceHash) {
    context.sourceHash[path] = sourceHash;
  }
  if (target == null || target.length != result.length) {
    context.isChanged = true;
  }
  return result;
};

// node_modules/basicprimitives/src/readers/ValueReader.js
function ValueReader(acceptedTypes, isNullable, defaultValue) {
  this.acceptedTypes = acceptedTypes;
  this.isNullable = isNullable;
  this.defaultValue = defaultValue;
  this.hash = {};
  for (var index = 0; index < acceptedTypes.length; index += 1) {
    var acceptedType = acceptedTypes[index];
    this.hash[acceptedType] = true;
  }
}
ValueReader.prototype.stringify = function(target) {
  if (this.hash["object"] == true) {
    var processed = [];
    var result = JSON.stringify(target, function(key, value) {
      if (key[0] === "_") {
        return null;
      }
      if (value !== null && typeof value == "object") {
        if (processed.indexOf(value) == -1) {
          processed.push(value);
          return value;
        }
        return null;
      }
      return value;
    });
    return result;
  }
  return target;
};
ValueReader.prototype.read = function(target, source, path, context) {
  var result = null;
  if (source === null || typeof source == "undefined" || !this.hash.hasOwnProperty(typeof source)) {
    source = this.isNullable ? null : this.defaultValue;
  }
  result = source;
  if (this.stringify(target) !== this.stringify(source)) {
    context.isChanged = true;
  }
  return result;
};

// node_modules/basicprimitives/src/readers/ObjectReader.js
function ObjectReader(dataTemplate, isNullable, defaultValue) {
  this.dataTemplate = dataTemplate;
  this.isNullable = isNullable;
  this.defaultValue = defaultValue;
}
ObjectReader.prototype.read = function(target, source, path, context) {
  var result = null, isTargetObject = isObject(target), property, propertyDataTemplate;
  if (!source) {
    source = this.isNullable ? null : this.defaultValue;
  }
  if (isObject(source)) {
    result = {};
    for (property in this.dataTemplate) {
      if (this.dataTemplate.hasOwnProperty(property)) {
        propertyDataTemplate = this.dataTemplate[property];
        result[property] = propertyDataTemplate.read(isTargetObject ? target[property] : null, source[property], path + "-" + property, context);
      }
    }
  } else {
    result = source;
    if (target !== source) {
      context.isChanged = true;
    }
  }
  return result;
};

// node_modules/basicprimitives/src/readers/EnumerationReader.js
function EnumerationReader(enumeration, isNullable, defaultValue) {
  this.enumeration = enumeration;
  this.isNullable = isNullable;
  this.defaultValue = defaultValue;
  this.hash = {};
  for (var key in enumeration) {
    this.hash[enumeration[key]] = key;
  }
}
EnumerationReader.prototype.read = function(target, source, path, context) {
  var result = null;
  if (source === null || typeof source == "undefined" || !this.hash.hasOwnProperty(source)) {
    source = this.isNullable ? null : this.defaultValue;
  }
  result = source;
  if (target !== source) {
    context.isChanged = true;
  }
  return result;
};

// node_modules/basicprimitives/src/tasks/options/CalloutOptionTask.js
function CalloutOptionTask(optionsTask, defaultConfig, defaultItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    calloutMaximumVisibility: new EnumerationReader(Visibility, false, defaultConfig.calloutMaximumVisibility),
    showCallout: new ValueReader(["boolean"], false, defaultConfig.showCallout),
    calloutPlacementOffset: new ValueReader(["number"], false, defaultConfig.calloutPlacementOffset),
    orientationType: new EnumerationReader(OrientationType, false, defaultConfig.orientationType),
    defaultTemplateName: new ValueReader(["string"], true),
    defaultCalloutTemplateName: new ValueReader(["string"], true),
    calloutfillColor: new ValueReader(["string"], false, defaultConfig.calloutfillColor),
    calloutBorderColor: new ValueReader(["string"], true),
    calloutOffset: new ValueReader(["number"], false, defaultConfig.calloutOffset),
    calloutCornerRadius: new ValueReader(["string"], false, defaultConfig.calloutCornerRadius),
    calloutPointerWidth: new ValueReader(["string"], false, defaultConfig.calloutPointerWidth),
    calloutLineWidth: new ValueReader(["number"], false, defaultConfig.calloutLineWidth),
    calloutOpacity: new ValueReader(["number"], false, defaultConfig.calloutOpacity),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        showCallout: new EnumerationReader(Enabled, false, defaultConfig.showCallout),
        calloutTemplateName: new ValueReader(["string"], true),
        templateName: new ValueReader(["string"], true)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItemOptions(itemid) {
    return _hash["options-items"][itemid];
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    getItemOptions,
    description: "Checks item callout options."
  };
}

// node_modules/basicprimitives/src/tasks/options/ConnectorsOptionTask.js
function ConnectorsOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    arrowsDirection: new EnumerationReader(GroupByType, false, defaultConfig.arrowsDirection),
    showExtraArrows: new ValueReader(["boolean"], false, defaultConfig.showExtraArrows),
    extraArrowsMinimumSpace: new ValueReader(["number"], false, defaultConfig.extraArrowsMinimumSpace),
    connectorType: new EnumerationReader(ConnectorType, false, defaultConfig.hasOwnProperty("connectorType") ? defaultConfig.connectorType : ConnectorType.Squared),
    showNeigboursConnectorsHighlighted: new EnumerationReader(ConnectorType, false, defaultConfig.hasOwnProperty("showNeigboursConnectorsHighlighted") ? defaultConfig.showNeigboursConnectorsHighlighted : false),
    elbowType: new EnumerationReader(ElbowType, false, defaultConfig.elbowType),
    bevelSize: new ValueReader(["number"], false, defaultConfig.bevelSize),
    elbowDotSize: new ValueReader(["number"], false, defaultConfig.elbowDotSize),
    linesColor: new ValueReader(["string"], false, defaultConfig.linesColor),
    linesWidth: new ValueReader(["number"], false, defaultConfig.linesWidth),
    linesType: new EnumerationReader(LineType, false, defaultConfig.linesType),
    highlightLinesColor: new ValueReader(["string"], false, defaultConfig.highlightLinesColor),
    highlightLinesWidth: new ValueReader(["number"], false, defaultConfig.highlightLinesWidth),
    highlightLinesType: new EnumerationReader(LineType, false, defaultConfig.highlightLinesType)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks connector lines drawing options."
  };
}

// node_modules/basicprimitives/src/tasks/options/OrgItemsOptionTask.js
function OrgItemsOptionTask(optionsTask, defaultItemConfig) {
  var _data = {}, _hash = {}, _sourceHash = {};
  var _dataTemplate = new ObjectReader({
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        parent: new ValueReader(["string", "number"], true),
        itemType: new EnumerationReader(ItemType, false, defaultItemConfig.itemType),
        adviserPlacementType: new EnumerationReader(AdviserPlacementType, false, defaultItemConfig.adviserPlacementType),
        childrenPlacementType: new EnumerationReader(ChildrenPlacementType, false, defaultItemConfig.childrenPlacementType),
        placeAdvisersAboveChildren: new EnumerationReader(Enabled, false, defaultItemConfig.placeAdvisersAboveChildren),
        placeAssistantsAboveChildren: new EnumerationReader(Enabled, false, defaultItemConfig.placeAssistantsAboveChildren),
        isVisible: new ValueReader(["boolean"], false, defaultItemConfig.isVisible),
        isActive: new ValueReader(["boolean"], false, defaultItemConfig.isActive),
        levelOffset: new ValueReader(["number"], false, null)
      }),
      true,
      "id",
      true,
      true
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash,
      sourceHash: _sourceHash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItems() {
    return _data.items;
  }
  function getConfig(itemId) {
    return _sourceHash["options-items"][itemId];
  }
  return {
    process,
    getItems,
    getConfig,
    description: "Checks items configuration options effecting their placement in layout."
  };
}

// node_modules/basicprimitives/src/tasks/options/ItemsContentOptionTask.js
function ItemsContentOptionTask(optionsTask, defaultItemConfig) {
  var _data = {}, _hash = {}, _sourceHash = {};
  var _dataTemplate = new ObjectReader({
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        title: new ValueReader(["string"], true),
        description: new ValueReader(["string"], true),
        image: new ValueReader(["string"], true),
        context: new ValueReader(["string", "number", "object"], true),
        itemTitleColor: new ValueReader(["string"], false, defaultItemConfig.itemTitleColor),
        groupTitle: new ValueReader(["string"], false, defaultItemConfig.groupTitle),
        groupTitleColor: new ValueReader(["string"], false, defaultItemConfig.groupTitleColor)
      }),
      true,
      "id",
      true,
      true
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash,
      sourceHash: _sourceHash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItems() {
    return _data.items;
  }
  function getConfig(itemId) {
    return _sourceHash["options-items"][itemId];
  }
  return {
    process,
    getItems,
    getConfig,
    description: "Checks items configuration options effecting their placement in layout."
  };
}

// node_modules/basicprimitives/src/readers/FunctionReader.js
function FunctionReader() {
}
FunctionReader.prototype.read = function(target, source, path, context) {
  var result = null;
  result = typeof source == "function" ? source : null;
  return result;
};

// node_modules/basicprimitives/src/tasks/options/ItemsSizesOptionTask.js
function ItemsSizesOptionTask(optionsTask, defaultConfig, defaultItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    /*item template options*/
    defaultTemplateName: new ValueReader(["string"], true),
    defaultLabelAnnotationTemplate: new ValueReader(["string"], true),
    hasSelectorCheckbox: new EnumerationReader(Enabled, false, defaultConfig.hasSelectorCheckbox),
    hasButtons: new EnumerationReader(Enabled, false, defaultConfig.hasButtons),
    buttonsPanelSize: new ValueReader(["number"], false, defaultConfig.buttonsPanelSize),
    groupTitlePanelSize: new ValueReader(["number"], false, defaultConfig.groupTitlePanelSize),
    groupTitlePlacementType: new EnumerationReader(AdviserPlacementType, false, defaultConfig.groupTitlePlacementType),
    checkBoxPanelSize: new ValueReader(["number"], false, defaultConfig.checkBoxPanelSize),
    selectCheckBoxLabel: new ValueReader(["string"], false, defaultConfig.selectCheckBoxLabel),
    onButtonsRender: new FunctionReader(),
    /* items visibility */
    pageFitMode: new EnumerationReader(PageFitMode, false, defaultConfig.pageFitMode),
    padding: new ObjectReader({
      left: new ValueReader(["number"], false, defaultConfig.padding.left),
      top: new ValueReader(["number"], false, defaultConfig.padding.top),
      right: new ValueReader(["number"], false, defaultConfig.padding.right),
      bottom: new ValueReader(["number"], false, defaultConfig.padding.bottom)
    }, false, defaultConfig.padding),
    minimalVisibility: new EnumerationReader(Visibility, false, defaultConfig.minimalVisibility),
    selectionPathMode: new EnumerationReader(SelectionPathMode, false, defaultConfig.selectionPathMode),
    autoSizeMinimum: new ObjectReader({
      width: new ValueReader(["number"], false, defaultConfig.autoSizeMinimum.width),
      height: new ValueReader(["number"], false, defaultConfig.autoSizeMinimum.height)
    }, false, defaultConfig.autoSizeMinimum),
    autoSizeMaximum: new ObjectReader({
      width: new ValueReader(["number"], false, defaultConfig.autoSizeMaximum.width),
      height: new ValueReader(["number"], false, defaultConfig.autoSizeMaximum.height)
    }, false, defaultConfig.autoSizeMaximum),
    /* scale */
    scale: new ValueReader(["number"], false, defaultConfig.scale),
    maximumScale: new ValueReader(["number"], false, defaultConfig.maximumScale),
    minimumScale: new ValueReader(["number"], false, defaultConfig.minimumScale),
    /*intervals*/
    normalLevelShift: new ValueReader(["number"], false, defaultConfig.normalLevelShift),
    dotLevelShift: new ValueReader(["number"], false, defaultConfig.dotLevelShift),
    lineLevelShift: new ValueReader(["number"], false, defaultConfig.lineLevelShift),
    normalItemsInterval: new ValueReader(["number"], false, defaultConfig.normalItemsInterval),
    dotItemsInterval: new ValueReader(["number"], false, defaultConfig.dotItemsInterval),
    lineItemsInterval: new ValueReader(["number"], false, defaultConfig.lineItemsInterval),
    /*cousiins branches interval multiplier*/
    cousinsIntervalMultiplier: new ValueReader(["number"], false, defaultConfig.cousinsIntervalMultiplier),
    verticalAlignment: new EnumerationReader(VerticalAlignmentType, false, defaultConfig.verticalAlignment),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        groupTitle: new ValueReader(["string", "number"], true),
        isVisible: new ValueReader(["boolean", "number"], false, defaultItemConfig.isVisible),
        isActive: new ValueReader(["boolean", "number"], false, defaultItemConfig.isActive),
        hasSelectorCheckbox: new EnumerationReader(Enabled, false, defaultItemConfig.hasSelectorCheckbox),
        hasButtons: new EnumerationReader(Enabled, false, defaultItemConfig.hasButtons),
        templateName: new ValueReader(["string"], true)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItemOptions(itemid) {
    return _hash["options-items"][itemid];
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getItemOptions,
    getOptions,
    description: "Checks items size options."
  };
}

// node_modules/basicprimitives/src/tasks/options/MinimumVisibleLevelsOptionTask.js
function MinimumVisibleLevelsOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    /* items visibility */
    pageFitMode: new EnumerationReader(PageFitMode, false, defaultConfig.pageFitMode),
    minimalVisibility: new EnumerationReader(Visibility, false, defaultConfig.minimalVisibility),
    minimumVisibleLevels: new ValueReader(["number"], false, defaultConfig.minimumVisibleLevels)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks minimum visible levels options."
  };
}

// node_modules/basicprimitives/src/tasks/options/LabelsOptionTask.js
function LabelsOptionTask(optionsTask, defaultConfig, defaultItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    showLabels: new EnumerationReader(Enabled, false, defaultConfig.showLabels),
    labelOffset: new ValueReader(["number"], false, defaultConfig.labelOffset),
    labelFontSize: new ValueReader(["string"], false, defaultConfig.labelFontSize),
    labelFontFamily: new ValueReader(["string"], false, defaultConfig.labelFontFamily),
    labelFontStyle: new ValueReader(["string"], false, defaultConfig.labelFontStyle),
    labelFontWeight: new ValueReader(["string"], false, defaultConfig.labelFontWeight),
    labelColor: new ValueReader(["string"], false, defaultConfig.labelColor),
    labelSize: new ObjectReader({
      width: new ValueReader(["number"], false, defaultConfig.labelSize.width),
      height: new ValueReader(["number"], false, defaultConfig.labelSize.height)
    }, false, defaultConfig.labelSize),
    labelOrientation: new EnumerationReader(TextOrientationType, false, defaultConfig.labelOrientation),
    labelPlacement: new EnumerationReader(PlacementType, false, defaultConfig.labelPlacement),
    arrowsDirection: new EnumerationReader(GroupByType, false, defaultConfig.arrowsDirection),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        label: new ValueReader(["string", "number", "object"], true),
        showLabel: new EnumerationReader(Enabled, false, defaultItemConfig.showLabel),
        labelSize: new ObjectReader({
          width: new ValueReader(["number"], false, 0),
          height: new ValueReader(["number"], false, 0)
        }, true),
        labelOrientation: new EnumerationReader(TextOrientationType, false, defaultItemConfig.labelOrientation),
        labelPlacement: new EnumerationReader(PlacementType, false, defaultItemConfig.labelPlacement)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItemsOptions() {
    return _hash["options-items"];
  }
  function getItemOptions(itemid) {
    return _hash["options-items"][itemid];
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getItemOptions,
    getItemsOptions,
    getOptions,
    description: "Checks items labels options."
  };
}

// node_modules/basicprimitives/src/tasks/options/TemplatesOptionTask.js
function TemplatesOptionTask(optionsTask, defaultConfig, defaultTemplateConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    groupTitleVerticalAlignment: new EnumerationReader(VerticalAlignmentType, false, defaultConfig.groupTitleVerticalAlignment),
    groupTitleHorizontalAlignment: new EnumerationReader(HorizontalAlignmentType, false, defaultConfig.groupTitleHorizontalAlignment),
    groupTitleOrientation: new EnumerationReader(TextOrientationType, false, defaultConfig.groupTitleOrientation),
    groupTitleFontSize: new ValueReader(["string"], false, defaultConfig.groupTitleFontSize),
    groupTitleFontFamily: new ValueReader(["string"], false, defaultConfig.groupTitleFontFamily),
    groupTitleColor: new ValueReader(["string"], false, defaultConfig.groupTitleColor),
    groupTitleFontWeight: new ValueReader(["string"], false, defaultConfig.groupTitleFontWeight),
    groupTitleFontStyle: new ValueReader(["string"], false, defaultConfig.groupTitleFontStyle),
    itemTitleFirstFontColor: new ValueReader(["string"], false, defaultConfig.itemTitleFirstFontColor),
    itemTitleSecondFontColor: new ValueReader(["string"], false, defaultConfig.itemTitleSecondFontColor),
    selectCheckBoxLabel: new ValueReader(["string"], false, defaultConfig.selectCheckBoxLabel),
    onItemRender: new FunctionReader(),
    onCursorRender: new FunctionReader(),
    onHighlightRender: new FunctionReader(),
    onGroupTitleRender: new FunctionReader(),
    templates: new ArrayReader(
      new ObjectReader({
        name: new ValueReader(["string"], true),
        isActive: new ValueReader(["boolean"], false, defaultTemplateConfig.isActive),
        itemSize: new ObjectReader({
          width: new ValueReader(["number"], false, defaultTemplateConfig.itemSize.width),
          height: new ValueReader(["number"], false, defaultTemplateConfig.itemSize.height)
        }, false, defaultTemplateConfig.itemSize),
        itemBorderWidth: new ValueReader(["number"], false, defaultTemplateConfig.itemBorderWidth),
        itemTemplate: new ValueReader(["string", "object"], true),
        minimizedItemShapeType: new EnumerationReader(ShapeType, true),
        minimizedItemSize: new ObjectReader({
          width: new ValueReader(["number"], false, defaultTemplateConfig.minimizedItemSize.width),
          height: new ValueReader(["number"], false, defaultTemplateConfig.minimizedItemSize.height)
        }, false, defaultTemplateConfig.minimizedItemSize),
        minimizedItemCornerRadius: new ValueReader(["number"], true),
        minimizedItemLineWidth: new ValueReader(["number"], false, defaultTemplateConfig.minimizedItemLineWidth),
        minimizedItemBorderColor: new ValueReader(["string"], true),
        minimizedItemLineType: new EnumerationReader(LineType, false, defaultTemplateConfig.minimizedItemLineType),
        minimizedItemFillColor: new ValueReader(["string"], true),
        minimizedItemOpacity: new ValueReader(["number"], false, defaultTemplateConfig.minimizedItemOpacity),
        highlightPadding: new ObjectReader({
          left: new ValueReader(["number"], false, defaultTemplateConfig.highlightPadding.left),
          top: new ValueReader(["number"], false, defaultTemplateConfig.highlightPadding.top),
          right: new ValueReader(["number"], false, defaultTemplateConfig.highlightPadding.right),
          bottom: new ValueReader(["number"], false, defaultTemplateConfig.highlightPadding.bottom)
        }, false, defaultTemplateConfig.highlightPadding),
        highlightBorderWidth: new ValueReader(["number"], false, defaultTemplateConfig.highlightBorderWidth),
        highlightTemplate: new ValueReader(["string", "object"], true),
        cursorPadding: new ObjectReader({
          left: new ValueReader(["number"], false, defaultTemplateConfig.cursorPadding.left),
          top: new ValueReader(["number"], false, defaultTemplateConfig.cursorPadding.top),
          right: new ValueReader(["number"], false, defaultTemplateConfig.cursorPadding.right),
          bottom: new ValueReader(["number"], false, defaultTemplateConfig.cursorPadding.bottom)
        }, false, defaultTemplateConfig.cursorPadding),
        cursorBorderWidth: new ValueReader(["number"], false, defaultTemplateConfig.cursorBorderWidth),
        cursorTemplate: new ValueReader(["string", "object"], true),
        hasButtons: new EnumerationReader(Enabled, false, defaultTemplateConfig.hasButtons),
        onButtonsRender: new FunctionReader()
      }),
      true,
      "name"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks items template options."
  };
}

// node_modules/basicprimitives/src/tasks/options/OrientationOptionTask.js
function OrientationOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    orientationType: new EnumerationReader(OrientationType, false, defaultConfig.orientationType)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks diagram orientation options."
  };
}

// node_modules/basicprimitives/src/tasks/options/OrgVisualTreeOptionTask.js
function OrgVisualTreeOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    alignBranches: new ValueReader(["boolean"], false, defaultConfig.alignBranches),
    leavesPlacementType: new EnumerationReader(ChildrenPlacementType, false, defaultConfig.leavesPlacementType),
    childrenPlacementType: new EnumerationReader(ChildrenPlacementType, false, defaultConfig.childrenPlacementType),
    placeAdvisersAboveChildren: new ValueReader(["boolean"], false, defaultConfig.placeAdvisersAboveChildren),
    placeAssistantsAboveChildren: new ValueReader(["boolean"], false, defaultConfig.placeAssistantsAboveChildren),
    maximumColumnsInMatrix: new ValueReader(["number"], false, defaultConfig.maximumColumnsInMatrix),
    horizontalAlignment: new EnumerationReader(HorizontalAlignmentType, false, defaultConfig.horizontalAlignment)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks items layout options."
  };
}

// node_modules/basicprimitives/src/tasks/options/MinimizedItemsOptionTask.js
function MinimizedItemsOptionTask(optionsTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    minimizedItemShapeType: new EnumerationReader(ShapeType, true),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        minimizedItemShapeType: new EnumerationReader(ShapeType, true),
        itemTitleColor: new ValueReader(["string"], true)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItemOptions(itemid) {
    return _hash["options-items"][itemid];
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getItemOptions,
    getOptions,
    description: "Checks minimized items drawing options."
  };
}

// node_modules/basicprimitives/src/tasks/options/selection/CursorItemOptionTask.js
function CursorItemOptionTask(optionsTask, defaultConfig) {
  var _data = {};
  var _dataTemplate = new ObjectReader({
    cursorItem: new ValueReader(["string", "number"], true),
    navigationMode: new EnumerationReader(NavigationMode, false, defaultConfig.navigationMode)
  });
  function process() {
    var context = {
      isChanged: false
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getCursorItem() {
    return _data.cursorItem;
  }
  function hasCursorEnabled() {
    switch (_data.navigationMode) {
      case NavigationMode.Default:
      case NavigationMode.CursorOnly:
        return true;
    }
    return false;
  }
  return {
    process,
    getCursorItem,
    hasCursorEnabled,
    description: "Checks currenct cursor item option."
  };
}

// node_modules/basicprimitives/src/tasks/options/selection/HighlightItemOptionTask.js
function HighlightItemOptionTask(optionsTask, defaultConfig) {
  var _data = {};
  var _dataTemplate = new ObjectReader({
    highlightItem: new ValueReader(["string", "number"], true),
    navigationMode: new EnumerationReader(NavigationMode, false, defaultConfig.navigationMode),
    highlightGravityRadius: new ValueReader(["number"], false, defaultConfig.highlightGravityRadius)
  });
  function process() {
    var context = {
      isChanged: false
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getHighlightItem() {
    return _data.highlightItem;
  }
  function getGravityRadius() {
    return _data.highlightGravityRadius;
  }
  function hasHighlightEnabled() {
    switch (_data.navigationMode) {
      case NavigationMode.Default:
      case NavigationMode.HighlightOnly:
        return true;
    }
    return false;
  }
  return {
    process,
    getHighlightItem,
    hasHighlightEnabled,
    getGravityRadius,
    description: "Checks highlight item option."
  };
}

// node_modules/basicprimitives/src/tasks/options/selection/SelectedItemsOptionTask.js
function SelectedItemsOptionTask(optionsTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    selectedItems: new ArrayReader(
      new ValueReader(["string", "number"], true),
      true
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, options = optionsTask.getOptions();
    _data = _dataTemplate.read(_data, options, "options", context);
    return context.isChanged;
  }
  function getSelectedItems() {
    return _data.selectedItems;
  }
  return {
    process,
    getSelectedItems,
    description: "Checks user selected items option."
  };
}

// node_modules/basicprimitives/src/tasks/options/selection/CursorSelectionPathModeOptionTask.js
function CursorSelectionPathModeOptionTask(optionsTask, defaultConfig) {
  var _data = {};
  var _dataTemplate = new ObjectReader({
    selectionPathMode: new EnumerationReader(SelectionPathMode, false, defaultConfig.selectionPathMode)
  });
  function process() {
    var context = {
      isChanged: false
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getSelectionPathMode() {
    return _data.selectionPathMode;
  }
  return {
    process,
    getSelectionPathMode,
    description: "Checks cursor selection path option."
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/SplitAnnotationsOptionTask.js
function SplitAnnotationsOptionTask(optionsTask) {
  var _data = {
    annotations: {}
  };
  function process() {
    var options = optionsTask.getOptions(), annotations = options.annotations, index, len, annotationConfig, annotationType, zOrderType, key, hash = {};
    if (Array.isArray(annotations)) {
      for (index = 0, len = annotations.length; index < len; index += 1) {
        annotationConfig = annotations[index];
        annotationType = annotationConfig.annotationType;
        switch (annotationType) {
          case AnnotationType.Shape:
          case AnnotationType.Connector:
          case AnnotationType.HighlightPath:
            switch (annotationConfig.zOrderType) {
              case ZOrderType.Background:
                zOrderType = ZOrderType.Background;
                break;
              case ZOrderType.Foreground:
              case ZOrderType.Auto:
              default:
                zOrderType = ZOrderType.Foreground;
                break;
            }
            break;
          case AnnotationType.Background:
          case AnnotationType.Label:
          default:
            zOrderType = null;
            break;
        }
        if (annotationType != null) {
          key = annotationType * 1e3 + (zOrderType || 0);
          if (!hash.hasOwnProperty(key)) {
            hash[key] = [];
          }
          hash[key].push(annotationConfig);
        }
      }
    }
    _data.annotations = hash;
    return true;
  }
  function getAnnotations(annotationType, zOrderType) {
    var key = annotationType * 1e3 + (zOrderType || 0);
    return _data.annotations[key];
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/ShapeAnnotationOptionTask.js
function ShapeAnnotationOptionTask(splitAnnotationsOptionTask, defaultShapeAnnotationConfig, zOrderType) {
  var _annotations = [], _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader(
      {
        zOrderType: new EnumerationReader(ZOrderType, false, defaultShapeAnnotationConfig.zOrderType),
        items: new ArrayReader(
          new ValueReader(["string", "number"], true),
          true
        ),
        shapeType: new EnumerationReader(ShapeType, false, defaultShapeAnnotationConfig.shapeType),
        offset: new ObjectReader({
          left: new ValueReader(["number"], false, defaultShapeAnnotationConfig.offset.left),
          top: new ValueReader(["number"], false, defaultShapeAnnotationConfig.offset.top),
          right: new ValueReader(["number"], false, defaultShapeAnnotationConfig.offset.right),
          bottom: new ValueReader(["number"], false, defaultShapeAnnotationConfig.offset.bottom)
        }, false, defaultShapeAnnotationConfig.offset),
        lineWidth: new ValueReader(["number"], false, defaultShapeAnnotationConfig.lineWidth),
        cornerRadius: new ValueReader(["string"], false, defaultShapeAnnotationConfig.cornerRadius),
        opacity: new ValueReader(["number"], false, defaultShapeAnnotationConfig.opacity),
        borderColor: new ValueReader(["string"], false, defaultShapeAnnotationConfig.borderColor),
        fillColor: new ValueReader(["string"], false, defaultShapeAnnotationConfig.fillColor),
        lineType: new EnumerationReader(LineType, false, defaultShapeAnnotationConfig.lineType),
        selectItems: new ValueReader(["boolean"], false, defaultShapeAnnotationConfig.selectItems),
        label: new ValueReader(["string", "object"], false, defaultShapeAnnotationConfig.label),
        labelSize: new ObjectReader({
          width: new ValueReader(["number"], false, defaultShapeAnnotationConfig.labelSize.width),
          height: new ValueReader(["number"], false, defaultShapeAnnotationConfig.labelSize.height)
        }, false, defaultShapeAnnotationConfig.labelSize),
        labelPlacement: new EnumerationReader(PlacementType, false, defaultShapeAnnotationConfig.labelPlacement),
        labelOffset: new ValueReader(["number"], false, defaultShapeAnnotationConfig.labelOffset)
      },
      false
    )
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _annotations = _dataTemplate.read(_annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.Shape, zOrderType), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _annotations;
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/HighlightPathAnnotationOptionTask.js
function HighlightPathAnnotationOptionTask(splitAnnotationsOptionTask, defaultHighlightPathAnnotationConfig, zOrderType) {
  var _data = {}, _annotations = [], _hash = {};
  var _dataAnnotationsTemplate = new ArrayReader(
    new ObjectReader(
      {
        zOrderType: new EnumerationReader(ZOrderType, false, defaultHighlightPathAnnotationConfig.zOrderType),
        lineWidth: new ValueReader(["number"], false, defaultHighlightPathAnnotationConfig.lineWidth),
        opacity: new ValueReader(["number"], false, defaultHighlightPathAnnotationConfig.opacity),
        color: new ValueReader(["string"], false, defaultHighlightPathAnnotationConfig.color),
        lineType: new EnumerationReader(LineType, false, defaultHighlightPathAnnotationConfig.lineType),
        items: new ArrayReader(
          new ValueReader(["string", "number"], true),
          false
        ),
        selectItems: new ValueReader(["boolean"], false, defaultHighlightPathAnnotationConfig.selectItems),
        showArrows: new ValueReader(["boolean"], false, defaultHighlightPathAnnotationConfig.showArrows)
      },
      false
    )
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _annotations = _dataAnnotationsTemplate.read(_annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.HighlightPath, zOrderType), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _annotations;
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/ConnectorAnnotationOptionTask.js
function ConnectorAnnotationOptionTask(splitAnnotationsOptionTask, defaultConnectorAnnotationConfig, zOrderType) {
  var _annotations = [], _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader({
      zOrderType: new EnumerationReader(ZOrderType, false, defaultConnectorAnnotationConfig.zOrderType),
      fromItem: new ValueReader(["string", "number"], true),
      toItem: new ValueReader(["string", "number"], true),
      connectorShapeType: new EnumerationReader(ShapeType, false, defaultConnectorAnnotationConfig.connectorShapeType),
      connectorPlacementType: new EnumerationReader(ConnectorPlacementType, false, defaultConnectorAnnotationConfig.connectorPlacementType),
      labelPlacementType: new EnumerationReader(ConnectorLabelPlacementType, false, defaultConnectorAnnotationConfig.labelPlacementType),
      offset: new ObjectReader({
        left: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.offset.left),
        top: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.offset.top),
        right: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.offset.right),
        bottom: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.offset.bottom)
      }, false, defaultConnectorAnnotationConfig.offset),
      lineWidth: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.lineWidth),
      color: new ValueReader(["string"], false, defaultConnectorAnnotationConfig.color),
      lineType: new EnumerationReader(LineType, false, defaultConnectorAnnotationConfig.lineType),
      selectItems: new ValueReader(["boolean"], false, defaultConnectorAnnotationConfig.selectItems),
      label: new ValueReader(["string", "object"], false, defaultConnectorAnnotationConfig.label),
      labelSize: new ObjectReader({
        width: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.labelSize.width),
        height: new ValueReader(["number"], false, defaultConnectorAnnotationConfig.labelSize.height)
      }, false, defaultConnectorAnnotationConfig.labelSize)
    }),
    false
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _annotations = _dataTemplate.read(_annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.Connector, zOrderType), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _annotations;
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/BackgroundAnnotationOptionTask.js
function BackgroundAnnotationOptionTask(splitAnnotationsOptionTask, defaultBackgroundAnnotationConfig) {
  var _annotations = [], _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader({
      items: new ArrayReader(
        new ValueReader(["string", "number"], true),
        true
      ),
      includeChildren: new ValueReader(["boolean"], false, defaultBackgroundAnnotationConfig.includeChildren),
      zOrderType: new EnumerationReader(ZOrderType, false, defaultBackgroundAnnotationConfig.zOrderType),
      offset: new ObjectReader({
        left: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.offset.left),
        top: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.offset.top),
        right: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.offset.right),
        bottom: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.offset.bottom)
      }, false, defaultBackgroundAnnotationConfig.offset),
      lineWidth: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.lineWidth),
      opacity: new ValueReader(["number"], false, defaultBackgroundAnnotationConfig.opacity),
      borderColor: new ValueReader(["string"], false, defaultBackgroundAnnotationConfig.borderColor),
      fillColor: new ValueReader(["string"], false, defaultBackgroundAnnotationConfig.fillColor),
      lineType: new EnumerationReader(LineType, false, defaultBackgroundAnnotationConfig.lineType),
      selectItems: new ValueReader(["boolean"], false, defaultBackgroundAnnotationConfig.selectItems)
    }),
    false
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _annotations = _dataTemplate.read(_annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.Background, null), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _annotations;
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/LevelAnnotationOptionTask.js
function LevelAnnotationOptionTask(splitAnnotationsOptionTask, defaultLevelAnnotationConfig) {
  var _annotations = [], _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader({
      levels: new ArrayReader(
        new ValueReader(["string", "number"], true),
        true
      ),
      title: new ValueReader(["string"], true),
      titleFontColor: new ValueReader(["string"], true),
      titleColor: new ValueReader(["string"], true),
      offset: new ObjectReader({
        left: new ValueReader(["number"], false, defaultLevelAnnotationConfig.offset.left),
        top: new ValueReader(["number"], false, defaultLevelAnnotationConfig.offset.top),
        right: new ValueReader(["number"], false, defaultLevelAnnotationConfig.offset.right),
        bottom: new ValueReader(["number"], false, defaultLevelAnnotationConfig.offset.bottom)
      }, false, defaultLevelAnnotationConfig.offset),
      lineWidth: new ObjectReader({
        left: new ValueReader(["number"], false, defaultLevelAnnotationConfig.lineWidth.left),
        top: new ValueReader(["number"], false, defaultLevelAnnotationConfig.lineWidth.top),
        right: new ValueReader(["number"], false, defaultLevelAnnotationConfig.lineWidth.right),
        bottom: new ValueReader(["number"], false, defaultLevelAnnotationConfig.lineWidth.bottom)
      }, false, defaultLevelAnnotationConfig.lineWidth),
      opacity: new ValueReader(["number"], false, defaultLevelAnnotationConfig.opacity),
      borderColor: new ValueReader(["string"], true),
      fillColor: new ValueReader(["string"], false, defaultLevelAnnotationConfig.fillColor),
      lineType: new EnumerationReader(LineType, false, defaultLevelAnnotationConfig.lineType)
    }),
    false
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _annotations = _dataTemplate.read(_annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.Level, null), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _annotations;
  }
  return {
    process,
    getAnnotations,
    description: "Collects Level Annotations"
  };
}

// node_modules/basicprimitives/src/tasks/options/ScaleOptionTask.js
function ScaleOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    scale: new ValueReader(["number"], false, defaultConfig.scale),
    minimumScale: new ValueReader(["number"], false, defaultConfig.minimumScale),
    maximumScale: new ValueReader(["number"], false, defaultConfig.maximumScale)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks control scale options."
  };
}

// node_modules/basicprimitives/src/tasks/options/FrameOptionTask.js
function FrameOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    showFrame: new ValueReader(["boolean"], false, defaultConfig.showFrame),
    frameInnerPadding: new ObjectReader({
      left: new ValueReader(["number"], false, defaultConfig.frameInnerPadding.left),
      top: new ValueReader(["number"], false, defaultConfig.frameInnerPadding.top),
      right: new ValueReader(["number"], false, defaultConfig.frameInnerPadding.right),
      bottom: new ValueReader(["number"], false, defaultConfig.frameInnerPadding.bottom)
    }, false, defaultConfig.frameInnerPadding),
    frameOuterPadding: new ObjectReader({
      left: new ValueReader(["number"], false, defaultConfig.frameOuterPadding.left),
      top: new ValueReader(["number"], false, defaultConfig.frameOuterPadding.top),
      right: new ValueReader(["number"], false, defaultConfig.frameOuterPadding.right),
      bottom: new ValueReader(["number"], false, defaultConfig.frameOuterPadding.bottom)
    }, false, defaultConfig.frameOuterPadding)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Checks frame options."
  };
}

// node_modules/basicprimitives/src/tasks/options/LevelTitlePlacementOptionTask.js
function LevelTitlePlacementOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    levelTitlePlaceInside: new ValueReader(["boolean"], false, defaultConfig.levelTitlePlaceInside),
    levelTitlePanelSize: new ValueReader(["number"], false, defaultConfig.levelTitlePanelSize),
    levelTitlePlacementType: new EnumerationReader(AdviserPlacementType, false, defaultConfig.levelTitlePlacementType)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Level annotation title placement options."
  };
}

// node_modules/basicprimitives/src/tasks/options/LevelTitleTemplateOptionTask.js
function LevelTitleTemplateOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    levelTitleOrientation: new EnumerationReader(TextOrientationType, false, defaultConfig.levelTitleOrientation),
    levelTitleVerticalAlignment: new EnumerationReader(VerticalAlignmentType, false, defaultConfig.levelTitleVerticalAlignment),
    levelTitleHorizontalAlignment: new EnumerationReader(HorizontalAlignmentType, false, defaultConfig.levelTitleHorizontalAlignment),
    levelTitleFontSize: new ValueReader(["string"], false, defaultConfig.levelTitleFontSize),
    levelTitleFontFamily: new ValueReader(["string"], false, defaultConfig.levelTitleFontFamily),
    levelTitleFontColor: new ValueReader(["string"], false, defaultConfig.levelTitleFontColor),
    levelTitleColor: new ValueReader(["string"], false, defaultConfig.levelTitleColor),
    levelTitleFontWeight: new ValueReader(["string"], false, defaultConfig.levelTitleFontWeight),
    levelTitleFontStyle: new ValueReader(["string"], false, defaultConfig.levelTitleFontStyle),
    onLevelTitleRender: new FunctionReader(),
    onLevelBackgroundRender: new FunctionReader()
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Level annotation title template options."
  };
}

// node_modules/basicprimitives/src/tasks/transformations/CombinedContextsTask.js
function CombinedContextsTask(task1, task2) {
  function process() {
    return true;
  }
  function getConfig(itemId) {
    return task1.getConfig(itemId) || task2 != null && task2.getConfig(itemId);
  }
  return {
    process,
    getConfig
  };
}

// node_modules/basicprimitives/src/models/OrgItem.js
function OrgItem(options) {
  var index, len, property;
  this.id = null;
  this.isVisible = true;
  this.isActive = true;
  this.itemType = ItemType.Regular;
  this.adviserPlacementType = AdviserPlacementType.Auto;
  this.childrenPlacementType = ChildrenPlacementType.Auto;
  this.placeAdvisersAboveChildren = Enabled.Auto;
  this.placeAssistantsAboveChildren = Enabled.Auto;
  this.levelOffset = null;
  this.level = null;
  this.hideParentConnection = false;
  this.hideChildrenConnection = false;
  this.childIndex = null;
  var properties = [
    "id",
    "parent",
    "isVisible",
    "isActive",
    "itemType",
    "adviserPlacementType",
    "childrenPlacementType",
    "placeAdvisersAboveChildren",
    "placeAssistantsAboveChildren",
    "levelOffset"
  ];
  for (index = 0, len = properties.length; index < len; index += 1) {
    property = properties[index];
    if (options.hasOwnProperty(property)) {
      this[property] = options[property];
    }
  }
}

// node_modules/basicprimitives/src/tasks/transformations/OrgTreeTask.js
function OrgTreeTask(itemsOptionTask) {
  var _data = {
    orgTree: null,
    /*Tree OrgItem */
    maximumId: null
    /* maximum of OrgItem.id */
  };
  function process() {
    createOrgTree(itemsOptionTask.getItems());
    return true;
  }
  function createOrgTree(items) {
    var orgItem, orgItemRoot, userItem, index, len, maximumId = 0, parsedId, orgTree = Tree(), rootItemConfig;
    for (index = 0, len = items.length; index < len; index += 1) {
      userItem = items[index];
      if (userItem.id != null) {
        orgItem = new OrgItem(userItem);
        parsedId = parseInt(userItem.id, 10);
        maximumId = Math.max(isNaN(parsedId) ? 0 : parsedId, maximumId);
        orgTree.add(userItem.parent, orgItem.id, orgItem);
      }
    }
    maximumId += 1;
    rootItemConfig = new OrgItemConfig();
    rootItemConfig.id = maximumId;
    rootItemConfig.title = "internal root";
    rootItemConfig.isVisible = false;
    rootItemConfig.isActive = false;
    orgItemRoot = new OrgItem(rootItemConfig);
    orgItemRoot.hideParentConnection = true;
    orgItemRoot.hideChildrenConnection = true;
    orgItemRoot.childrenPlacementType = ChildrenPlacementType.Horizontal;
    orgTree.add(null, orgItemRoot.id, orgItemRoot);
    orgTree.loopLevels(this, function(nodeid, node, levelid) {
      if (levelid > 0) {
        return orgTree.BREAK;
      }
      if (orgItemRoot.id != nodeid) {
        orgTree.adopt(orgItemRoot.id, nodeid);
        node.itemType = ItemType.Regular;
      }
    });
    hideRootConnectors(orgTree);
    _data.orgTree = orgTree;
    _data.maximumId = maximumId;
    return true;
  }
  function hideRootConnectors(orgTree) {
    orgTree.loopLevels(this, function(nodeid, node, levelid) {
      var allRegular = true;
      if (!node.isVisible) {
        orgTree.loopChildren(this, nodeid, function(childid, child, index) {
          if (child.itemType != ItemType.Regular) {
            allRegular = false;
            return true;
          }
        });
        if (allRegular) {
          node.hideChildrenConnection = true;
          orgTree.loopChildren(this, nodeid, function(childid, child, index) {
            child.hideParentConnection = true;
          });
        } else {
          return orgTree.SKIP;
        }
      } else {
        return orgTree.SKIP;
      }
    });
  }
  function getOrgTree() {
    return _data.orgTree;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getOrgTree,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/models/Template.js
function Template(templateConfig, itemTemplate, highlightTemplate, dotHighlightTemplate, cursorTemplate) {
  this.templateConfig = templateConfig;
  this.itemTemplate = itemTemplate;
  this.highlightTemplate = highlightTemplate;
  this.dotHighlightTemplate = dotHighlightTemplate;
  this.cursorTemplate = cursorTemplate;
}

// node_modules/basicprimitives/src/tasks/templates/ReadTemplatesTask.js
function ReadTemplatesTask(templatesOptionTask, defaultTemplates) {
  var _data = {
    templates: {},
    itemTemplates: []
  }, _defaultWidgetTemplateName = "DefaultWidgetTemplate", _defaultWidgetLabelAnnotationTemplateName = "DefaultWidgetLabelAnnotationTemplate";
  function process() {
    var index, len, templateConfig, options = templatesOptionTask.getOptions(), templates = options.templates;
    _data.templates = {};
    _data.itemTemplates = [];
    templateConfig = new TemplateConfig();
    _data.templates[_defaultWidgetTemplateName] = new Template(
      templateConfig,
      new defaultTemplates.ItemTemplate(options, templateConfig),
      new defaultTemplates.HighlightTemplate(options, templateConfig),
      new defaultTemplates.DotHighlightTemplate(options, templateConfig),
      new defaultTemplates.CursorTemplate(options, templateConfig)
    );
    _data.itemTemplates.push(_data.templates[_defaultWidgetTemplateName]);
    templateConfig = getLabelAnnotationTemplateConfig(_defaultWidgetLabelAnnotationTemplateName);
    _data.templates[_defaultWidgetLabelAnnotationTemplateName] = new Template(
      templateConfig,
      new defaultTemplates.LabelAnnotationTemplate(),
      null,
      new defaultTemplates.DotHighlightTemplate(options, templateConfig),
      null
    );
    for (index = 0, len = templates.length; index < len; index += 1) {
      templateConfig = templates[index];
      _data.templates[templateConfig.name] = new Template(
        templateConfig,
        isNullOrEmpty(templateConfig.itemTemplate) ? new defaultTemplates.ItemTemplate(options, templateConfig) : new defaultTemplates.UserTemplate(options, templateConfig.itemTemplate, options.onItemRender),
        isNullOrEmpty(templateConfig.highlightTemplate) ? new defaultTemplates.HighlightTemplate(options, templateConfig) : new defaultTemplates.UserTemplate(options, templateConfig.highlightTemplate, options.onHighlightRender),
        new defaultTemplates.DotHighlightTemplate(options, templateConfig),
        isNullOrEmpty(templateConfig.cursorTemplate) ? new defaultTemplates.CursorTemplate(options, templateConfig) : new defaultTemplates.UserTemplate(options, templateConfig.cursorTemplate, options.onCursorRender)
      );
      _data.itemTemplates.push(_data.templates[templateConfig.name]);
    }
    return true;
  }
  function getLabelAnnotationTemplateConfig(name2) {
    var config = new TemplateConfig();
    config.name = name2;
    config.isActive = false;
    config.itemSize = new Size(100, 20);
    config.minimizedItemSize = new Size(0, 0);
    config.minimizedItemCornerRadius = config.minimizedItemSize.width / 2;
    return config;
  }
  function getTemplate(templateName1, templateName2, templateName3) {
    var result = _data.templates[templateName1] || _data.templates[templateName2] || _data.templates[templateName3];
    return result;
  }
  function getItemTemplates() {
    return _data.itemTemplates;
  }
  return {
    process,
    getTemplate,
    getItemTemplates,
    DefaultWidgetTemplateName: _defaultWidgetTemplateName,
    DefaultWidgetLabelAnnotationTemplateName: _defaultWidgetLabelAnnotationTemplateName
  };
}

// node_modules/basicprimitives/src/tasks/templates/ActiveItemsTask.js
function ActiveItemsTask(itemsSizesOptionTask, readTemplatesTask) {
  var _data = {
    items: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, itemsSizesOptions = itemsSizesOptionTask.getOptions(), items = itemsSizesOptions.items;
    _data.items = _dataTemplate.read(_data.items, collectActiveItems(itemsSizesOptions, items), "items", context);
    return context.isChanged;
  }
  function collectActiveItems(itemsSizesOptions, items) {
    var result = [], index, len;
    for (index = 0, len = items.length; index < len; index += 1) {
      var itemConfig = items[index], template = readTemplatesTask.getTemplate(itemConfig.templateName, itemsSizesOptions.defaultTemplateName, readTemplatesTask.DefaultWidgetTemplateName), templateConfig = template.templateConfig, isActive = itemConfig.isActive && templateConfig.isActive;
      if (isActive) {
        result.push(itemConfig.id);
      }
    }
    return result;
  }
  function getActiveItems() {
    return _hash.items;
  }
  return {
    process,
    getActiveItems
  };
}

// node_modules/basicprimitives/src/models/TemplateParams.js
function TemplateParams() {
  this.template = null;
  this.isActive = false;
  this.hasSelectorCheckbox = false;
  this.hasButtons = false;
  this.hasGroupTitle = false;
  this.onButtonsRender = null;
}

// node_modules/basicprimitives/src/tasks/templates/ItemTemplateParamsTask.js
function ItemTemplateParamsTask(itemsSizesOptionTask, cursorItemOptionTask, readTemplatesTask) {
  var _data = {
    items: {}
    // TemplateParams
  };
  function process() {
    var itemsSizesOptions = itemsSizesOptionTask.getOptions(), cursorItem = cursorItemOptionTask.getCursorItem(), items = itemsSizesOptions.items, index, len;
    _data.items = {};
    for (index = 0, len = items.length; index < len; index += 1) {
      var itemConfig = items[index], templateParams = new TemplateParams(), isCursor = cursorItem == itemConfig.id, template = readTemplatesTask.getTemplate(itemConfig.templateName, itemsSizesOptions.defaultTemplateName, readTemplatesTask.DefaultWidgetTemplateName), templateConfig = template.templateConfig, hasButtonsRender = itemsSizesOptions.onButtonsRender != null || templateConfig.onButtonsRender != null;
      templateParams.template = template;
      templateParams.isActive = itemConfig.isActive && templateConfig.isActive;
      if (templateParams.isActive) {
        templateParams.hasSelectorCheckbox = getSelectionVisibility(isCursor, itemConfig.hasSelectorCheckbox, itemsSizesOptions.hasSelectorCheckbox);
        templateParams.hasButtons = templateConfig.hasButtons !== Enabled.Auto ? templateConfig.hasButtons == Enabled.True : hasButtonsRender && getSelectionVisibility(isCursor, itemConfig.hasButtons, itemsSizesOptions.hasButtons);
        if (templateParams.hasButtons) {
          templateParams.onButtonsRender = templateConfig.onButtonsRender || itemsSizesOptions.onButtonsRender;
        }
      }
      templateParams.hasGroupTitle = !isNullOrEmpty(itemConfig.groupTitle);
      _data.items[itemConfig.id] = templateParams;
    }
    return true;
  }
  function getSelectionVisibility(isCursor, itemState, widgetState) {
    var result = false;
    switch (itemState) {
      case Enabled.Auto:
        switch (widgetState) {
          case Enabled.Auto:
            result = isCursor;
            break;
          case Enabled.True:
            result = true;
            break;
          case Enabled.False:
            result = false;
            break;
        }
        break;
      case Enabled.True:
        result = true;
        break;
      case Enabled.False:
        result = false;
        break;
    }
    return result;
  }
  function getTemplateParams(orgItemId) {
    return _data.items[orgItemId];
  }
  return {
    process,
    getTemplateParams
  };
}

// node_modules/basicprimitives/src/tasks/templates/GroupTitleTemplateTask.js
function GroupTitleTemplateTask(templatesOptionTask, templates) {
  var _data = {
    template: null
  };
  function process() {
    _data.template = null;
    return true;
  }
  function getTemplate() {
    var options;
    if (_data.template == null) {
      options = templatesOptionTask.getOptions();
      var { onGroupTitleRender } = options;
      if (onGroupTitleRender != null) {
        _data.template = new templates.CustomRenderTemplate(options, onGroupTitleRender);
      } else {
        _data.template = new templates.GroupTitleTemplate(options);
      }
    }
    return _data.template;
  }
  return {
    process,
    getTemplate
  };
}

// node_modules/basicprimitives/src/tasks/templates/CheckBoxTemplateTask.js
function CheckBoxTemplateTask(itemsSizesOptionTask, templates) {
  var _data = {
    template: null
  };
  function process() {
    _data.template = null;
    return true;
  }
  function getTemplate() {
    var options;
    if (_data.template == null) {
      options = itemsSizesOptionTask.getOptions();
      _data.template = new templates.CheckBoxTemplate(options.selectCheckBoxLabel);
    }
    return _data.template;
  }
  return {
    process,
    getTemplate
  };
}

// node_modules/basicprimitives/src/tasks/templates/ButtonsTemplateTask.js
function ButtonsTemplateTask(itemsSizesOptionTask, templates) {
  var _data = {
    template: null
  };
  function process() {
    return false;
  }
  function getTemplate() {
    if (_data.template == null) {
      _data.template = new templates.ButtonsTemplate();
    }
    return _data.template;
  }
  return {
    process,
    getTemplate
  };
}

// node_modules/basicprimitives/src/tasks/templates/AnnotationLabelTemplateTask.js
function AnnotationLabelTemplateTask(itemsSizesOptionTask, templates) {
  var _data = {
    template: null
  };
  function process() {
    return false;
  }
  function getTemplate() {
    if (_data.template == null) {
      _data.template = new templates.AnnotationLabelTemplate();
    }
    return _data.template;
  }
  return {
    process,
    getTemplate
  };
}

// node_modules/basicprimitives/src/tasks/templates/LevelAnnotationTemplateTask.js
function LevelAnnotationTemplateTask(orientationOptionTask, levelTitleTemplateOptionTask, templates) {
  var _data = {
    backgroundTemplate: null,
    titleTemplate: null
  };
  function process() {
    _data.backgroundTemplate = null;
    _data.titleTemplate = null;
    return true;
  }
  function getBackgroundTemplate() {
    var options;
    if (_data.backgroundTemplate == null) {
      options = levelTitleTemplateOptionTask.getOptions();
      var { onLevelBackgroundRender } = options;
      if (onLevelBackgroundRender != null) {
        _data.backgroundTemplate = new templates.CustomRenderTemplate(options, onLevelBackgroundRender);
      } else {
        _data.backgroundTemplate = new templates.LevelBackgroundTemplate(options);
      }
    }
    return _data.backgroundTemplate;
  }
  function getTitleTemplate() {
    var options;
    if (_data.titleTemplate == null) {
      var { orientationType: orientation } = orientationOptionTask.getOptions();
      options = levelTitleTemplateOptionTask.getOptions();
      var { onLevelTitleRender } = options;
      if (onLevelTitleRender != null) {
        _data.titleTemplate = new templates.CustomRenderTemplate(options, onLevelTitleRender);
      } else {
        _data.titleTemplate = new templates.LevelTitleTemplate(options, orientation);
      }
    }
    return _data.titleTemplate;
  }
  return {
    process,
    getBackgroundTemplate,
    getTitleTemplate
  };
}

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/enums.js
var GroupType = {
  Items: 0,
  Assistants: 1,
  RowChildren: 2,
  Children: 3
};
var RowType = {
  Items: 0,
  Advisers: 1,
  SubAdvisers: 2,
  Assistants: 3,
  SubAssistants: 4,
  RowChildren: 5,
  Children: 6
};
var RowTypeToGroupTypeMap = {};
RowTypeToGroupTypeMap[RowType.Items] = GroupType.Items;
RowTypeToGroupTypeMap[RowType.Advisers] = GroupType.Items;
RowTypeToGroupTypeMap[RowType.SubAdvisers] = GroupType.Items;
RowTypeToGroupTypeMap[RowType.Assistants] = GroupType.Assistants;
RowTypeToGroupTypeMap[RowType.SubAssistants] = GroupType.Assistants;
RowTypeToGroupTypeMap[RowType.RowChildren] = GroupType.RowChildren;
RowTypeToGroupTypeMap[RowType.Children] = GroupType.Children;

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/BranchAligner.js
function RowKeyGenerator() {
  var _rowsHash = {};
  var _rowIndex = 1;
  function find(parentId, rowType, index) {
    var key = parentId + "-" + rowType + "-" + index;
    if (!_rowsHash.hasOwnProperty(key)) {
      _rowsHash[key] = _rowIndex;
      _rowIndex += 1;
    }
    return _rowsHash[key];
  }
  function get() {
    var result = _rowIndex;
    _rowIndex += 1;
    return result;
  }
  return {
    find,
    get
  };
}
function Row(id) {
  this.id = id;
  this.rowType = RowType.Items;
  this.index = 0;
  this.offset = 0;
  this.extend = true;
  this.depth = 0;
  this.groups = [];
  this.groups[GroupType.Items] = [[1, 1]];
  this.getDepth = function() {
    var [currExtend, currDepth] = this.groups.reduce((acc, row) => {
      return row.reduce(([currExtend2, currDepth2], item) => {
        var [extend, depth] = item || [1, 1];
        return [currExtend2 + extend, Math.max(currDepth2, currExtend2 + depth)];
      }, acc);
    }, [0, 0]);
    return Math.max(currExtend, currDepth) || 1;
  };
  this.addRowDepth = function(rowType, extend, index, depth) {
    var groupIndex = RowTypeToGroupTypeMap[rowType];
    if (!this.groups[groupIndex]) {
      this.groups[groupIndex] = [];
    }
    var rows = this.groups[groupIndex];
    var [currExtend, currDepth] = rows[index] || [1, 1];
    rows[index] = [Math.max(currExtend, extend ? depth : 1), Math.max(currDepth, depth)];
  };
}
function BranchAligner() {
  var _rowsTree = Tree();
  var _rowKeyGenerator = RowKeyGenerator();
  var _rowHash = {};
  function _createParentRow(parentNodeId) {
    var parentRowId = _rowKeyGenerator.find(null, RowType.Children, 0);
    var parentRow = new Row(parentRowId);
    parentRow.rowType = RowType.Items;
    parentRow.index = 0;
    parentRow.offset = 0;
    parentRow.extend = false;
    _rowsTree.add(null, parentRowId, parentRow);
    _rowHash[parentNodeId] = parentRowId;
    return parentRowId;
  }
  function mergeToParent(parentNodeId, nodes) {
    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);
    nodes.forEach((child) => {
      _rowHash[child.id] = parentRowId;
    });
  }
  function mergeToChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {
    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);
    var rowId = _rowKeyGenerator.find(parentRowId, rowType, index);
    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);
  }
  function addChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {
    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);
    var rowId = _rowKeyGenerator.get();
    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);
  }
  function addSplitChildren(parentNodeId, nodes, rowType, index, offset) {
    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);
    nodes.forEach((child) => {
      var rowId = _rowKeyGenerator.get();
      var row = new Row(rowId);
      row.extend = false;
      row.index = index || 0;
      row.offset = offset || 0;
      row.rowType = rowType;
      _rowsTree.add(parentRowId, rowId, row);
      _rowHash[child.id] = rowId;
    });
  }
  function _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren) {
    var row = _rowsTree.node(rowId);
    if (!row) {
      row = new Row(rowId);
      row.extend = extendChildren;
      row.index = index || 0;
      row.offset = offset || 0;
      row.rowType = rowType;
      _rowsTree.add(parentRowId, rowId, row);
    }
    nodes.forEach((child) => {
      _rowHash[child.id] = rowId;
    });
  }
  function align(debug) {
    _rowsTree.loopPostOrder(this, function(rowId, row, parentRowId, parentRow) {
      row.depth = row.getDepth() + row.offset;
      if (parentRow != null) {
        parentRow.addRowDepth(row.rowType, row.extend, row.index, row.depth);
      }
    });
  }
  function loopGroupTypes(thisArg, nodeId, onGroupType) {
    var rowId = _rowHash[nodeId];
    var row = _rowsTree.node(rowId);
    if (row) {
      for (var index = 0, len = row.groups.length; index < len; index += 1) {
        if (row.groups[index]) {
          if (onGroupType.call(thisArg, index, len)) {
            break;
          }
        }
      }
    }
  }
  function getRowDepth(nodeId, groupType, index) {
    var rowId = _rowHash[nodeId];
    var row = _rowsTree.node(rowId);
    var childRow = (row.groups[groupType] || [])[index];
    return childRow && childRow[0] || 1;
  }
  function getGroupSize(nodeId, groupType) {
    var rowId = _rowHash[nodeId];
    var row = _rowsTree.node(rowId);
    if (row) {
      if (row.groups.hasOwnProperty(groupType)) {
        return row.groups[groupType].length;
      }
    }
    return 0;
  }
  function getRowsDepth(nodeId, groupType) {
    var rowId = _rowHash[nodeId];
    var row = _rowsTree.node(rowId);
    var children = row.groups[groupType] || [];
    return children.map((item) => item[0]);
  }
  function loopRows(thisArg, nodeId, rowType, onRow) {
    var rowId = _rowHash[nodeId];
    var row = _rowsTree.node(rowId);
    var groupIndex = RowTypeToGroupTypeMap[rowType];
    var children = row.groups[groupIndex] || [];
    for (var index = 0; index < children.length; index += 1) {
      var childRow = children[index];
      if (childRow) {
        if (onRow.call(thisArg, childRow[0], index)) {
          break;
        }
      }
    }
  }
  return {
    mergeToParent,
    mergeToChild,
    addChild,
    addSplitChildren,
    align,
    loopGroupTypes,
    getRowDepth,
    getRowsDepth,
    loopRows,
    getGroupSize
  };
}
var BranchAligner_default = BranchAligner;

// node_modules/basicprimitives/src/models/TreeItem.js
function TreeItem() {
  this.id = null;
  this.visualAggregatorId = null;
  this.partners = [];
  this.visibility = Visibility.Normal;
  this.actualItemType = null;
  this.connectorPlacement = 0;
  this.gravity = 0;
  this.relationDegree = 0;
}

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/NodeTypeSorter.js
function NodeTypeSorter() {
  var _rows = [];
  function getRow(itemType, index) {
    return (_rows[itemType] || [])[index || 0] || [];
  }
  function getRows(itemType) {
    return _rows[itemType] || [];
  }
  function addChild(itemType, levelOffset, orgItem) {
    switch (itemType) {
      case ItemType.SubAssistant:
      case ItemType.Assistant:
        levelOffset = levelOffset < 0 || levelOffset == null ? 0 : levelOffset;
        break;
      default:
        levelOffset = 0;
        break;
    }
    _rows[itemType] = _rows[itemType] || [];
    var groups = _rows[itemType];
    groups[levelOffset] = groups[levelOffset] || [];
    groups[levelOffset].push(orgItem);
  }
  return {
    addChild,
    getRow,
    getRows
  };
}
var NodeTypeSorter_default = NodeTypeSorter;

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/NodeGroupSorter.js
function NodeGroupSorter() {
  var _rows = [];
  function getRow(groupType, index) {
    return (_rows[groupType] || [])[index || 0] || [];
  }
  function getRows(groupType) {
    return _rows[groupType] || [];
  }
  function getLength() {
    return _rows.length;
  }
  function _addChild(groupType, index, orgItem) {
    _rows[groupType] = _rows[groupType] || [];
    var groups = _rows[groupType];
    groups[index] = groups[index] || [];
    groups[index].push(orgItem);
  }
  function addChild(itemType, index, orgItem) {
    switch (itemType) {
      case ItemType.SubAdviser:
      case ItemType.Adviser:
        _addChild(GroupType.Items, 0, orgItem);
        break;
      case ItemType.SubAssistant:
      case ItemType.Assistant:
        index = index < 0 || index == null ? 0 : index;
        _addChild(GroupType.Assistants, index, orgItem);
        break;
      case ItemType.Regular:
        if (index < 0 || index === void 0 || index === null) {
          _addChild(GroupType.Children, 0, orgItem);
        } else {
          _addChild(GroupType.RowChildren, index, orgItem);
        }
        break;
      default:
        break;
    }
  }
  return {
    addChild,
    getLength,
    getRow,
    getRows
  };
}
var NodeGroupSorter_default = NodeGroupSorter;

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/NavigationalFamily.js
function NavigationalFamily(activeItems) {
  var _activeItems = activeItems, _navigationFamily = Family();
  function define(parentItem, treeItem, skipFirstParent) {
    var parents = [];
    if (skipFirstParent || !parentItem.isVisible || !_activeItems.hasOwnProperty(parentItem.id)) {
      if (!skipFirstParent && parentItem.isVisible) {
        parents.push(parentItem.id);
      }
      _navigationFamily.loopParents(
        this,
        parentItem.id,
        function(parentId, parent, level) {
          if (parent.isVisible) {
            parents.push(parentId);
            if (_activeItems.hasOwnProperty(parentId)) {
              return _navigationFamily.SKIP;
            }
          }
        }
      );
    } else {
      parents.push(parentItem.id);
    }
    if (_navigationFamily.node(treeItem.id) != null) {
      _navigationFamily.adopt(parents, treeItem.id);
    } else {
      _navigationFamily.add(parents, treeItem.id, treeItem);
    }
  }
  function getFamily() {
    return _navigationFamily;
  }
  return {
    define,
    getFamily
  };
}

// node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/VisualTreeBuilder.js
function NodeProps() {
  this.hasVisibleChildren = false;
  this.hasPartners = false;
  this.isPartner = false;
  this.hasLeavesOnly = true;
  this.hasChildren = false;
  this.typeSorter = NodeTypeSorter_default();
  this.groupSorter = NodeGroupSorter_default();
}
function VisualTreeBuilder() {
  var _treeItemCounter, _activeItems;
  function build(orgTree, maximumId, activeItems, options) {
    _treeItemCounter = maximumId;
    _activeItems = activeItems;
    var { visualTree, navigationFamily, branchAligner } = createVisualTreeItems(orgTree, options, activeItems);
    return {
      visualTree,
      navigationFamily: navigationFamily.getFamily(),
      branchAligner,
      treeItemCounter: _treeItemCounter
    };
  }
  function createVisualTreeItems(orgTree, options, activeItems) {
    var index, leftSiblingOffset, rightSiblingOffset, orgTreeProps = {}, visualTree = Tree(), navigationFamily = NavigationalFamily(activeItems);
    orgTree.loopPostOrder(this, function(nodeId, node, parentId, parent) {
      if (!orgTreeProps.hasOwnProperty(nodeId)) {
        orgTreeProps[nodeId] = new NodeProps();
      }
      var nodeProps = orgTreeProps[nodeId];
      nodeProps.actualItemType = node.itemType;
      if (parent != null) {
        if (!orgTreeProps.hasOwnProperty(parentId)) {
          orgTreeProps[parentId] = new NodeProps();
        }
        var parentProps = orgTreeProps[parentId];
        parentProps.hasVisibleChildren = parentProps.hasVisibleChildren || node.isVisible || nodeProps.hasVisibleChildren;
        parentProps.hasChildren = true;
        parentProps.hasLeavesOnly = parentProps.hasLeavesOnly && !nodeProps.hasChildren;
      }
    });
    orgTree.loopPreOrder(this, function(nodeId, node, parentId, parent) {
      var nodeProps = orgTreeProps[nodeId];
      var parentProps = orgTreeProps[parentId];
      if (!parentProps) {
        parentProps = new NodeProps();
        parentProps.actualItemType = ItemType.Regular;
        orgTreeProps[parentId] = parentProps;
      }
      switch (nodeProps.actualItemType) {
        case ItemType.LimitedPartner:
        case ItemType.AdviserPartner:
        case ItemType.GeneralPartner:
          if (parentProps.isPartner) {
            nodeProps.actualItemType = ItemType.Adviser;
          } else {
            nodeProps.isPartner = true;
            parentProps.hasPartners = true;
          }
          break;
        case ItemType.Regular:
          if (parentProps.isPartner) {
            nodeProps.actualItemType = ItemType.Assistant;
          }
          break;
      }
    });
    var branchAligner = BranchAligner_default();
    orgTree.loopLevels(this, function(parentOrgItemId, parentOrgItem, levelid) {
      var parentProps = orgTreeProps[parentOrgItemId];
      if (!parentProps.hasVisibleChildren) {
        return orgTree.SKIP;
      }
      orgTree.loopChildren(this, parentOrgItemId, function(orgItemId, orgItem, index2) {
        var treeItemProps = orgTreeProps[orgItemId];
        parentProps.typeSorter.addChild(treeItemProps.actualItemType, orgItem.levelOffset, orgItem);
        parentProps.groupSorter.addChild(treeItemProps.actualItemType, orgItem.levelOffset, orgItem);
      });
      var partners = [];
      if (parentProps.hasPartners) {
        partners = [...parentProps.typeSorter.getRow(ItemType.AdviserPartner), ...parentProps.typeSorter.getRow(ItemType.LimitedPartner), ...parentProps.typeSorter.getRow(ItemType.GeneralPartner)];
      }
      var advisers = parentProps.typeSorter.getRow(ItemType.Adviser);
      if (advisers.length > 0) {
        var extendChildren = partners.length > 0;
        if (!extendChildren) {
          switch (parentOrgItem.placeAdvisersAboveChildren) {
            case Enabled.Auto:
              extendChildren = options.placeAdvisersAboveChildren;
              break;
            case Enabled.True:
              extendChildren = true;
              break;
          }
        }
        if (options.alignBranches) {
          if (parentProps.isPartner) {
            extendChildren = true;
          }
          if (extendChildren) {
            branchAligner.mergeToChild(parentOrgItemId, advisers, RowType.Advisers, 0, 0, extendChildren);
          } else {
            branchAligner.mergeToParent(parentOrgItemId, advisers);
          }
        } else {
          branchAligner.addChild(parentOrgItemId, advisers, RowType.Advisers, 0, 0, extendChildren);
        }
      }
      var subAdvisers = parentProps.typeSorter.getRow(ItemType.SubAdviser);
      if (subAdvisers.length > 0) {
        var extendChildren = partners.length > 0;
        if (!extendChildren) {
          switch (parentOrgItem.placeAdvisersAboveChildren) {
            case Enabled.Auto:
              extendChildren = options.placeAdvisersAboveChildren;
              break;
            case Enabled.True:
              extendChildren = true;
              break;
          }
        }
        if (options.alignBranches) {
          if (parentProps.isPartner) {
            extendChildren = true;
          }
          branchAligner.mergeToChild(parentOrgItemId, subAdvisers, RowType.SubAdvisers, 0, 1, extendChildren);
        } else {
          branchAligner.addChild(parentOrgItemId, subAdvisers, RowType.SubAdvisers, 0, 1, extendChildren);
        }
      }
      var assistants = parentProps.typeSorter.getRows(ItemType.Assistant);
      if (assistants.length > 0) {
        var extendChildren = partners.length > 0;
        if (!extendChildren) {
          switch (parentOrgItem.placeAssistantsAboveChildren) {
            case Enabled.Auto:
              extendChildren = options.placeAssistantsAboveChildren;
              break;
            case Enabled.True:
              extendChildren = true;
              break;
          }
        }
        assistants.forEach((nodes, index2) => {
          if (options.alignBranches) {
            branchAligner.mergeToChild(parentOrgItemId, nodes, RowType.Assistants, index2, 0, extendChildren);
          } else {
            branchAligner.addChild(parentOrgItemId, nodes, RowType.Assistants, index2, 0, extendChildren);
          }
        });
      }
      var subAssistants = parentProps.typeSorter.getRows(ItemType.SubAssistant);
      if (subAssistants.length > 0) {
        var extendChildren = partners.length > 0;
        if (!extendChildren) {
          switch (parentOrgItem.placeAssistantsAboveChildren) {
            case Enabled.Auto:
              extendChildren = options.placeAssistantsAboveChildren;
              break;
            case Enabled.True:
              extendChildren = true;
              break;
          }
        }
        subAssistants.forEach((nodes, index2) => {
          if (options.alignBranches) {
            branchAligner.mergeToChild(parentOrgItemId, nodes, RowType.SubAssistants, index2, 1, extendChildren);
          } else {
            branchAligner.addChild(parentOrgItemId, nodes, RowType.SubAssistants, index2, 1, extendChildren);
          }
        });
      }
      if (partners.length > 0) {
        branchAligner.mergeToParent(parentOrgItemId, partners);
      }
      var rowChildren = parentProps.groupSorter.getRows(GroupType.RowChildren);
      if (rowChildren.length > 0) {
        rowChildren.forEach((nodes, index2) => {
          if (options.alignBranches) {
            branchAligner.mergeToChild(parentOrgItemId, nodes, RowType.RowChildren, index2, 0, true);
          } else {
            branchAligner.addChild(parentOrgItemId, nodes, RowType.RowChildren, index2, 0, true);
          }
        });
      }
      var children = parentProps.groupSorter.getRow(GroupType.Children);
      if (children.length > 0) {
        var props = orgTreeProps[parentOrgItemId];
        var childrenRows = getRegularChildrenRows(options, children, parentOrgItem.childrenPlacementType, props.hasLeavesOnly);
        childrenRows.forEach((nodes, index2) => {
          if (options.alignBranches) {
            branchAligner.mergeToChild(parentOrgItemId, nodes, RowType.Children, index2, 0, true);
          } else {
            if (index2 == childrenRows.length - 1) {
              branchAligner.addSplitChildren(parentOrgItemId, nodes, RowType.Children, index2, 0);
            } else {
              branchAligner.addChild(parentOrgItemId, nodes, RowType.Children, index2, 0, true);
            }
          }
        });
      }
    });
    branchAligner.align();
    var visualPartners = {};
    orgTree.loopLevels(this, function(parentOrgItemId, parentOrgItem, levelid) {
      var parentProps = orgTreeProps[parentOrgItemId];
      var logicalParentItem = visualTree.node(parentOrgItemId);
      if (!logicalParentItem) {
        logicalParentItem = getNewTreeItem({
          visibility: Visibility.Invisible,
          connectorPlacement: 0,
          parentId: null,
          actualItemType: ItemType.Regular
        }, parentOrgItem);
        visualTree.add(null, parentOrgItemId, logicalParentItem);
      }
      leftSiblingOffset = 0;
      rightSiblingOffset = 0;
      if ((index = visualTree.indexOf(parentOrgItemId)) != null) {
        leftSiblingOffset = index;
        rightSiblingOffset = visualTree.countSiblings(parentOrgItemId) - index - 1;
      }
      var partners = [];
      if (parentProps.hasPartners) {
        partners = [
          ...parentProps.typeSorter.getRow(ItemType.AdviserPartner),
          ...parentProps.typeSorter.getRow(ItemType.LimitedPartner),
          ...parentProps.typeSorter.getRow(ItemType.GeneralPartner)
        ];
      }
      var visualParent = logicalParentItem;
      var visualParent2 = null;
      var flagPartners = true;
      branchAligner.loopGroupTypes(this, parentOrgItemId, function(groupType, len) {
        if (!(parentProps.hasPartners || parentProps.isPartner) && groupType > parentProps.groupSorter.getLength() - 1) {
          return true;
        }
        if (groupType > GroupType.Assistants && flagPartners) {
          flagPartners = false;
          if (parentProps.hasPartners) {
            visualPartners[parentOrgItemId] = [visualParent.id];
            visualParent = visualParent2 || visualParent;
            visualParent2 = null;
            visualParent.partners = visualPartners[parentOrgItemId];
          }
          if (parentProps.isPartner) {
            visualPartners[parentOrgItem.parent].push(visualParent.id);
          }
        }
        var fillEmptyLevels = (parentProps.isPartner || parentProps.hasPartners) && groupType <= GroupType.Assistants;
        fillEmptyLevels = fillEmptyLevels || groupType < parentProps.groupSorter.getLength() - 1;
        var rows = [];
        switch (groupType) {
          case GroupType.Items:
            var row = parentProps.groupSorter.getRows(GroupType.Items)[0] || [];
            var depth = branchAligner.getRowDepth(parentOrgItemId, GroupType.Items, 0);
            addAdvisers(visualTree, orgTreeProps, visualParent, row, leftSiblingOffset, rightSiblingOffset);
            row.forEach((item) => navigationFamily.define(parentOrgItem, item));
            if (partners.length > 0) {
              visualParent2 = addPartners(visualTree, orgTreeProps, visualParent, partners, leftSiblingOffset, rightSiblingOffset);
              partners.forEach((partner) => {
                navigationFamily.define(parentOrgItem, partner, true);
                if (partner.id != logicalParentItem.id) {
                  var rowChildren = parentProps.groupSorter.getRows(GroupType.RowChildren);
                  rowChildren.forEach((row2) => row2.forEach((child) => navigationFamily.define(partner, child)));
                  var regularChildren2 = parentProps.groupSorter.getRow(GroupType.Children);
                  regularChildren2.forEach((child) => navigationFamily.define(partner, child));
                }
              });
            }
            if (parentProps.hasPartners || parentProps.isPartner || groupType < parentProps.groupSorter.getLength() - 1) {
              while (depth > 1) {
                visualParent = createNewVisualAggregator(visualTree, visualParent, false);
                if (visualParent2) {
                  visualParent2 = createNewVisualAggregator(visualTree, visualParent2, false);
                }
                depth -= 1;
              }
            }
            break;
          case GroupType.Assistants:
            var rows = parentProps.groupSorter.getRows(GroupType.Assistants);
            branchAligner.loopRows(this, parentOrgItemId, RowType.Assistants, function(depth2, rowIndex) {
              var row2 = rows[rowIndex] || [];
              if (!fillEmptyLevels && rowIndex > rows.length - 1) {
                return true;
              }
              visualParent = addAssistants(visualTree, orgTreeProps, visualParent, row2);
              if (visualParent2) {
                visualParent2 = createNewVisualAggregator(visualTree, visualParent2, false);
              }
              row2.forEach((item) => navigationFamily.define(parentOrgItem, item));
              if (parentProps.hasPartners || parentProps.isPartner || rowIndex < rows.length - 1 || groupType < parentProps.groupSorter.getLength() - 1) {
                while (depth2 > 1) {
                  visualParent = createNewVisualAggregator(visualTree, visualParent, false);
                  if (visualParent2) {
                    visualParent2 = createNewVisualAggregator(visualTree, visualParent2, false);
                  }
                  depth2 -= 1;
                }
              }
            });
            break;
          case GroupType.RowChildren:
            var rows = parentProps.groupSorter.getRows(GroupType.RowChildren);
            branchAligner.loopRows(this, parentOrgItemId, RowType.RowChildren, function(depth2, rowIndex) {
              var row2 = rows[rowIndex] || [];
              if (!fillEmptyLevels && rowIndex > rows.length - 1) {
                return true;
              }
              var hideChildConnector = logicalParentItem.visibility == Visibility.Invisible && logicalParentItem.connectorPlacement === 0;
              visualParent = addRowChildren(visualTree, visualParent, row2, fillEmptyLevels || rowIndex < rows.length - 1, hideChildConnector, options.horizontalAlignment);
              row2.forEach((item) => navigationFamily.define(parentOrgItem, item));
              if (rowIndex < rows.length - 1 || groupType < parentProps.groupSorter.getLength() - 1) {
                while (depth2 > 1) {
                  visualParent = createNewVisualAggregator(visualTree, visualParent, false);
                  depth2 -= 1;
                }
              }
            });
            break;
          case GroupType.Children:
            var regularChildren = parentProps.groupSorter.getRow(GroupType.Children);
            if (regularChildren.length > 0) {
              var props = orgTreeProps[logicalParentItem.id];
              var depths = branchAligner.getRowsDepth(parentOrgItemId, GroupType.Children);
              addChildren(orgTree, visualTree, depths, options, logicalParentItem, visualParent, regularChildren, parentOrgItem.childrenPlacementType, props.hasLeavesOnly);
              regularChildren.forEach((item) => navigationFamily.define(parentOrgItem, item));
            }
            break;
        }
      });
      if (flagPartners) {
        flagPartners = false;
        if (parentProps.hasPartners) {
          visualPartners[parentOrgItemId] = [visualParent.id];
          visualParent = visualParent2 || visualParent;
          visualParent2 = null;
          visualParent.partners = visualPartners[parentOrgItemId];
        }
        if (parentProps.isPartner) {
          visualPartners[parentOrgItem.parent].push(visualParent.id);
        }
      }
      if (!parentProps.hasVisibleChildren) {
        return orgTree.SKIP;
      }
    });
    return {
      visualTree,
      navigationFamily,
      branchAligner
    };
  }
  function addPartners(visualTree, orgTreeProps, parent, partners, leftSiblingOffset, rightSiblingOffset) {
    var leftItems = [];
    var rightItems = [];
    partners.map((partner) => getNewTreeItem({}, partner)).forEach((item2) => {
      var isLeft = true;
      if (parent.connectorPlacement & SideFlag.Right) {
        isLeft = true;
        item2.connectorPlacement = SideFlag.Right | SideFlag.Bottom;
      } else if (parent.connectorPlacement & SideFlag.Left) {
        isLeft = false;
        item2.connectorPlacement = SideFlag.Left | SideFlag.Bottom;
      } else {
        switch (item2.adviserPlacementType) {
          case AdviserPlacementType.Left:
            isLeft = true;
            item2.connectorPlacement = SideFlag.Right | SideFlag.Bottom;
            break;
          default:
            isLeft = false;
            item2.connectorPlacement = SideFlag.Left | SideFlag.Bottom;
            break;
        }
        var itemProp = orgTreeProps[item2.id];
        switch (itemProp.actualItemType) {
          case ItemType.GeneralPartner:
            item2.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
            break;
          case ItemType.LimitedPartner:
            item2.connectorPlacement = SideFlag.Bottom;
            break;
          default:
            break;
        }
      }
      if (isLeft) {
        leftItems.unshift(item2);
      } else {
        rightItems.push(item2);
      }
    });
    var partners = [...leftItems, parent, ...rightItems];
    var parentIndex = leftItems.length;
    var centerIndex = Math.floor(partners.length / 2);
    var invisiblePartner = null;
    if (partners.length % 2 == 0) {
      invisiblePartner = getNewTreeItem({ visibility: Visibility.Invisible });
      partners.splice(centerIndex, 0, invisiblePartner);
      if (centerIndex <= parentIndex) {
        parentIndex += 1;
      }
    }
    var visualParent = visualTree.parent(parent.id);
    for (var index = parentIndex - 1; index >= 0; index -= 1) {
      var item = partners[index];
      visualTree.add(visualParent.id, item.id, item, leftSiblingOffset);
      item.gravity = HorizontalAlignmentType.Right;
    }
    for (var index = parentIndex + 1; index < partners.length; index += 1) {
      var item = partners[index];
      visualTree.add(visualParent.id, item.id, item, visualTree.countChildren(visualParent.id) - rightSiblingOffset);
      item.gravity = HorizontalAlignmentType.Left;
    }
    if (invisiblePartner != null) {
      var mimicPartner = null;
      if (centerIndex <= parentIndex) {
        mimicPartner = partners[centerIndex - 1];
      } else {
        mimicPartner = partners[centerIndex + 1];
      }
      invisiblePartner.connectorPlacement = mimicPartner.connectorPlacement & (SideFlag.Left | SideFlag.Right);
    }
    var centerPartner = partners[centerIndex];
    return centerPartner;
  }
  function addAdvisers(visualTree, orgTreeProps, parent, advisers, leftSiblingOffset, rightSiblingOffset) {
    advisers.map((adviser) => getNewTreeItem({}, adviser)).forEach((item) => {
      var itemProps = orgTreeProps[item.id];
      var alteredItem;
      switch (itemProps.actualItemType) {
        case ItemType.SubAdviser:
          item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
          alteredItem = getNewTreeItem({ visibility: Visibility.Invisible });
          visualTree.add(alteredItem.id, item.id, item);
          break;
        default:
          alteredItem = item;
          break;
      }
      var visualParent = visualTree.parent(parent.id);
      if (parent.connectorPlacement & SideFlag.Right) {
        visualTree.add(visualParent.id, alteredItem.id, alteredItem, leftSiblingOffset);
        alteredItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;
        alteredItem.gravity = HorizontalAlignmentType.Right;
      } else if (parent.connectorPlacement & SideFlag.Left) {
        visualTree.add(visualParent.id, alteredItem.id, alteredItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);
        alteredItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;
        alteredItem.gravity = HorizontalAlignmentType.Left;
      } else {
        switch (item.adviserPlacementType) {
          case AdviserPlacementType.Left:
            visualTree.add(visualParent.id, alteredItem.id, alteredItem, leftSiblingOffset);
            alteredItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;
            alteredItem.gravity = HorizontalAlignmentType.Right;
            break;
          default:
            visualTree.add(visualParent.id, alteredItem.id, alteredItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);
            alteredItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;
            alteredItem.gravity = HorizontalAlignmentType.Left;
            break;
        }
        switch (item.actualItemType) {
          case ItemType.GeneralPartner:
            alteredItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
            break;
          case ItemType.LimitedPartner:
            alteredItem.connectorPlacement = SideFlag.Bottom;
            break;
        }
      }
    });
  }
  function addAssistants(visualTree, orgTreeProps, visualParent, assistants) {
    var nextVisualParent = createNewVisualAggregator(visualTree, visualParent, false);
    assistants.map((assistant) => getNewTreeItem({}, assistant)).forEach((item) => {
      var itemProps = orgTreeProps[item.id];
      var alteredItem;
      switch (itemProps.actualItemType) {
        case ItemType.SubAssistant:
          item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
          alteredItem = getNewTreeItem({ visibility: Visibility.Invisible });
          visualTree.add(alteredItem.id, item.id, item);
          break;
        case ItemType.Assistant:
          alteredItem = item;
          break;
      }
      switch (item.adviserPlacementType) {
        case AdviserPlacementType.Left:
          visualTree.add(visualParent.id, alteredItem.id, alteredItem, 0);
          alteredItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;
          alteredItem.gravity = HorizontalAlignmentType.Right;
          break;
        default:
          visualTree.add(visualParent.id, alteredItem.id, alteredItem);
          alteredItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;
          alteredItem.gravity = HorizontalAlignmentType.Left;
          break;
      }
    });
    return nextVisualParent;
  }
  function addRowChildren(visualTree, visualParent, rowOfChildren, fillEmptyLevels, hideChildConnector, horizontalAlignment) {
    var nextVisualParent = null;
    if (fillEmptyLevels) {
      nextVisualParent = createNewVisualAggregator(visualTree, visualParent, hideChildConnector);
    }
    var medianIndex = 0;
    switch (horizontalAlignment) {
      case HorizontalAlignmentType.Center:
        medianIndex = Math.ceil(rowOfChildren.length / 2) - 1;
        break;
      case HorizontalAlignmentType.Left:
        medianIndex = -1;
        break;
      case HorizontalAlignmentType.Right:
        medianIndex = rowOfChildren.length - 1;
        break;
    }
    for (var index = medianIndex; index >= 0; index -= 1) {
      var item = getNewTreeItem({}, rowOfChildren[index]);
      visualTree.add(visualParent.id, item.id, item, 0);
      item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
      item.gravity = HorizontalAlignmentType.Right;
    }
    for (index = medianIndex + 1; index < rowOfChildren.length; index += 1) {
      item = getNewTreeItem({}, rowOfChildren[index]);
      visualTree.add(visualParent.id, item.id, item);
      item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;
      item.gravity = HorizontalAlignmentType.Left;
    }
    return nextVisualParent;
  }
  function addChildren(orgTree, visualTree, depths, options, treeItem, visualParent, regularChildren, childrenPlacementType, hasLeavesOnly) {
    var visualParent, currentVisualParent, leftChildItem, rightChildItem, newAggregatorItem, childItem, orgChildItem, width, height, twinColumns, rowIndex, index, len, singleItemPlacement, hideParentConnector = treeItem.visibility == Visibility.Invisible && treeItem.connectorPlacement === 0;
    switch (options.horizontalAlignment) {
      case HorizontalAlignmentType.Center:
      case HorizontalAlignmentType.Left:
        singleItemPlacement = AdviserPlacementType.Right;
        break;
      case HorizontalAlignmentType.Right:
        singleItemPlacement = AdviserPlacementType.Left;
        break;
    }
    if (childrenPlacementType === ChildrenPlacementType.Auto) {
      if (hasLeavesOnly) {
        childrenPlacementType = options.leavesPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Matrix : options.leavesPlacementType;
      } else {
        childrenPlacementType = options.childrenPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Horizontal : options.childrenPlacementType;
      }
    }
    if (childrenPlacementType == ChildrenPlacementType.Matrix && regularChildren.length < 3) {
      childrenPlacementType = ChildrenPlacementType.Horizontal;
    }
    switch (childrenPlacementType) {
      case ChildrenPlacementType.Horizontal:
        for (index = 0, len = regularChildren.length; index < len; index += 1) {
          childItem = getNewTreeItem({}, regularChildren[index]);
          orgChildItem = orgTree.node(childItem.id);
          visualTree.add(visualParent.id, childItem.id, childItem);
          childItem.connectorPlacement = (orgChildItem.hideParentConnection ? 0 : SideFlag.Top) | (orgChildItem.hideChildrenConnection ? 0 : SideFlag.Bottom);
          if (index === 0) {
            childItem.relationDegree = 1;
          }
        }
        break;
      case ChildrenPlacementType.Matrix:
        width = Math.min(options.maximumColumnsInMatrix, Math.ceil(Math.sqrt(regularChildren.length)));
        height = Math.ceil(regularChildren.length / width);
        twinColumns = Math.ceil(width / 2);
        for (var columnIndex = 0; columnIndex < twinColumns; columnIndex += 1) {
          currentVisualParent = visualParent;
          for (rowIndex = 0; rowIndex < height; rowIndex += 1) {
            leftChildItem = getMatrixItem(regularChildren, columnIndex * 2, rowIndex, width);
            rightChildItem = getMatrixItem(regularChildren, columnIndex * 2 + 1, rowIndex, width);
            if (leftChildItem !== null || rightChildItem !== null) {
              var depth = depths[rowIndex - 1] || 1;
              while (depth > 1) {
                newAggregatorItem = getNewTreeItem({
                  visibility: Visibility.Invisible,
                  connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom
                });
                visualTree.add(currentVisualParent.id, newAggregatorItem.id, newAggregatorItem);
                currentVisualParent = newAggregatorItem;
                depth -= 1;
              }
            }
            if (leftChildItem !== null) {
              leftChildItem = getNewTreeItem({}, leftChildItem);
              if (columnIndex === 0) {
                leftChildItem.relationDegree = 1;
              }
              visualTree.add(currentVisualParent.id, leftChildItem.id, leftChildItem);
              leftChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;
              leftChildItem.gravity = HorizontalAlignmentType.Right;
            }
            if (leftChildItem !== null || rightChildItem !== null) {
              newAggregatorItem = getNewTreeItem({
                visibility: Visibility.Invisible,
                connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom
              });
              visualTree.add(currentVisualParent.id, newAggregatorItem.id, newAggregatorItem);
            }
            if (rightChildItem !== null) {
              rightChildItem = getNewTreeItem({}, rightChildItem);
              visualTree.add(currentVisualParent.id, rightChildItem.id, rightChildItem);
              rightChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;
              rightChildItem.gravity = HorizontalAlignmentType.Left;
            }
            currentVisualParent = newAggregatorItem;
          }
        }
        if (width > 2) {
          visualParent.visualAggregatorId = null;
        }
        break;
      case ChildrenPlacementType.Vertical:
        for (index = 0, len = regularChildren.length; index < len; index += 1) {
          childItem = getNewTreeItem({}, regularChildren[index]);
          var depth = index == len - 1 ? 1 : depths[index] || 1;
          var aggregatorItem = visualParent;
          while (depth > 0) {
            newAggregatorItem = getNewTreeItem({
              visibility: Visibility.Invisible,
              connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom
            });
            visualTree.add(aggregatorItem.id, newAggregatorItem.id, newAggregatorItem);
            aggregatorItem = newAggregatorItem;
            depth -= 1;
          }
          switch (singleItemPlacement) {
            case AdviserPlacementType.Left:
              visualTree.add(visualParent.id, childItem.id, childItem, 0);
              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;
              childItem.gravity = HorizontalAlignmentType.Right;
              break;
            case AdviserPlacementType.Right:
              visualTree.add(visualParent.id, childItem.id, childItem);
              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;
              childItem.gravity = HorizontalAlignmentType.Left;
              break;
          }
          visualParent = newAggregatorItem;
        }
        break;
      default:
        throw "Children placement is undefined!";
    }
  }
  function getRegularChildrenRows(options, regularChildren, childrenPlacementType, hasLeavesOnly) {
    var results = [];
    if (childrenPlacementType === ChildrenPlacementType.Auto) {
      if (hasLeavesOnly) {
        childrenPlacementType = options.leavesPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Matrix : options.leavesPlacementType;
      } else {
        childrenPlacementType = options.childrenPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Horizontal : options.childrenPlacementType;
      }
    }
    if (childrenPlacementType == ChildrenPlacementType.Matrix && regularChildren.length < 3) {
      childrenPlacementType = ChildrenPlacementType.Horizontal;
    }
    switch (childrenPlacementType) {
      case ChildrenPlacementType.Horizontal:
        results.push(regularChildren);
        break;
      case ChildrenPlacementType.Matrix:
        var width = Math.min(options.maximumColumnsInMatrix, Math.ceil(Math.sqrt(regularChildren.length)));
        for (var index = 0; index < regularChildren.length; index += width) {
          results.push(regularChildren.slice(index, index + width));
        }
        break;
      case ChildrenPlacementType.Vertical:
        regularChildren.forEach((childItem) => {
          results.push([childItem]);
        });
        break;
    }
    return results;
  }
  function getMatrixItem(items, x, y, width) {
    var result, isOdd = width % 2 > 0, index;
    if (isOdd) {
      if (x === width - 1) {
        x = items.length;
      } else if (x === width) {
        x = width - 1;
      }
    }
    index = y * width + x;
    result = index > items.length - 1 ? null : items[index];
    return result;
  }
  function createNewVisualAggregator(visualTree, treeItem, hideChildrenConnector) {
    var newAggregatorItem, hideParentConnector = treeItem.visibility == Visibility.Invisible && (treeItem.connectorPlacement & SideFlag.Top) === 0 || hideChildrenConnector;
    newAggregatorItem = getNewTreeItem({
      visibility: Visibility.Invisible,
      visualAggregatorId: treeItem.visualAggregatorId,
      connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom
    });
    visualTree.insert(treeItem.id, newAggregatorItem.id, newAggregatorItem);
    treeItem.visualAggregatorId = newAggregatorItem.id;
    return newAggregatorItem;
  }
  function getNewTreeItem(properties, orgItem) {
    var result = new TreeItem(), optionKey;
    if (orgItem != null) {
      result.actualItemType = orgItem.itemType;
      result.adviserPlacementType = orgItem.adviserPlacementType;
    }
    for (optionKey in properties) {
      if (properties.hasOwnProperty(optionKey)) {
        result[optionKey] = properties[optionKey];
      }
    }
    if (orgItem != null) {
      result.id = orgItem.id;
      result.visibility = orgItem.isVisible ? Visibility.Auto : Visibility.Invisible;
    } else {
      _treeItemCounter += 1;
      result.id = _treeItemCounter;
    }
    return result;
  }
  return {
    build
  };
}

// node_modules/basicprimitives/src/tasks/transformations/VisualTreeTask.js
function VisualTreeTask(orgTreeTask, activeItemsTask, visualTreeOptionTask) {
  var _visualTree, _leftMargins, _rightMargins, _navigationFamily, _treeItemCounter, _branchAligner, _visualTreeBuilder = VisualTreeBuilder();
  function process() {
    var orgTree = orgTreeTask.getOrgTree();
    var options = visualTreeOptionTask.getOptions();
    var activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};
    _treeItemCounter = orgTreeTask.getMaximumId();
    if (orgTree.hasNodes()) {
      ({
        visualTree: _visualTree,
        navigationFamily: _navigationFamily,
        treeItemCounter: _treeItemCounter,
        branchAligner: _branchAligner
      } = _visualTreeBuilder.build(orgTree, _treeItemCounter, activeItems, options));
    } else {
      _visualTree = Tree();
      _navigationFamily = Family();
      _branchAligner = BranchAligner_default();
    }
    ({
      leftMargins: _leftMargins,
      rightMargins: _rightMargins
    } = getVisualTreeMargins(_visualTree));
    return true;
  }
  function getVisualTreeMargins(visualTree) {
    var leftMargins = {};
    var rightMargins = {};
    visualTree.loop(this, function(nodeid, node) {
      leftMargins[nodeid] = [];
      rightMargins[nodeid] = [];
    });
    visualTree.loopPostOrder(this, function(nodeid, node, parentid, parent) {
      var parentLeftMargins = leftMargins[parentid], parentRightMargins = rightMargins[parentid], nodeLeftMargins = leftMargins[nodeid], nodeRightMargins = rightMargins[nodeid], index, len;
      if (parentid != null) {
        if (!parentLeftMargins[0]) {
          parentLeftMargins[0] = nodeid;
        }
        for (index = 0, len = nodeLeftMargins.length; index < len; index += 1) {
          if (!parentLeftMargins[index + 1]) {
            parentLeftMargins[index + 1] = nodeLeftMargins[index];
          }
        }
        parentRightMargins[0] = nodeid;
        for (index = 0, len = nodeRightMargins.length; index < len; index += 1) {
          parentRightMargins[index + 1] = nodeRightMargins[index];
        }
      }
    });
    return {
      leftMargins,
      rightMargins
    };
  }
  function getVisualTree() {
    return _visualTree;
  }
  function getLogicalFamily() {
    return _navigationFamily;
  }
  function getBranchAligner() {
    return _branchAligner;
  }
  function getLeftMargins() {
    return _leftMargins;
  }
  function getRightMargins() {
    return _rightMargins;
  }
  function getMaximumId() {
    return _treeItemCounter;
  }
  return {
    process,
    getVisualTree,
    getLogicalFamily,
    getLeftMargins,
    getRightMargins,
    getMaximumId,
    getBranchAligner
  };
}

// node_modules/basicprimitives/src/models/TreeLevelConnectorStackSize.js
function TreeLevelConnectorStackSize() {
  this.parentsStackSize = 0;
}

// node_modules/basicprimitives/src/graphics/structs/PaletteItem.js
function PaletteItem(options) {
  this.lineColor = Colors.Silver;
  this.lineWidth = 1;
  this.lineType = LineType.Solid;
  this.fillColor = null;
  this.opacity = null;
  this._key = "";
  var property, properties, index, len;
  properties = ["lineColor", "lineWidth", "lineType", "fillColor", "opacity"];
  for (index = 0, len = properties.length; index < len; index += 1) {
    property = properties[index];
    if (options != null && options.hasOwnProperty(property)) {
      this[property] = options[property];
    }
    this._key += (!isNullOrEmpty(this._key) ? ", " : "") + property + ":" + this[property];
  }
}
PaletteItem.prototype.toAttr = function() {
  var attr = {
    "lineWidth": this.lineWidth,
    "lineType": this.lineType
  };
  if (this.fillColor !== null) {
    attr.fillColor = this.fillColor;
  }
  if (this.opacity !== null) {
    attr.opacity = this.opacity;
  }
  if (this.lineColor !== null) {
    attr.borderColor = this.lineColor;
  }
  return attr;
};
PaletteItem.prototype.toString = function() {
  return this._key;
};

// node_modules/basicprimitives/src/graphics/structs/MoveSegment.js
function MoveSegment() {
  this.parent = Point.prototype;
  this.parent.constructor.apply(this, arguments);
  this.segmentType = SegmentType.Move;
}
MoveSegment.prototype = new Point();
MoveSegment.prototype.clone = function() {
  return new MoveSegment(this);
};
MoveSegment.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    onItem.call(thisArg, this.x, this.y, 0);
  }
};
MoveSegment.prototype.setPoint = function(point, index) {
  this.x = point.x;
  this.y = point.y;
};
MoveSegment.prototype.getEndPoint = function() {
  return this;
};
MoveSegment.prototype.invert = function(endPoint) {
  this.x = endPoint.x;
  this.y = endPoint.y;
};
MoveSegment.prototype.transform = function(transform, forward) {
  var self = this;
  transform.transformPoint(self.x, self.y, forward, self, function(x, y) {
    self.x = x;
    self.y = y;
  });
};

// node_modules/basicprimitives/src/graphics/structs/LineSegment.js
function LineSegment() {
  this.parent = MoveSegment.prototype;
  this.parent.constructor.apply(this, arguments);
  this.segmentType = SegmentType.Line;
}
LineSegment.prototype = new MoveSegment();
LineSegment.prototype.clone = function() {
  return new LineSegment(this);
};
LineSegment.prototype.trim = function(prevEndPoint, offset) {
  var endPoint = this.offsetPoint(this, prevEndPoint, offset);
  this.x = endPoint.x;
  this.y = endPoint.y;
  return this;
};
LineSegment.prototype.offsetPoint = function(first, second, offset) {
  var result = null, distance = first.distanceTo(second);
  if (distance === 0 || offset === 0) {
    result = new Point(first);
  } else {
    result = new Point(first.x + (second.x - first.x) / distance * offset, first.y + (second.y - first.y) / distance * offset);
  }
  return result;
};

// node_modules/basicprimitives/src/graphics/structs/QuadraticArcSegment.js
function QuadraticArcSegment(arg0, arg1, arg2, arg3) {
  this.x = null;
  this.y = null;
  this.cpX = null;
  this.cpY = null;
  switch (arguments.length) {
    case 2:
      this.x = arg1.x;
      this.y = arg1.y;
      this.cpX = arg0.x;
      this.cpY = arg0.y;
      break;
    case 4:
      this.cpX = arg0;
      this.cpY = arg1;
      this.x = arg2;
      this.y = arg3;
      break;
    default:
      break;
  }
  this.segmentType = SegmentType.QuadraticArc;
}
QuadraticArcSegment.prototype.clone = function() {
  return new QuadraticArcSegment(this.cpX, this.cpY, this.x, this.y);
};
QuadraticArcSegment.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    onItem.call(thisArg, this.cpX, this.cpY, 0);
    onItem.call(thisArg, this.x, this.y, 1);
  }
};
QuadraticArcSegment.prototype.setPoint = function(point, index) {
  switch (index) {
    case 0:
      this.cpX = point.x;
      this.cpY = point.y;
      break;
    case 1:
      this.x = point.x;
      this.y = point.y;
      break;
  }
};
QuadraticArcSegment.prototype.getEndPoint = function() {
  return this;
};
QuadraticArcSegment.prototype.invert = function(endPoint) {
  this.x = endPoint.x;
  this.y = endPoint.y;
};
QuadraticArcSegment.prototype.transform = function(transform, forward) {
  var self = this;
  transform.transformPoints(self.x, self.y, self.cpX, self.cpY, forward, self, function(x, y, cpX, cpY) {
    self.x = x;
    self.y = y;
    self.cpX = cpX;
    self.cpY = cpY;
  });
};
QuadraticArcSegment.prototype.trim = function(prevEndPoint, offset) {
  var time = 0.5, endPoint = this.offsetPoint(this.x, this.y, this.cpX, this.cpY, prevEndPoint.x, prevEndPoint.y, time), time2 = 0.1, endPoint2 = this.offsetPoint(this.x, this.y, this.cpX, this.cpY, prevEndPoint.x, prevEndPoint.y, time2);
  time = offset * (time / endPoint.distanceTo(this.x, this.y) + time2 / endPoint2.distanceTo(this.x, this.y)) / 2;
  endPoint = this.offsetPoint(this.x, this.y, this.cpX, this.cpY, prevEndPoint.x, prevEndPoint.y, time);
  this.x = endPoint.x;
  this.y = endPoint.y;
  return this;
};
QuadraticArcSegment.prototype.offsetPoint = function(firstX, firstY, controlX, controlY, secondX, secondY, time) {
  return new Point(
    (1 - time) * (1 - time) * firstX + 2 * (1 - time) * time * controlX + time * time * secondX,
    (1 - time) * (1 - time) * firstY + 2 * (1 - time) * time * controlY + time * time * secondY
  );
};

// node_modules/basicprimitives/src/graphics/structs/Polyline.js
function Polyline(newPaletteItem) {
  var paletteItem = new PaletteItem(), segments = [], self, arrowPaletteItem;
  switch (arguments.length) {
    case 1:
      paletteItem = newPaletteItem;
      break;
  }
  arrowPaletteItem = new PaletteItem({
    lineColor: paletteItem.lineColor,
    lineWidth: 0,
    fillColor: paletteItem.lineColor,
    opacity: paletteItem.opacity || 1
  });
  function getStartPoint() {
    var result = null;
    if (segments.length > 0) {
      result = segments[0].getEndPoint();
    }
    return result;
  }
  function getEndPoint() {
    var result = null;
    if (segments.length > 0) {
      result = segments[segments.length - 1].getEndPoint();
    }
    return result;
  }
  function addSegment(segment) {
    segments.push(segment);
  }
  function addSegments(newSegments) {
    var index, len;
    for (index = 0, len = newSegments.length; index < len; index += 1) {
      segments.push(newSegments[index]);
    }
  }
  function mergeTo(polyline) {
    polyline.addSegments(segments);
  }
  function clone() {
    var index, len, result = new Polyline(paletteItem), cloneSegments = [], segment;
    for (index = 0, len = segments.length; index < len; index += 1) {
      segment = segments[index];
      cloneSegments.push(segment.clone());
    }
    result.addSegments(cloneSegments);
    return result;
  }
  function length() {
    return segments.length;
  }
  function loop2(thisArg, onItem) {
    var index, len, segment;
    if (onItem != null) {
      for (index = 0, len = segments.length; index < len; index += 1) {
        segment = segments[index];
        if (segment) {
          if (onItem.call(thisArg, segment, index)) {
            break;
          }
        }
      }
    }
  }
  function loopReversed(thisArg, onItem) {
    var index, segment;
    if (onItem != null) {
      for (index = segments.length - 1; index >= 0; index -= 1) {
        segment = segments[index];
        if (segment) {
          if (onItem.call(thisArg, segment, index)) {
            break;
          }
        }
      }
    }
  }
  function transform(transformArg, forward) {
    loop2(this, function(segment) {
      if (segment.transform != null) {
        segment.transform(transformArg, forward);
      }
    });
  }
  function isInvertable() {
    return isNullOrEmpty(paletteItem.fillColor);
  }
  function addInverted(polyline) {
    var hasMoved = false, stack = [];
    if (isInvertable()) {
      polyline.loopReversed(this, function(segment, index) {
        if (segment.segmentType != SegmentType.Dot) {
          if (!hasMoved) {
            segments.push(new MoveSegment(segment.getEndPoint()));
            hasMoved = true;
          }
          stack.unshift(segment);
          if (stack.length > 1) {
            stack[1].invert(stack[0].getEndPoint());
            segments.push(stack[1]);
            stack.length = 1;
          }
        }
      });
    } else {
      polyline.mergeTo(self);
    }
  }
  function _getArrow(fromX, fromY, toX, toY, length2, width) {
    var result = new Polyline(arrowPaletteItem), index, len, point, x, y, perimeter = [
      new Point(length2, -width / 2),
      new Point(0, 0),
      new Point(length2, width / 2),
      new Point(length2 / 4 * 3, 0)
    ], angle = Math.atan2(fromY - toY, fromX - toX);
    for (index = 0, len = perimeter.length; index < len; index += 1) {
      point = perimeter[index];
      x = point.x * Math.cos(angle) - point.y * Math.sin(angle);
      y = point.x * Math.sin(angle) + point.y * Math.cos(angle);
      point.x = x + toX;
      point.y = y + toY;
    }
    result.addSegment(new MoveSegment(perimeter[0].x, perimeter[0].y));
    result.addSegment(new LineSegment(perimeter[1].x, perimeter[1].y));
    result.addSegment(new LineSegment(perimeter[2].x, perimeter[2].y));
    result.addSegment(new QuadraticArcSegment(perimeter[3].x, perimeter[3].y, perimeter[0].x, perimeter[0].y));
    return result;
  }
  function addOffsetArrow(forward, lineWidth, offsetPercent, minimumDistance, onAddArrowSegments) {
    var prevEndPoint, currentEndPoint, currentSegment, newEndPoint, newPrevEndPoint, polyline, len = segments.length, arrowTipLength = lineWidth * 3, arrowTipWidth = lineWidth * 2, offset, distance;
    switch (lineWidth) {
      case 1:
        arrowTipLength = 8;
        arrowTipWidth = 6;
        break;
      case 2:
        arrowTipLength = 12;
        arrowTipWidth = 8;
        break;
      case 3:
        arrowTipLength = 16;
        arrowTipWidth = 10;
        break;
    }
    if (onAddArrowSegments != null && len > 1) {
      prevEndPoint = segments[len - 2].getEndPoint();
      currentSegment = segments[len - 1];
      if (currentSegment.offsetPoint != null) {
        currentEndPoint = new Point(currentSegment.getEndPoint());
        distance = prevEndPoint.distanceTo(currentEndPoint);
        if (distance > minimumDistance) {
          offset = distance * offsetPercent;
          if (forward) {
            newEndPoint = currentSegment.offsetPoint(prevEndPoint, currentEndPoint, offset);
            polyline = _getArrow(prevEndPoint.x, prevEndPoint.y, newEndPoint.x, newEndPoint.y, arrowTipLength, arrowTipWidth);
          } else {
            newPrevEndPoint = currentSegment.offsetPoint(currentEndPoint, prevEndPoint, offset);
            polyline = _getArrow(currentEndPoint.x, currentEndPoint.y, newPrevEndPoint.x, newPrevEndPoint.y, arrowTipLength, arrowTipWidth);
          }
          onAddArrowSegments(polyline);
        }
      }
    }
  }
  function addArrow(lineWidth, onAddArrowSegments) {
    var prevEndPoint, currentEndPoint, currentSegment, newEndPoint, polyline, len = segments.length, arrowTipLength = lineWidth * 3, arrowTipWidth = lineWidth * 2;
    switch (lineWidth) {
      case 1:
        arrowTipLength = 8;
        arrowTipWidth = 6;
        break;
      case 2:
        arrowTipLength = 12;
        arrowTipWidth = 8;
        break;
      case 3:
        arrowTipLength = 16;
        arrowTipWidth = 10;
        break;
    }
    if (onAddArrowSegments != null && len > 1) {
      prevEndPoint = segments[len - 2].getEndPoint();
      currentSegment = segments[len - 1];
      if (currentSegment.trim != null) {
        currentEndPoint = new Point(currentSegment.getEndPoint());
        if (currentEndPoint.distanceTo(prevEndPoint) >= arrowTipLength) {
          newEndPoint = currentSegment.trim(prevEndPoint, arrowTipLength);
          polyline = _getArrow(newEndPoint.x, newEndPoint.y, currentEndPoint.x, currentEndPoint.y, arrowTipLength, arrowTipWidth);
          onAddArrowSegments(polyline, newEndPoint);
        }
      }
    }
  }
  function optimizeMoveSegments() {
    var index, len, cursorIndex, key, optimizedSegments, segment, nextSegment, links = {}, jumps = [], processed = [];
    for (index = 0, len = segments.length; index < len - 1; index += 1) {
      segment = segments[index];
      nextSegment = segments[index + 1];
      switch (segment.segmentType) {
        case SegmentType.Line:
        case SegmentType.QuadraticArc:
        case SegmentType.CubicArc:
          switch (nextSegment.segmentType) {
            case SegmentType.Move:
            case SegmentType.Dot:
              key = segment.x + "&" + segment.y;
              if (!links.hasOwnProperty(key)) {
                links[key] = index;
              }
              break;
            default:
              break;
          }
          break;
        case SegmentType.Move:
          key = segment.x + "&" + segment.y;
          if (links.hasOwnProperty(key) && !jumps[links[key]]) {
            jumps[links[key]] = index + 1;
            processed[index] = true;
          }
          break;
        default:
          break;
      }
    }
    optimizedSegments = [];
    for (index = 0; index < len; index += 1) {
      if (!processed[index]) {
        segment = segments[index];
        optimizedSegments.push(segment);
        processed[index] = true;
        if (jumps[index] > 0) {
          cursorIndex = jumps[index];
          while (cursorIndex < len && !processed[cursorIndex]) {
            segment = segments[cursorIndex];
            optimizedSegments.push(segment);
            processed[cursorIndex] = true;
            if (jumps[cursorIndex] > 0) {
              cursorIndex = jumps[cursorIndex];
            } else {
              cursorIndex += 1;
            }
          }
        }
      }
    }
    segments = optimizedSegments;
  }
  function toString() {
    return paletteItem.toString();
  }
  function Vertex(segment, pointIndex) {
    this.segment = segment;
    this.pointIndex = pointIndex;
  }
  Vertex.prototype.pushToSegment = function(point) {
    this.segment.setPoint(point, this.pointIndex);
  };
  function _joinVectors(prev, current, offset, polyline, isLoop) {
    var relationType = prev.relateTo(current), offset2 = isLoop ? 0 : offset, joinSegment, joinVector, newToPoint;
    if (relationType == VectorRelationType.Collinear) {
      current.offset(offset2);
    } else {
      if (relationType == VectorRelationType.Opposite && current.from.context.pointIndex === 0) {
        joinSegment = new LineSegment(current.from);
        polyline.addSegment(joinSegment);
        current.offset(offset2);
        newToPoint = current.from.clone();
        newToPoint.context = new Vertex(joinSegment, 0);
        joinVector = new Vector(prev.to.clone(), newToPoint);
        if (!isLoop) {
          current.from = newToPoint.clone();
        }
        joinVector.offset(offset);
        joinVector.intersect(prev);
        joinVector.from.context.pushToSegment(joinVector.from);
        current.intersect(joinVector);
        if (isLoop) {
          joinVector.to.context.pushToSegment(joinVector.to);
        }
      } else {
        current.offset(offset2);
        current.intersect(prev);
      }
    }
    current.from.context.pushToSegment(current.from);
  }
  function _closeVector(vectorStack, startVectors, offset, polyline) {
    var startVector, prevVector = vectorStack[0], closurePoint = prevVector.to.context.segment.getEndPoint().toString();
    if (startVectors.hasOwnProperty(closurePoint)) {
      startVector = startVectors[closurePoint];
      _joinVectors(prevVector, startVector, offset, polyline, true);
      delete startVectors[closurePoint];
    }
    prevVector.to.context.pushToSegment(prevVector.to);
    vectorStack.length = 0;
  }
  function getOffsetPolyine(offset) {
    var result = new Polyline(paletteItem), startVectors = {}, pointStack = [], vectorStack = [];
    loop2(this, function(segment) {
      var newSegment = segment.clone(), newPoint;
      switch (newSegment.segmentType) {
        case SegmentType.Dot:
        case SegmentType.Move:
          if (vectorStack.length > 0) {
            _closeVector(vectorStack, startVectors, offset, result);
          }
          pointStack.length = 0;
          if (newSegment.segmentType == SegmentType.Move) {
            newPoint = new Point(newSegment);
            newPoint.context = new Vertex(newSegment, 0);
            pointStack.push(newPoint);
          }
          break;
        default:
          newSegment.loop(this, function(x, y, index) {
            var newPoint2 = new Point(x, y), current, prev, closurePoint;
            newPoint2.context = new Vertex(newSegment, index);
            pointStack.unshift(newPoint2);
            if (pointStack.length > 1) {
              vectorStack.unshift(new Vector(pointStack[1].clone(), pointStack[0].clone()));
              pointStack.length = 1;
            }
            switch (vectorStack.length) {
              case 1:
                current = vectorStack[0];
                closurePoint = current.from.toString();
                startVectors[closurePoint] = current;
                current.offset(offset);
                current.from.context.pushToSegment(current.from);
                break;
              case 2:
                prev = vectorStack[1];
                current = vectorStack[0];
                _joinVectors(prev, current, offset, result, false);
                vectorStack.length = 1;
                break;
              default:
                break;
            }
          });
          break;
      }
      result.addSegment(newSegment);
    });
    if (vectorStack.length > 0) {
      _closeVector(vectorStack, startVectors, offset, result);
    }
    return result;
  }
  self = {
    paletteItem,
    arrowPaletteItem,
    addSegment,
    addSegments,
    mergeTo,
    length,
    loop: loop2,
    loopReversed,
    transform,
    isInvertable,
    addInverted,
    addArrow,
    addOffsetArrow,
    optimizeMoveSegments,
    getOffsetPolyine,
    toString,
    getStartPoint,
    getEndPoint,
    clone
  };
  return self;
}

// node_modules/basicprimitives/src/graphics/structs/CubicArcSegment.js
function CubicArcSegment(arg0, arg1, arg2, arg3, arg4, arg5) {
  this.parent = Point.prototype;
  this.x = null;
  this.y = null;
  this.cpX1 = null;
  this.cpY1 = null;
  this.cpX2 = null;
  this.cpY2 = null;
  switch (arguments.length) {
    case 3:
      this.parent.constructor.apply(this, [arg2.x, arg2.y]);
      this.cpX1 = arg0.x;
      this.cpY1 = arg0.y;
      this.cpX2 = arg1.x;
      this.cpY2 = arg1.y;
      break;
    case 6:
      this.parent.constructor.apply(this, [arg4, arg5]);
      this.cpX1 = arg0;
      this.cpY1 = arg1;
      this.cpX2 = arg2;
      this.cpY2 = arg3;
      break;
    default:
      break;
  }
  this.segmentType = SegmentType.CubicArc;
}
CubicArcSegment.prototype = new Point();
CubicArcSegment.prototype.clone = function() {
  return new CubicArcSegment(this.cpX1, this.cpY1, this.cpX2, this.cpY2, this.x, this.y);
};
CubicArcSegment.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    onItem.call(thisArg, this.cpX1, this.cpY1, 0);
    onItem.call(thisArg, this.cpX2, this.cpY2, 1);
    onItem.call(thisArg, this.x, this.y, 2);
  }
};
CubicArcSegment.prototype.setPoint = function(point, index) {
  switch (index) {
    case 0:
      this.cpX1 = point.x;
      this.cpY1 = point.y;
      break;
    case 1:
      this.cpX2 = point.x;
      this.cpY2 = point.y;
      break;
    case 2:
      this.x = point.x;
      this.y = point.y;
      break;
  }
};
CubicArcSegment.prototype.getEndPoint = function() {
  return this;
};
CubicArcSegment.prototype.invert = function(endPoint) {
  var tempX = this.cpX1, tempY = this.cpY1;
  this.x = endPoint.x;
  this.y = endPoint.y;
  this.cpX1 = this.cpX2;
  this.cpY1 = this.cpY2;
  this.cpX2 = tempX;
  this.cpY2 = tempY;
};
CubicArcSegment.prototype.transform = function(transform, forward) {
  var self = this;
  transform.transform3Points(self.x, self.y, self.cpX1, self.cpY1, self.cpX2, self.cpY2, forward, self, function(x, y, cpX1, cpY1, cpX2, cpY2) {
    self.x = x;
    self.y = y;
    self.cpX1 = cpX1;
    self.cpY1 = cpY1;
    self.cpX2 = cpX2;
    self.cpY2 = cpY2;
  });
};
CubicArcSegment.prototype.trim = function(prevEndPoint, offset) {
  var time = 0.5, endPoint = this.offsetPoint(this.x, this.y, this.cpX2, this.cpY2, this.cpX1, this.cpY1, prevEndPoint.x, prevEndPoint.y, time), time2 = 0.1, endPoint2 = this.offsetPoint(this.x, this.y, this.cpX2, this.cpY2, this.cpX1, this.cpY1, prevEndPoint.x, prevEndPoint.y, time2);
  time = offset * (time / endPoint.distanceTo(this.x, this.y) + time2 / endPoint2.distanceTo(this.x, this.y)) / 2;
  endPoint = this.offsetPoint(this.x, this.y, this.cpX2, this.cpY2, this.cpX1, this.cpY1, prevEndPoint.x, prevEndPoint.y, time);
  this.x = endPoint.x;
  this.y = endPoint.y;
  return this;
};
CubicArcSegment.prototype.offsetPoint = function(x, y, cpX1, cpY1, cpX2, cpY2, x2, y2, time) {
  return new Point(
    (1 - time) * (1 - time) * (1 - time) * x + 3 * (1 - time) * (1 - time) * time * cpX1 + 3 * (1 - time) * time * time * cpX2 + time * time * time * x2,
    (1 - time) * (1 - time) * (1 - time) * y + 3 * (1 - time) * (1 - time) * time * cpY1 + 3 * (1 - time) * time * time * cpY2 + time * time * time * y2
  );
};

// node_modules/basicprimitives/src/connectors/BaseConnectorBundle.js
function BaseConnectorBundle() {
  this.NORMAL_ITEM_WEIGHT = 10010;
  this.LINE_ITEM_WEIGHT = 1e4;
}
BaseConnectorBundle.prototype.trace = function(data, params, options) {
};
BaseConnectorBundle.prototype.getId = function(data) {
  var result = "_" + data.nodeid;
  data.nodeid += 1;
  return result;
};
BaseConnectorBundle.prototype.ConnectorEdge = function(from, to, polyline, parentsArrowId, childrenArrowId, dotId, weight, fromOffset, hasMiddle, middleParent, hasArrow) {
  this.polyline = polyline;
  this.from = from;
  this.to = to;
  this.weight = weight || 0;
  this.fromOffset = fromOffset || 0;
  this.hasArrow = hasArrow || false;
  this.parentsArrowId = parentsArrowId;
  this.childrenArrowId = childrenArrowId;
  this.dotId = dotId;
  this.hasMiddle = hasMiddle;
  this.middleParent = middleParent;
  this.isOppositeFlow = false;
};
BaseConnectorBundle.prototype.ConnectorDestination = function(options) {
  this.id = null;
  this.x = null;
  this.y = null;
  this.bundleid = null;
  this.hasElbow = false;
  this.elbowPoint1 = null;
  this.elbowPoint2 = null;
  this.visibility = null;
  this.isSquared = true;
  for (var key in options) {
    if (options.hasOwnProperty(key)) {
      this[key] = options[key];
    }
  }
};
BaseConnectorBundle.prototype.traceFork = function(data, params, options, parentPoint, points, hasSquared, isParents, fromOffset, showHorizontalArrows) {
  var startIndex, endIndex, len, connectorPoint, curvedPoints = [], bundlePoint, connectorDestination, index, polyline, bevelSize, fromPoint, fromPointId, toPoint, toPointId;
  if (hasSquared) {
    curvedPoints = [];
    for (startIndex = 0, len = points.length; startIndex < len; startIndex += 1) {
      connectorPoint = points[startIndex];
      if (connectorPoint.x < parentPoint.x && !connectorPoint.isSquared) {
        curvedPoints.push(connectorPoint);
      } else {
        break;
      }
    }
    len = curvedPoints.length;
    if (len > 0) {
      connectorDestination = curvedPoints[len - 1];
      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({
        id: connectorDestination.bundleid,
        x: connectorDestination.x,
        y: parentPoint.y
      });
      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);
    }
    curvedPoints = [];
    for (endIndex = points.length - 1; endIndex >= startIndex; endIndex -= 1) {
      connectorPoint = points[endIndex];
      if (connectorPoint.x > parentPoint.x && !connectorPoint.isSquared) {
        curvedPoints.push(connectorPoint);
      } else {
        break;
      }
    }
    len = curvedPoints.length;
    if (len > 0) {
      connectorDestination = curvedPoints[len - 1];
      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({
        id: connectorDestination.bundleid,
        x: connectorDestination.x,
        y: parentPoint.y
      });
      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);
    }
    for (index = startIndex; index <= endIndex; index += 1) {
      connectorPoint = points[index];
      bevelSize = options.bevelSize;
      if (bevelSize < 2) {
        bevelSize = 0;
      }
      switch (options.elbowType) {
        case ElbowType.Bevel:
        case ElbowType.Round:
          if (bevelSize > 0 && Math.abs(parentPoint.x - connectorPoint.x) > bevelSize && Math.abs(parentPoint.y - connectorPoint.y) > bevelSize) {
            connectorPoint.hasElbow = true;
            connectorPoint.elbowPoint1 = new Point(connectorPoint.x, parentPoint.y + (parentPoint.y > connectorPoint.y ? -bevelSize : bevelSize));
            connectorPoint.elbowPoint2 = new Point(connectorPoint.x + (parentPoint.x > connectorPoint.x ? bevelSize : -bevelSize), parentPoint.y);
          }
          break;
        default:
          break;
      }
      polyline = new Polyline();
      if (connectorPoint.hasElbow) {
        params.transform.transform3Points(
          connectorPoint.elbowPoint2.x,
          connectorPoint.elbowPoint2.y,
          connectorPoint.elbowPoint1.x,
          connectorPoint.elbowPoint2.y,
          connectorPoint.elbowPoint1.x,
          connectorPoint.elbowPoint1.y,
          true,
          this,
          function(fromX, fromY, toX, toY, toX2, toY2) {
            switch (options.elbowType) {
              case ElbowType.Bevel:
                polyline.addSegment(new MoveSegment(fromX, fromY));
                polyline.addSegment(new LineSegment(toX2, toY2));
                break;
              case ElbowType.Round:
                polyline.addSegment(new MoveSegment(fromX, fromY));
                polyline.addSegment(new CubicArcSegment(fromX, fromY, toX, toY, toX2, toY2));
                break;
            }
          }
        );
        params.transform.transformPoints(connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, connectorPoint.x, connectorPoint.y, true, this, function(fromX, fromY, toX, toY) {
          polyline.addSegment(new LineSegment(toX, toY));
        });
      } else {
        params.transform.transformPoints(connectorPoint.x, parentPoint.y, connectorPoint.x, connectorPoint.y, true, this, function(fromX, fromY, toX, toY) {
          polyline.addSegment(new MoveSegment(fromX, fromY));
          polyline.addSegment(new LineSegment(toX, toY));
        });
      }
      var bundleid = connectorPoint.x == parentPoint.x ? parentPoint.id : connectorPoint.bundleid;
      var isVisible = connectorPoint.visibility !== Visibility.Invisible;
      data.graph.addEdge(bundleid, connectorPoint.id, new this.ConnectorEdge(
        bundleid,
        connectorPoint.id,
        polyline,
        isParents ? connectorPoint.id : null,
        !isParents ? connectorPoint.id : null,
        null,
        isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT,
        fromOffset,
        null,
        null,
        isVisible
      ));
    }
    startIndex = Math.max(startIndex - 1, 0);
    endIndex = Math.min(endIndex + 1, points.length - 1);
    fromPoint = parentPoint;
    fromPointId = parentPoint.id;
    for (index = startIndex; index <= endIndex; index += 1) {
      toPoint = points[index];
      toPointId = toPoint.bundleid;
      if (toPoint.x > fromPoint.x) {
        polyline = new Polyline();
        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function(startX, startY, endX, endY) {
          polyline.addSegment(new MoveSegment(startX, startY));
          polyline.addSegment(new LineSegment(endX, endY));
        });
        data.graph.addEdge(
          fromPointId,
          toPointId,
          new this.ConnectorEdge(
            fromPointId,
            toPointId,
            polyline,
            null,
            null,
            fromPointId,
            Math.abs(toPoint.x - fromPoint.x) / 1e4,
            fromOffset,
            /* draw middle arrows */
            showHorizontalArrows,
            isParents ? toPointId : fromPointId
          )
        );
        fromPoint = toPoint.elbowPoint2 || toPoint;
        fromPointId = toPointId;
      }
    }
    fromPoint = parentPoint;
    fromPointId = parentPoint.id;
    for (index = endIndex; index >= startIndex; index -= 1) {
      toPoint = points[index];
      toPointId = toPoint.bundleid;
      if (toPoint.x < fromPoint.x) {
        polyline = new Polyline();
        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function(startX, startY, endX, endY) {
          polyline.addSegment(new MoveSegment(startX, startY));
          polyline.addSegment(new LineSegment(endX, endY));
        });
        data.graph.addEdge(
          fromPointId,
          toPointId,
          new this.ConnectorEdge(
            fromPointId,
            toPointId,
            polyline,
            null,
            null,
            fromPointId,
            Math.abs(toPoint.x - fromPoint.x) / 1e4,
            fromOffset,
            /* draw middle arrows */
            showHorizontalArrows,
            isParents ? toPointId : fromPointId
          )
        );
        fromPoint = toPoint.elbowPoint2 || toPoint;
        fromPointId = toPointId;
      }
    }
  } else {
    this.traceAngularSegments(data, params, options, parentPoint, points, true);
  }
};
BaseConnectorBundle.prototype.traceAngularSegments = function(data, params, options, bundlePoint, points, drawToBundle) {
  var index, len, rect, point, polyline;
  for (index = 0, len = points.length; index < len; index += 1) {
    point = points[index];
    polyline = new Polyline();
    params.transform.transformPoint(bundlePoint.x, bundlePoint.y, true, this, function(x, y) {
      polyline.addSegment(new MoveSegment(x, y));
    });
    switch (options.connectorType) {
      case ConnectorType.Angular:
        params.transform.transformPoint(point.x, point.y, true, this, function(x, y) {
          polyline.addSegment(new LineSegment(x, y));
        });
        break;
      case ConnectorType.Curved:
        rect = new Rect(bundlePoint, point);
        if (drawToBundle) {
          if (bundlePoint.x > rect.x) {
            params.transform.transform3Points(
              rect.right(),
              rect.verticalCenter(),
              rect.x,
              rect.verticalCenter(),
              rect.x,
              rect.bottom(),
              true,
              this,
              function(cpX1, cpY1, cpX2, cpY2, x, y) {
                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));
              }
            );
          } else {
            params.transform.transform3Points(
              rect.x,
              rect.verticalCenter(),
              rect.right(),
              rect.verticalCenter(),
              rect.right(),
              rect.bottom(),
              true,
              this,
              function(cpX1, cpY1, cpX2, cpY2, x, y) {
                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));
              }
            );
          }
        } else {
          if (bundlePoint.x > rect.x) {
            params.transform.transformPoints(
              rect.x,
              rect.y,
              rect.x,
              rect.bottom(),
              true,
              this,
              function(cpX, cpY, x, y) {
                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));
              }
            );
          } else {
            params.transform.transformPoints(
              rect.right(),
              rect.y,
              rect.right(),
              rect.bottom(),
              true,
              this,
              function(cpX, cpY, x, y) {
                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));
              }
            );
          }
        }
        break;
    }
    var isVisible = point.visibility !== Visibility.Invisible;
    data.graph.addEdge(bundlePoint.id, point.id, new this.ConnectorEdge(
      bundlePoint.id,
      point.id,
      polyline,
      null,
      isVisible ? point.id : null,
      isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT,
      null,
      null,
      null,
      true
    ));
  }
};

// node_modules/basicprimitives/src/connectors/VerticalConnectorBundle.js
function VerticalConnectorBundle(fromItems, toItems, dotId) {
  this.fromItems = fromItems;
  this.toItems = toItems;
  this.dotId = dotId || null;
  this.fromOffset = 0;
  this.fromStackSize = 0;
}
VerticalConnectorBundle.prototype = new BaseConnectorBundle();
VerticalConnectorBundle.prototype.trace = function(data, params, options) {
  var parents, children, items, treeItemId, treeItemPosition, index, len, isSquared, hasSquared, parentHorizontalCenter, parentsConnectorOffset, childrenConnectorOffset, connectorPoint, connectorStep, chartHasSquaredConnectors = options.connectorType === ConnectorType.Squared;
  parents = [];
  if (this.fromItems.length > 0) {
    items = this.fromItems;
    for (index = 0, len = items.length; index < len; index += 1) {
      treeItemId = items[index];
      treeItemPosition = params.treeItemsPositions[treeItemId];
      connectorPoint = new this.ConnectorDestination({
        id: params.nestedLayoutBottomConnectorIds.hasOwnProperty(treeItemId) ? params.nestedLayoutBottomConnectorIds[treeItemId] : treeItemId,
        bundleid: this.getId(data),
        x: treeItemPosition.actualPosition.horizontalCenter(),
        y: treeItemPosition.actualPosition.bottom(),
        isSquared: true,
        visibility: treeItemPosition.actualVisibility
      });
      parents.push(connectorPoint);
    }
    parents.sort(function(a, b) {
      return a.x - b.x;
    });
    parentsConnectorOffset = treeItemPosition.bottomConnectorShift - treeItemPosition.bottomConnectorInterval * (this.fromStackSize - this.fromOffset + 1);
  }
  children = [];
  if (this.toItems.length > 0) {
    hasSquared = false;
    items = this.toItems;
    for (index = 0; index < items.length; index += 1) {
      treeItemId = items[index];
      treeItemPosition = params.treeItemsPositions[treeItemId];
      isSquared = true;
      switch (treeItemPosition.actualVisibility) {
        case Visibility.Dot:
        case Visibility.Line:
          isSquared = chartHasSquaredConnectors;
          break;
      }
      connectorStep = 0;
      connectorPoint = new this.ConnectorDestination({
        id: treeItemId,
        bundleid: this.getId(data),
        x: treeItemPosition.actualPosition.horizontalCenter() + connectorStep,
        y: treeItemPosition.actualPosition.top(),
        isSquared,
        visibility: treeItemPosition.actualVisibility
      });
      children.push(connectorPoint);
      hasSquared = hasSquared || connectorPoint.isSquared;
    }
    children.sort(function(a, b) {
      return a.x - b.x;
    });
    childrenConnectorOffset = treeItemPosition.topConnectorShift;
  }
  if (children.length == 1) {
    parentHorizontalCenter = children[0].x;
  } else if (parents.length == 1) {
    parentHorizontalCenter = parents[0].x;
  } else if (children.length > 0 && parents.length > 0) {
    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x + children[0].x + children[children.length - 1].x) / 4;
  } else if (children.length > 0) {
    parentHorizontalCenter = (children[0].x + children[children.length - 1].x) / 2;
  } else {
    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x) / 2;
  }
  var topCenterPoint = null;
  if (parents.length > 0) {
    topCenterPoint = new this.ConnectorDestination({
      id: children.length == 0 && this.dotId ? this.dotId : this.getId(data),
      x: parentHorizontalCenter,
      y: parentsConnectorOffset
    });
    this.traceFork(data, params, options, topCenterPoint, parents, true, true, this.fromOffset, options.showExtraArrows);
  }
  var bottomCenterPoint = null;
  if (children.length > 0) {
    bottomCenterPoint = new this.ConnectorDestination({
      id: parents.length == 0 && this.dotId ? this.dotId : this.getId(data),
      x: parentHorizontalCenter,
      y: childrenConnectorOffset
    });
    if (topCenterPoint != null && bottomCenterPoint.y == topCenterPoint.y) {
      bottomCenterPoint = topCenterPoint;
    }
    this.traceFork(data, params, options, bottomCenterPoint, children, hasSquared, false, 0, options.showExtraArrows);
  }
  if (topCenterPoint != null && bottomCenterPoint != null && topCenterPoint.id != bottomCenterPoint.id) {
    params.transform.transformPoints(
      topCenterPoint.x,
      topCenterPoint.y,
      bottomCenterPoint.x,
      bottomCenterPoint.y,
      true,
      this,
      function(fromX, fromY, toX, toY) {
        var polyline = new Polyline();
        polyline.addSegment(new MoveSegment(fromX, fromY));
        polyline.addSegment(new LineSegment(toX, toY));
        data.graph.addEdge(topCenterPoint.id, bottomCenterPoint.id, new this.ConnectorEdge(
          topCenterPoint.id,
          bottomCenterPoint.id,
          polyline,
          null,
          null,
          null,
          0
          /* weight */
        ));
      }
    );
  }
};

// node_modules/basicprimitives/src/connectors/HorizontalConnectorBundle.js
function HorizontalConnectorBundle(fromItem, toItem) {
  this.fromItem = fromItem;
  this.toItem = toItem;
}
HorizontalConnectorBundle.prototype = new BaseConnectorBundle();
HorizontalConnectorBundle.prototype.trace = function(data, params, options) {
  var fromItemId = this.fromItem, toItemId = this.toItem, fromItemPosition = params.treeItemsPositions[fromItemId], toItemPosition = params.treeItemsPositions[toItemId], polyline = new Polyline();
  if (fromItemPosition.actualPosition.x < toItemPosition.actualPosition.x) {
    params.transform.transformPoints(
      fromItemPosition.actualPosition.right(),
      fromItemPosition.horizontalConnectorsShift,
      toItemPosition.actualPosition.x,
      toItemPosition.horizontalConnectorsShift,
      true,
      this,
      function(fromX, fromY, toX, toY) {
        polyline.addSegment(new MoveSegment(fromX, fromY));
        polyline.addSegment(new LineSegment(toX, toY));
      }
    );
  } else {
    params.transform.transformPoints(
      fromItemPosition.actualPosition.x,
      fromItemPosition.horizontalConnectorsShift,
      toItemPosition.actualPosition.right(),
      fromItemPosition.horizontalConnectorsShift,
      true,
      this,
      function(fromX, fromY, toX, toY) {
        polyline.addSegment(new MoveSegment(fromX, fromY));
        polyline.addSegment(new LineSegment(toX, toY));
      }
    );
  }
  var toItemIsVisible = toItemPosition.actualVisibility !== Visibility.Invisible;
  var fromItemIsVisible = fromItemPosition.actualVisibility !== Visibility.Invisible;
  data.graph.addEdge(
    fromItemId,
    toItemId,
    new this.ConnectorEdge(
      fromItemId,
      toItemId,
      polyline,
      toItemIsVisible ? toItemId : null,
      fromItemIsVisible ? fromItemId : null,
      null,
      toItemIsVisible || fromItemIsVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT,
      null,
      null,
      null,
      true
    )
  );
};

// node_modules/basicprimitives/src/tasks/transformations/VisualTreeLevelsTask.js
function VisualTreeLevelsTask(visualTreeTask, itemTemplateParamsTask) {
  var _data = {
    treeLevels: null,
    /* TreeLevels */
    bundles: null,
    /* array of BaseConnectorBundle objects */
    connectorStacks: null
    /* array of TreeLevelConnectorStackSize objects, 
    it keeps total number of horizontal connectors lines between parents and children stack on top of each other */
  }, _nullTreeLevelConnectorStackSize = new TreeLevelConnectorStackSize();
  function process() {
    var visualTree = visualTreeTask.getVisualTree();
    _data.treeLevels = TreeLevels();
    visualTree.loopLevels(this, function(treeItemId, treeItem, levelIndex) {
      _data.treeLevels.addItem(levelIndex, treeItemId, treeItem);
    });
    _data.bundles = [];
    _data.connectorStacks = [];
    recalcLevelsDepth(_data.bundles, _data.connectorStacks, _data.treeLevels, visualTree);
    return true;
  }
  function recalcLevelsDepth(bundles, connectorStacks, treeLevels, orgTree, orgPartners) {
    var index, len, index2, len2, index3, len3, treeItem, itemPosition, bundle, bundlesToStack, bundlesByItemId = {}, startIndex, endIndex, stackSegments;
    treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
      var stacksSizes = new TreeLevelConnectorStackSize();
      connectorStacks[levelIndex] = stacksSizes;
      bundlesToStack = [];
      treeLevels.loopLevelItems(this, levelIndex, function(itemid, treeItem2, position) {
        var parents = [];
        if (!bundlesByItemId.hasOwnProperty(itemid)) {
          if (treeItem2.connectorPlacement & SideFlag.Bottom) {
            parents.push(itemid);
          }
          parents = parents.concat(treeItem2.partners);
          if (parents.length > 0) {
            bundle = new VerticalConnectorBundle(parents, []);
            for (var index4 = 0, len4 = parents.length; index4 < len4; index4 += 1) {
              bundlesByItemId[parents[index4]] = bundle;
            }
            orgTree.loopChildren(this, itemid, function(childid, child, index5) {
              if (child.connectorPlacement & SideFlag.Top) {
                bundle.toItems.push(childid);
              }
            });
            if (parents.length > 1) {
              bundlesToStack.push(bundle);
            }
            if (bundle.fromItems.length > 1 || bundle.toItems.length > 0) {
              bundles.push(bundle);
            }
          }
        }
        if (treeItem2.connectorPlacement & SideFlag.Left) {
          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getPrevItem(itemid));
          bundles.push(bundle);
        }
        if (treeItem2.connectorPlacement & SideFlag.Right) {
          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getNextItem(itemid));
          bundles.push(bundle);
        }
      });
      if (bundlesToStack.length > 0) {
        stackSegments = Pile();
        for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {
          bundle = bundlesToStack[index2];
          startIndex = null;
          endIndex = null;
          for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {
            itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);
            startIndex = startIndex != null ? Math.min(startIndex, itemPosition) : itemPosition;
            endIndex = endIndex != null ? Math.max(endIndex, itemPosition) : itemPosition;
          }
          stackSegments.add(startIndex, endIndex, bundle);
        }
        stacksSizes.parentsStackSize = stackSegments.resolve(this, function(from, to, bundle2, offset, stackSize) {
          bundle2.fromOffset = offset + 1;
          bundle2.fromStackSize = stackSize;
        });
      }
    });
  }
  function getTreeLevels() {
    return _data.treeLevels;
  }
  function getBundles() {
    return _data.bundles;
  }
  function getNestedLayoutParentConnectorIds() {
    return {};
  }
  function getNestedLayoutBottomConnectorIds() {
    return {};
  }
  function getConnectorsStacksSizes(levelid) {
    return _data.connectorStacks[levelid] || _nullTreeLevelConnectorStackSize;
  }
  return {
    process,
    getTreeLevels,
    getBundles,
    getConnectorsStacksSizes,
    getNestedLayoutParentConnectorIds,
    getNestedLayoutBottomConnectorIds
  };
}

// node_modules/basicprimitives/src/tasks/transformations/OrgExtractNestedLayoutsTask.js
function OrgExtractNestedLayoutsTask(extractNestedLayoutsOptionTask, bindFamilyConnectorsTask) {
  function process(debug) {
    return false;
  }
  function getNestedLayoutParentConnectorIds() {
    return {};
  }
  function getNestedLayoutBottomConnectorIds() {
    return {};
  }
  function getBundles() {
    return [];
  }
  function getLayouts() {
    return {};
  }
  return {
    process,
    getNestedLayoutParentConnectorIds,
    getNestedLayoutBottomConnectorIds,
    getBundles,
    getLayouts
  };
}

// node_modules/basicprimitives/src/models/TreeLevelPosition.js
function TreeLevelPosition(source) {
  this.currentvisibility = Visibility.Normal;
  this.actualVisibility = Visibility.Normal;
  this.shift = 0;
  this.depth = 0;
  this.nextLevelShift = 0;
  this.horizontalConnectorsDepth = 0;
  this.topConnectorShift = 0;
  this.connectorShift = 0;
  this.levelSpace = 0;
  this.currentOffset = 0;
  this.labels = [];
  this.labelsRect = null;
  this.showLabels = true;
  this.hasFixedLabels = false;
  if (source != null) {
    for (var property in source) {
      if (source.hasOwnProperty(property)) {
        this[property] = source[property];
      }
    }
  }
}
TreeLevelPosition.prototype.setShift = function(shift, levelSpace, topConnectorSpace, connectorSpace, partnerConnectorOffset) {
  this.shift = shift;
  this.levelSpace = levelSpace;
  this.topConnectorShift = -levelSpace / 2 - topConnectorSpace;
  this.connectorShift = this.depth + connectorSpace + (partnerConnectorOffset + 1) * (levelSpace / 2);
  this.nextLevelShift = topConnectorSpace + this.depth + connectorSpace + levelSpace + partnerConnectorOffset * levelSpace / 2;
  return this.nextLevelShift;
};
TreeLevelPosition.prototype.getNodesBottom = function() {
  return this.shift + this.depth;
};
TreeLevelPosition.prototype.toString = function() {
  return this.currentvisibility;
};

// node_modules/basicprimitives/src/models/TreeItemPosition.js
function TreeItemPosition(source) {
  this.level = null;
  this.actualVisibility = Visibility.Normal;
  this.actualSize = null;
  this.actualPosition = null;
  this.contentPosition = null;
  this.horizontalConnectorsShift = null;
  this.topConnectorShift = null;
  this.topConnectorInterval = 0;
  this.bottomConnectorShift = null;
  this.bottomConnectorInterval = 0;
  this.leftMedianOffset = null;
  this.rightMedianOffset = null;
  if (source != null) {
    for (var property in source) {
      if (source.hasOwnProperty(property)) {
        switch (property) {
          case "actualPosition":
            this.actualPosition = new Rect(source.actualPosition);
            break;
          default:
            this[property] = source[property];
            break;
        }
      }
    }
  }
}

// node_modules/basicprimitives/src/tasks/transformations/layouts/OrgLayout.js
function ChildLayoutPosition(offset, leftPadding, rightPadding) {
  this.offset = offset;
  this.leftPadding = leftPadding;
  this.rightPadding = rightPadding;
}
function OrgLayout(visualTree, treeLevels, leftMargins, rightMargins, getConnectorsStacksSizes) {
  this.visualTree = visualTree;
  this.treeLevels = treeLevels;
  this.leftMargins = leftMargins;
  this.rightMargins = rightMargins;
  this.getConnectorsStacksSizes = getConnectorsStacksSizes;
  this.treeLevelsPositions = [];
  this.childLayoutsPositions = {};
}
OrgLayout.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    var zeroBasedLevelIndex = 0;
    this.treeLevels.loopLevels(this, function(levelIndex) {
      this.treeLevels.loopLevelItems(this, levelIndex, function(treeItemId, treeItem) {
        onItem.call(thisArg, treeItem, zeroBasedLevelIndex);
      });
      zeroBasedLevelIndex += 1;
    });
  }
};
OrgLayout.prototype.measure = function(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {
  this.treeLevelsPositions = [];
  this.treeLevels.loopLevels(this, function(index, levelContext) {
    var treeLevelPosition = new TreeLevelPosition();
    this.treeLevelsPositions.push(treeLevelPosition);
  });
  this.setOffsets(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, this.visualTree, this.rightMargins, this.leftMargins, options.intervals, options.arrowsDirection, options.linesWidth, options.cousinsIntervalMultiplier, options.horizontalAlignment, options.padding);
  this.setLevelsDepth(this.treeLevels, treeItemsPositions, this.treeLevelsPositions, options.verticalAlignment);
  this.shiftLevels(this.treeLevelsPositions, options.padding.top, options.shifts, options.arrowsDirection, options.linesWidth, this.getConnectorsStacksSizes);
  var treeItemPosition = new TreeItemPosition();
  treeItemPosition.actualVisibility = Visibility.Normal;
  treeItemPosition.actualSize = this.getLayoutSize(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, options.padding);
  return treeItemPosition;
};
OrgLayout.prototype.getLayoutSize = function(treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, padding) {
  return new Rect(0, 0, Math.round(this.getLayoutWidth(treeLevels, treeItemsPositions, childLayoutsPositions, padding)), Math.round(this.getLayoutHeight(treeLevelsPositions, padding)));
};
OrgLayout.prototype.getLayoutWidth = function(treeLevels, treeItemsPositions, childLayoutsPositions, padding) {
  var result = 0;
  treeLevels.loopLevels(this, function(levelIndex, level) {
    var levelLength = treeLevels.getLevelLength(levelIndex);
    if (levelLength > 0) {
      var itemId = treeLevels.getItemAtPosition(levelIndex, levelLength - 1), treeItemPosition = treeItemsPositions[itemId], childLayoutPosition = childLayoutsPositions[itemId];
      result = Math.max(result, childLayoutPosition.offset + treeItemPosition.actualSize.width + padding.right);
    }
  });
  return result;
};
OrgLayout.prototype.getLayoutHeight = function(treeLevelsPositions, padding) {
  var len = treeLevelsPositions.length, treeLevel = treeLevelsPositions[len - 1];
  return treeLevel.getNodesBottom() + padding.bottom;
};
OrgLayout.prototype.setLevelsDepth = function(treeLevels, treeItemsPositions, treeLevelsPositions, verticalAlignment) {
  var minimalDepth, dotsDepth;
  treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
    var treeLevelPosition = treeLevelsPositions[levelIndex];
    treeLevelPosition.shift = 0;
    treeLevelPosition.depth = 0;
    treeLevelPosition.actualVisibility = Visibility.Invisible;
    minimalDepth = null;
    dotsDepth = null;
    treeLevels.loopLevelItems(this, levelIndex, function(itemId, treeItem, position) {
      var treeItemPosition = treeItemsPositions[itemId];
      treeLevelPosition.depth = Math.max(treeLevelPosition.depth, treeItemPosition.actualSize.height);
      switch (treeItemPosition.actualVisibility) {
        case Visibility.Dot:
        case Visibility.Line:
        case Visibility.Invisible:
          dotsDepth = !dotsDepth ? treeItemPosition.actualSize.height : Math.min(dotsDepth, treeItemPosition.actualSize.height);
          break;
        default:
          minimalDepth = !minimalDepth ? treeItemPosition.actualSize.height : Math.min(minimalDepth, treeItemPosition.actualSize.height);
          break;
      }
      treeLevelPosition.actualVisibility = Math.min(treeLevelPosition.actualVisibility, treeItemPosition.actualVisibility);
    });
    if (minimalDepth == null) {
      minimalDepth = treeLevelPosition.depth;
    }
    if (dotsDepth != null && dotsDepth > minimalDepth) {
      minimalDepth = dotsDepth;
    }
    switch (verticalAlignment) {
      case VerticalAlignmentType.Top:
        treeLevelPosition.horizontalConnectorsDepth = minimalDepth / 2;
        break;
      case VerticalAlignmentType.Middle:
        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth / 2;
        break;
      case VerticalAlignmentType.Bottom:
        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth - minimalDepth / 2;
        break;
    }
  });
};
OrgLayout.prototype.shiftLevels = function(treeLevelsPositions, shift, shifts, arrowsDirection, linesWidth, getConnectorsStacksSizes) {
  var index, len, treeLevelPosition, childrenSpace = 0, parentsSpace = 0, arrowTipLength = linesWidth * 8;
  switch (arrowsDirection) {
    case GroupByType.Parents:
      childrenSpace = arrowTipLength;
      parentsSpace = 0;
      break;
    case GroupByType.Children:
      childrenSpace = 0;
      parentsSpace = arrowTipLength;
      break;
  }
  var isTopLevel = true;
  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {
    treeLevelPosition = treeLevelsPositions[index];
    if (isTopLevel && treeLevelPosition.actualVisibility == Visibility.Invisible) {
      treeLevelPosition.setShift(0, 0, 0, 0, 0);
    } else {
      var parentsStackSize = getConnectorsStacksSizes(index).parentsStackSize;
      shift += treeLevelPosition.setShift(shift, shifts[treeLevelPosition.actualVisibility], parentsSpace, childrenSpace, parentsStackSize);
      isTopLevel = false;
    }
  }
};
OrgLayout.prototype.setOffsets = function(treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, visualTree, rightMargins, leftMargins, intervals, arrowsDirection, linesWidth, cousinsIntervalMultiplier, horizontalAlignment, padding) {
  var index, len;
  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {
    treeLevelsPositions[index].currentOffset = 0;
  }
  visualTree.loopPostOrder(this, function(treeItemId, treeItem, parentId, parent) {
    var treeItemPosition = treeItemsPositions[treeItemId], treeItemVisibility = treeItemPosition.actualVisibility, treeItemLevelIndex = treeLevels.getLevelIndex(treeItemId), treeLevelPosition = treeLevelsPositions[treeItemLevelIndex], treeItemPadding = intervals[treeItemVisibility === Visibility.Auto ? treeLevelPosition.currentvisibility : treeItemVisibility] / 2, index2, len2, offset, siblings, gaps, gap, leftMargin, parentItem, groups, items, item1, item2, groupIndex, groupOffset, group, sibling, leftPadding = treeLevelPosition.currentOffset > 0 ? treeItemPadding + treeItemPadding * treeItem.relationDegree * cousinsIntervalMultiplier : padding.left, arrowTipLength = linesWidth * 8;
    childLayoutsPositions[treeItemId] = new ChildLayoutPosition(0, leftPadding, treeItemPadding);
    var childLayoutPosition = childLayoutsPositions[treeItemId];
    if (arrowsDirection != GroupByType.None) {
      if (treeItem.connectorPlacement & SideFlag.Left) {
        childLayoutPosition.leftPadding += arrowTipLength;
      }
      if (treeItem.connectorPlacement & SideFlag.Right) {
        childLayoutPosition.rightPadding += arrowTipLength;
      }
    }
    childLayoutPosition.offset = treeLevelPosition.currentOffset + childLayoutPosition.leftPadding;
    treeLevelPosition.currentOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;
    if (visualTree.hasChildren(treeItemId)) {
      offset = this.getChildrenOffset(treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment);
      if (offset > 0) {
        this.offsetItemChildren(treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
      } else if (offset < 0) {
        offset = -offset;
        this.offsetItem(treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
        siblings = null;
        gaps = {};
        leftMargin = null;
        parentItem = visualTree.parent(treeItem.id);
        if (parentItem !== null) {
          visualTree.loopChildrenReversed(this, parentItem.id, function(childItemId, childItem, index3) {
            if (childItem === treeItem) {
              siblings = [];
            } else if (siblings !== null) {
              gap = this.getGapBetweenSiblings(childItem, treeItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions);
              gaps[childItem.id] = gap;
              if (gap > 0) {
                siblings.splice(0, 0, childItem);
              } else {
                leftMargin = childItem;
                return true;
              }
            }
          });
          if (siblings.length > 0) {
            groups = null;
            if (leftMargin !== null) {
              items = [leftMargin];
              items = items.concat(siblings);
              items.push(treeItem);
              groups = [[leftMargin]];
              for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {
                item1 = items[index2 - 1];
                item2 = items[index2];
                if (item1.gravity == HorizontalAlignmentType.Right || item2.gravity == HorizontalAlignmentType.Left) {
                  groups[groups.length - 1].push(item2);
                } else {
                  groups.push([item2]);
                }
              }
            } else {
              groups = [siblings.slice(0)];
              groups[groups.length - 1].push(treeItem);
            }
            if (groups.length > 0) {
              siblings = groups[groups.length - 1];
              for (index2 = siblings.length - 2; index2 >= 0; index2 -= 1) {
                sibling = siblings[index2];
                gap = gaps[sibling.id];
                offset = Math.min(gap, offset);
                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
              }
            }
            groupOffset = offset / (groups.length - 1);
            for (groupIndex = groups.length - 2; groupIndex > 0; groupIndex -= 1) {
              group = groups[groupIndex];
              for (index2 = group.length - 1; index2 >= 0; index2 -= 1) {
                sibling = group[index2];
                gap = gaps[sibling.id];
                offset = Math.min(groupIndex * groupOffset, Math.min(gap, offset));
                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);
              }
            }
          }
        }
      }
    }
  });
};
OrgLayout.prototype.getGapBetweenSiblings = function(leftItem, rightItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions) {
  var result = null, itemRightMargins = this.getRightMargins(leftItem, rightMargins, treeItemsPositions, childLayoutsPositions), itemLeftMargins = this.getLeftMargins(rightItem, leftMargins, childLayoutsPositions), depth = Math.min(itemRightMargins.length, itemLeftMargins.length);
  for (var index = 0; index < depth; index += 1) {
    var gap = itemLeftMargins[index] - itemRightMargins[index];
    result = result !== null ? Math.min(result, gap) : gap;
    if (gap <= 0) {
      break;
    }
  }
  return Math.floor(result);
};
OrgLayout.prototype.getRightMargins = function(treeItem, rightMargins, treeItemsPositions, childLayoutsPositions) {
  var result = [], itemRightMargins = rightMargins[treeItem.id];
  if (itemRightMargins === void 0) {
    itemRightMargins = [];
  }
  itemRightMargins = itemRightMargins.slice();
  itemRightMargins.splice(0, 0, treeItem.id);
  for (var index = 0, len = itemRightMargins.length; index < len; index += 1) {
    var treeItemId = itemRightMargins[index];
    var treeItemPosition = treeItemsPositions[treeItemId];
    var childLayoutPosition = childLayoutsPositions[treeItemId];
    result[index] = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;
  }
  return result;
};
OrgLayout.prototype.getLeftMargins = function(treeItem, leftMargins, childLayoutsPositions) {
  var result = [], itemLeftMargins = leftMargins[treeItem.id];
  if (itemLeftMargins === void 0) {
    itemLeftMargins = [];
  }
  itemLeftMargins = itemLeftMargins.slice();
  itemLeftMargins.splice(0, 0, treeItem.id);
  for (var index = 0, len = itemLeftMargins.length; index < len; index += 1) {
    var childLayoutPosition = childLayoutsPositions[itemLeftMargins[index]];
    result[index] = childLayoutPosition.offset - childLayoutPosition.leftPadding;
  }
  return result;
};
OrgLayout.prototype.getChildrenOffset = function(treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment) {
  var treeItemPosition = treeItemsPositions[treeItem.id], childLayoutPosition = childLayoutsPositions[treeItem.id], treeItemCenterOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width / 2, childrenCenterOffset = null;
  if (treeItem.visualAggregatorId === null) {
    var firstItem = null;
    visualTree.loopChildren(this, treeItem.id, function(childItemId, childItem, index) {
      firstItem = childItem;
      if (firstItem.connectorPlacement & SideFlag.Top) {
        return true;
      }
    });
    var firstItemPosition = treeItemsPositions[firstItem.id];
    var firstLayoutPosition = childLayoutsPositions[firstItem.id];
    var lastItem = null;
    visualTree.loopChildrenReversed(this, treeItem.id, function(childItemId, childItem, index) {
      lastItem = childItem;
      if (lastItem.connectorPlacement & SideFlag.Top) {
        return true;
      }
    });
    var lastItemPosition = treeItemsPositions[lastItem.id];
    var lastLayoutPosition = childLayoutsPositions[lastItem.id];
    switch (horizontalAlignment) {
      case HorizontalAlignmentType.Left:
        childrenCenterOffset = firstLayoutPosition.offset + firstItemPosition.actualSize.width / 2;
        break;
      case HorizontalAlignmentType.Right:
        childrenCenterOffset = lastLayoutPosition.offset + lastItemPosition.actualSize.width / 2;
        break;
      case HorizontalAlignmentType.Center:
        childrenCenterOffset = (firstLayoutPosition.offset + lastLayoutPosition.offset + lastItemPosition.actualSize.width) / 2;
        break;
    }
  } else {
    var visualAggregatorPosition = treeItemsPositions[treeItem.visualAggregatorId];
    var visualAggregatorLayoutPosition = childLayoutsPositions[treeItem.visualAggregatorId];
    childrenCenterOffset = visualAggregatorLayoutPosition.offset + visualAggregatorPosition.actualSize.width / 2;
  }
  return treeItemCenterOffset - childrenCenterOffset;
};
OrgLayout.prototype.offsetItem = function(treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions) {
  var treeItemPosition = treeItemsPositions[treeItem.id];
  var childLayoutPosition = childLayoutsPositions[treeItem.id];
  childLayoutPosition.offset += offset;
  var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(treeItem.id)];
  treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding);
};
OrgLayout.prototype.offsetItemChildren = function(treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions) {
  visualTree.loopLevels(this, treeItem.id, function(childItemId, childItem, levelid) {
    var treeItemPosition = treeItemsPositions[childItemId];
    var childLayoutPosition = childLayoutsPositions[childItemId];
    childLayoutPosition.offset += offset;
    var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(childItemId)];
    treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width);
    return true;
  });
};
OrgLayout.prototype.arrange = function(thisArg, position, layoutDirection, treeItemsPositions, options, onItemPositioned) {
  var prevLevelPosition = null;
  if (onItemPositioned != null) {
    this.treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
      var treeLevelPosition = this.treeLevelsPositions[levelIndex];
      this.treeLevels.loopLevelItems(this, levelIndex, function(itemId, treeItem, position2) {
        var treeItemPosition = treeItemsPositions[itemId];
        var childLayoutPosition = this.childLayoutsPositions[itemId];
        var result = this.getItemPosition(treeItemPosition.actualVisibility, childLayoutPosition.offset, treeItemPosition.actualSize, prevLevelPosition, treeLevelPosition, options.verticalAlignment);
        onItemPositioned.call(thisArg, itemId, __spreadValues(__spreadValues({}, treeItemPosition), result));
      });
      prevLevelPosition = treeLevelPosition;
    });
  }
};
OrgLayout.prototype.getItemPosition = function(visibility, offset, size, prevLevel, level, verticalAlignment) {
  var itemShift = 0;
  switch (visibility) {
    case Visibility.Normal:
      switch (verticalAlignment) {
        case VerticalAlignmentType.Top:
          itemShift = 0;
          break;
        case VerticalAlignmentType.Middle:
          itemShift = (level.depth - size.height) / 2;
          break;
        case VerticalAlignmentType.Bottom:
          itemShift = level.depth - size.height;
          break;
      }
      break;
    case Visibility.Dot:
    case Visibility.Line:
    case Visibility.Invisible:
      itemShift = level.horizontalConnectorsDepth - size.height / 2;
      break;
  }
  return {
    actualPosition: new Rect(offset, level.shift + itemShift, size.width, size.height),
    horizontalConnectorsShift: level.shift + level.horizontalConnectorsDepth,
    topConnectorShift: prevLevel != null ? prevLevel.shift + prevLevel.connectorShift : null,
    topConnectorInterval: prevLevel != null ? prevLevel.levelSpace / 2 : null,
    bottomConnectorShift: level.shift + level.connectorShift,
    bottomConnectorInterval: level.levelSpace / 2
  };
};

// node_modules/basicprimitives/src/tasks/transformations/layouts/ItemLayout.js
function ItemLayout(visibility) {
  this.visibility = visibility;
}
ItemLayout.prototype.measure = function(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {
  var templateConfig, size, contentPosition;
  var { orientationType, checkBoxPanelSize, buttonsPanelSize, groupTitlePanelSize, groupTitlePlacementType } = options;
  var treeItemVisibility = isSelected || isCursor ? Visibility.Normal : this.visibility;
  var actualVisibility = treeItemVisibility === Visibility.Auto ? levelVisibility : treeItemVisibility;
  switch (actualVisibility) {
    case Visibility.Normal:
      templateConfig = treeItemTemplate.template.templateConfig;
      size = new Size(templateConfig.itemSize);
      contentPosition = new Rect(0, 0, size.width, size.height);
      if (isCursor) {
        size.height += templateConfig.cursorPadding.top + templateConfig.cursorPadding.bottom;
        size.width += templateConfig.cursorPadding.left + templateConfig.cursorPadding.right;
        contentPosition.x = templateConfig.cursorPadding.left;
        contentPosition.y = templateConfig.cursorPadding.top;
      }
      if (treeItemTemplate.hasSelectorCheckbox) {
        size.height += checkBoxPanelSize;
      }
      if (treeItemTemplate.hasButtons) {
        size.width += buttonsPanelSize;
        switch (groupTitlePlacementType) {
          case AdviserPlacementType.Right:
            contentPosition.x += buttonsPanelSize;
            break;
        }
      }
      if (treeItemTemplate.hasGroupTitle) {
        size.width += groupTitlePanelSize;
        switch (groupTitlePlacementType) {
          case AdviserPlacementType.Right:
            break;
          default:
            contentPosition.x += groupTitlePanelSize;
            break;
        }
      }
      break;
    case Visibility.Dot:
      templateConfig = treeItemTemplate.template.templateConfig;
      size = new Size(templateConfig.minimizedItemSize);
      break;
    case Visibility.Line:
    case Visibility.Invisible:
      size = new Size();
      break;
  }
  switch (orientationType) {
    case OrientationType.Left:
    case OrientationType.Right:
      size.invert();
      break;
  }
  var treeItemPosition = new TreeItemPosition();
  treeItemPosition.actualVisibility = actualVisibility;
  treeItemPosition.actualSize = size;
  treeItemPosition.contentPosition = contentPosition;
  return treeItemPosition;
};
ItemLayout.prototype.arrange = function(thisArg, position, layoutDirection, treeItemsPositions, options, onItemPositioned) {
};

// node_modules/basicprimitives/src/tasks/transformations/OrgCreateLayoutsTreeTask.js
function OrgCreateLayoutsTreeTask(visualTreeTask, visualTreeLevelsTask, extractNestedLayoutsTask) {
  var _data = {
    layoutsTree: {},
    maximumId: null
  };
  function process() {
    var visualTree = visualTreeTask.getVisualTree();
    var leftMargins = visualTreeTask.getLeftMargins();
    var rightMargins = visualTreeTask.getRightMargins();
    var maximumId = visualTreeTask.getMaximumId();
    var treeLevels = visualTreeLevelsTask.getTreeLevels();
    var getConnectorsStacksSizes = visualTreeLevelsTask.getConnectorsStacksSizes;
    var layouts = extractNestedLayoutsTask.getLayouts();
    var rootLayout = new OrgLayout(visualTree, treeLevels, leftMargins, rightMargins, getConnectorsStacksSizes);
    var layoutsTree = Tree();
    maximumId++;
    layoutsTree.add(null, maximumId, rootLayout);
    var levelLayouts = [{ id: maximumId, levelLayout: rootLayout }];
    while (levelLayouts.length > 0) {
      var nextLevelLayouts = [];
      for (var index = 0; index < levelLayouts.length; index += 1) {
        var { id, levelLayout } = levelLayouts[index];
        levelLayout.loop(this, function(treeItem) {
          var treeItemId = treeItem.id;
          var itemLayout = layouts[treeItemId];
          if (!itemLayout) {
            itemLayout = new ItemLayout(treeItem.visibility);
          } else {
            nextLevelLayouts.push({ id: treeItemId, levelLayout: itemLayout });
          }
          layoutsTree.add(id, treeItemId, itemLayout);
        });
      }
      levelLayouts = nextLevelLayouts;
    }
    _data.layoutsTree = layoutsTree;
    _data.maximumId = maximumId;
    return true;
  }
  function getLayoutsTree() {
    return _data.layoutsTree;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLayoutsTree,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/ConnectionsGraphTask.js
function ConnectionsGraphTask(getGraphics, createTransformTask, connectorsOptionTask, visualTreeLevelsTask, extractNestedLayoutsTask, alignDiagramTask, removeLoopsTask) {
  var _data = {
    graph: null,
    nodeid: 0
  };
  function process() {
    var bundles = visualTreeLevelsTask.getBundles(), bundles2 = extractNestedLayoutsTask.getBundles(), nestedLayoutParentConnectorIds = extractNestedLayoutsTask.getNestedLayoutParentConnectorIds(), nestedLayoutBottomConnectorIds = extractNestedLayoutsTask.getNestedLayoutBottomConnectorIds(), connectorsOptions = connectorsOptionTask.getOptions(), loops = removeLoopsTask != null ? removeLoopsTask.getLoops() : [];
    bundles = bundles.concat(bundles2);
    var data = {
      graph: Graph(),
      nodeid: 0
    };
    var params = {
      treeItemsPositions: alignDiagramTask.getItemsPositions(),
      nestedLayoutParentConnectorIds,
      nestedLayoutBottomConnectorIds,
      transform: createTransformTask.getTransform()
    };
    var options = {
      connectorType: connectorsOptions.connectorType,
      showExtraArrows: connectorsOptions.showExtraArrows,
      bevelSize: connectorsOptions.bevelSize,
      elbowType: connectorsOptions.elbowType
    };
    for (var index = 0, len = bundles.length; index < len; index += 1) {
      var bundle = bundles[index];
      bundle.trace(data, params, options);
    }
    TraceLoops(data.graph, loops, connectorsOptions.extraArrowsMinimumSpace);
    _data = data;
    return true;
  }
  function TraceLoops(graph, loops) {
    var edges = [];
    for (var isOppositeFlow = 1; isOppositeFlow >= 0; isOppositeFlow -= 1) {
      for (var index = 0, len = loops.length; index < len; index += 1) {
        var loop2 = loops[index];
        if (loop2.isOppositeFlow == (isOppositeFlow == 1)) {
          graph.getShortestPath(this, loop2.from, [loop2.to], function(connectorEdge, fromItem, toItem) {
            return connectorEdge.weight;
          }, function(path, to) {
            for (var index2 = 0, len2 = path.length - 1; index2 < len2; index2 += 1) {
              var fromItem = path[index2], toItem = path[index2 + 1];
              var edge2 = graph.edge(fromItem, toItem);
              if (edge2.polyline.length() > 0) {
                edge2.isOppositeFlow = isOppositeFlow == 1;
                edges.push(edge2);
              }
            }
          });
        }
      }
    }
    for (var index = 0, len = edges.length; index < len; index += 1) {
      var edge = edges[index];
      if (edge.isOppositeFlow) {
        edge.hasArrow = true;
      }
    }
  }
  function getGraph() {
    return _data.graph;
  }
  return {
    process,
    getGraph
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/HighlightItemTask.js
function HighlightItemTask(highlightItemOptionTask, activeItemsTask) {
  var _data = {
    highlightTreeItemId: null
  };
  function process() {
    var treeItemId = highlightItemOptionTask.getHighlightItem(), activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};
    _data.highlightTreeItemId = treeItemId != null && activeItems.hasOwnProperty(treeItemId) ? treeItemId : null;
    return true;
  }
  function getHighlightTreeItem() {
    return _data.highlightTreeItemId;
  }
  return {
    process,
    getHighlightTreeItem
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/CursorItemTask.js
function CursorItemTask(cursorItemOptionTask, activeItemsTask) {
  var _data = {
    cursorTreeItemId: null
  };
  function process() {
    var treeItemId = cursorItemOptionTask.getCursorItem(), activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};
    _data.cursorTreeItemId = treeItemId != null && activeItems.hasOwnProperty(treeItemId) ? treeItemId : null;
    return true;
  }
  function getCursorTreeItem() {
    return _data.cursorTreeItemId;
  }
  function getItems() {
    return _data.cursorTreeItemId != null ? [_data.cursorTreeItemId] : [];
  }
  return {
    process,
    getCursorTreeItem,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/OrgCursorNeighboursTask.js
function OrgCursorNeighboursTask(cursorItemTask, navigationFamilyTask) {
  var _data = {
    items: []
  };
  function process() {
    var navigationFamily = navigationFamilyTask.getLogicalFamily(), cursorTreeItemId = cursorItemTask.getCursorTreeItem();
    _data.items = getCursorNeighbours(cursorTreeItemId, navigationFamily);
    return true;
  }
  function getCursorNeighbours(cursorTreeItemId, navigationFamily) {
    var result = [];
    if (cursorTreeItemId !== null) {
      navigationFamily.loopNeighbours(this, cursorTreeItemId, function(treeItemId, treeItem, distance) {
        if (treeItem.isVisible) {
          result.push(treeItemId);
        }
        return true;
      });
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/SelectedItemsTask.js
function SelectedItemsTask(selectedItemsOptionTask, itemsOptionTask) {
  var _data = {
    items: []
  }, _hash = {}, _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, selectedItems = selectedItemsOptionTask.getSelectedItems();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(selectedItems), "items", context);
    return context.isChanged;
  }
  function getSelectedItems(selectedItems) {
    var result = [], processed = {}, index, len, treeItemId;
    for (index = 0, len = selectedItems.length; index < len; index += 1) {
      treeItemId = selectedItems[index];
      if (treeItemId != null && !processed.hasOwnProperty(treeItemId)) {
        processed[treeItemId] = true;
        if (itemsOptionTask.getConfig(treeItemId) != null) {
          result.push(treeItemId);
        }
      }
    }
    return result;
  }
  function isSelected(itemid) {
    return _hash.items.hasOwnProperty(itemid);
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems,
    isSelected
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/OrgSelectionPathItemsTask.js
function OrgSelectionPathItemsTask(navigationFamilyTask, cursorItemTask, selectedItemsTask, cursorSelectionPathModeOptionTask) {
  var _data = {
    items: []
  };
  function process() {
    var selectionPathMode = cursorSelectionPathModeOptionTask.getSelectionPathMode(), navigationFamily = navigationFamilyTask.getLogicalFamily(), cursorTreeItemId = cursorItemTask.getCursorTreeItem(), selectedItems = selectedItemsTask.getItems().slice(0);
    selectedItems.push(cursorTreeItemId);
    _data.items = getSelectionPathItems(selectedItems, navigationFamily, selectionPathMode);
    return true;
  }
  function getSelectionPathItems(selectedItems, navigationFamily, selectionPathMode) {
    var result = [], processed = {}, selectedItem, index, len;
    for (index = 0, len = selectedItems.length; index < len; index += 1) {
      selectedItem = selectedItems[index];
      switch (selectionPathMode) {
        case SelectionPathMode.None:
          break;
        case SelectionPathMode.FullStack:
          navigationFamily.loopParents(this, selectedItem, function(parentItemId, parentItem) {
            if (processed[parentItemId] != null) {
              return navigationFamily.SKIP;
            }
            if (parentItem.visibility != Visibility.Invisible) {
              result.push(parentItemId);
            }
            processed[parentItemId] = true;
          });
          break;
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/NormalVisibilityItemsByAnnotationTask.js
function NormalVisibilityItemsByAnnotationTask(annotationOptionTask) {
  var _data = {
    items: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, annotations = annotationOptionTask.getAnnotations();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(annotations), "items", context);
    return context.isChanged;
  }
  function getSelectedItems(annotations) {
    var result = [], processed = {}, index, len, index2, len2, items, item, annotation, treeItemId;
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotation = annotations[index];
      if (annotation.selectItems) {
        items = annotation.items;
        for (index2 = 0, len2 = items.length; index2 < len2; index2 += 1) {
          treeItemId = items[index2];
          if (treeItemId != null && !processed.hasOwnProperty(treeItemId)) {
            result.push(treeItemId);
            processed[treeItemId] = true;
          }
        }
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/NormalVisibilityItemsByConnectorAnnotationTask.js
function NormalVisibilityItemsByConnectorAnnotationTask(connectorAnnotationOptionTask) {
  var _data = {
    items: []
  }, _hash = {}, _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, annotations = connectorAnnotationOptionTask.getAnnotations();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(annotations), "items", context);
    return context.isChanged;
  }
  function getSelectedItems(annotations) {
    var result = [], processed = {}, index, len, annotation, treeItem;
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotation = annotations[index];
      if (annotation.selectItems) {
        if (annotation.fromItem != null && !processed.hasOwnProperty(annotation.fromItem)) {
          result.push(annotation.fromItem);
          processed[annotation.fromItem] = true;
        }
        if (annotation.toItem != null && !processed.hasOwnProperty(annotation.toItem)) {
          result.push(annotation.toItem);
          processed[annotation.toItem] = true;
        }
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/OrgNormalVisibilityItemsByMinimumVisibleLevelsTask.js
function OrgNormalVisibilityItemsByMinimumVisibleLevelsTask(minimumVisibleLevelsOptionTask, orgTreeTask) {
  var _data = {
    items: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, orgTree = orgTreeTask.getOrgTree(), { pageFitMode, minimalVisibility, minimumVisibleLevels } = minimumVisibleLevelsOptionTask.getOptions();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(orgTree, pageFitMode, minimalVisibility, minimumVisibleLevels), "items", context);
    return context.isChanged;
  }
  function getSelectedItems(orgTree, pageFitMode, minimalVisibility, minimumVisibleLevels) {
    var result = [], buckets = [];
    if (minimumVisibleLevels > 0) {
      if (PageFitMode.PageWidth == pageFitMode || PageFitMode.PageHeight || PageFitMode.FitToPage) {
        if (minimalVisibility != Visibility.Normal) {
          orgTree.loopLevels(this, function(nodeId, node, levelIndex) {
            if (node.isVisible) {
              var nodeLevel = levelIndex + node.levelOffset;
              if (!buckets[nodeLevel]) {
                buckets[nodeLevel] = [nodeId];
              } else {
                buckets[nodeLevel].push(nodeId);
              }
            }
          });
          var actualLevel = 0;
          for (var index = 0; index < buckets.length; index += 1) {
            if (buckets[index] != null) {
              result = result.concat(buckets[index]);
              actualLevel += 1;
              if (actualLevel >= minimumVisibleLevels) {
                break;
              }
            }
          }
        }
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/CombinedNormalVisibilityItemsTask.js
function CombinedNormalVisibilityItemsTask(itemsSizesOptionTask, cursorItemTask, cursorNeighboursTask, selectedItemsTask, selectionPathItemsTask, normalVisibilityItemsByForegroundShapeAnnotationTask, normalVisibilityItemsByBackgroundShapeAnnotationTask, normalVisibilityItemsByBackgroundAnnotationTask, normalVisibilityItemsByForegroundHighlightPathAnnotationTask, normalVisibilityItemsByBackgroundHighlightPathAnnotationTask, normalVisibilityItemsByForegroundConnectorAnnotationTask, normalVisibilityItemsByBackgroundConnectorAnnotationTask, NormalVisibilityItemsByMinimumVisibleLevelsTask) {
  var _data = {
    items: []
  }, _hash = {}, _sourceTasks = [
    cursorItemTask,
    cursorNeighboursTask,
    selectedItemsTask,
    selectionPathItemsTask,
    normalVisibilityItemsByForegroundShapeAnnotationTask,
    normalVisibilityItemsByBackgroundShapeAnnotationTask,
    normalVisibilityItemsByBackgroundAnnotationTask,
    normalVisibilityItemsByForegroundHighlightPathAnnotationTask,
    normalVisibilityItemsByBackgroundHighlightPathAnnotationTask,
    normalVisibilityItemsByForegroundConnectorAnnotationTask,
    normalVisibilityItemsByBackgroundConnectorAnnotationTask,
    NormalVisibilityItemsByMinimumVisibleLevelsTask
  ], _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, itemsSizesOption = itemsSizesOptionTask.getOptions();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(_sourceTasks), "items", context);
    if (itemsSizesOption.pageFitMode == PageFitMode.None || itemsSizesOption.minimalVisibility == Visibility.Normal) {
      context.isChanged = false;
    }
    return context.isChanged;
  }
  function getSelectedItems(sourceTasks, getItemOptions) {
    var result = [], sourceIndex, sourceLen, sourceTask, index, len, items, item, processed = {};
    for (sourceIndex = 0, sourceLen = sourceTasks.length; sourceIndex < sourceLen; sourceIndex += 1) {
      sourceTask = sourceTasks[sourceIndex];
      items = sourceTask.getItems();
      for (index = 0, len = items.length; index < len; index += 1) {
        item = items[index];
        if (!processed.hasOwnProperty(item)) {
          result.push(item);
          processed[item] = true;
        }
      }
    }
    return result;
  }
  function isItemSelected(treeItem) {
    return _hash.items.hasOwnProperty(treeItem);
  }
  return {
    process,
    isItemSelected
  };
}

// node_modules/basicprimitives/src/tasks/layout/FrameSizeTask.js
function FrameSizeTask(frameOptionTask, readTemplatesTask, scaleOptionTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    median: new ObjectReader({
      left: new ValueReader(["number"], false, 0),
      top: new ValueReader(["number"], false, 0),
      right: new ValueReader(["number"], false, 0),
      bottom: new ValueReader(["number"], false, 0)
    }, false, new Thickness(0, 0, 0, 0)),
    thickness: new ObjectReader({
      left: new ValueReader(["number"], false, 0),
      top: new ValueReader(["number"], false, 0),
      right: new ValueReader(["number"], false, 0),
      bottom: new ValueReader(["number"], false, 0)
    }, false, new Thickness(0, 0, 0, 0))
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, getFrameSize(), "options", context);
    return context.isChanged;
  }
  function getFrameSize() {
    var frameOptions = frameOptionTask.getOptions(), showFrame = frameOptions.showFrame, frameInnerPadding = frameOptions.frameInnerPadding, frameOuterPadding = frameOptions.frameOuterPadding, scale = scaleOptionTask.getOptions().scale, median = new Thickness(0, 0, 0, 0), thickness = new Thickness(0, 0, 0, 0);
    if (showFrame) {
      var maximumMarkerSize = new Size(0, 0), maximumMarkerPadding = new Thickness(0, 0, 0, 0), index, len, templates = readTemplatesTask.getItemTemplates();
      for (index = 0, len = templates.length; index < len; index += 1) {
        var template = templates[index];
        var templateConfig = template.templateConfig, cursorPadding = new Thickness(templateConfig.cursorPadding), highlightPadding = new Thickness(templateConfig.highlightPadding);
        cursorPadding.addThickness(templateConfig.cursorBorderWidth);
        highlightPadding.addThickness(templateConfig.highlightBorderWidth);
        maximumMarkerSize.maxSize(templateConfig.minimizedItemSize);
        maximumMarkerPadding.maxThickness(templateConfig.cursorPadding);
        maximumMarkerPadding.maxThickness(templateConfig.highlightPadding);
      }
      median = new Thickness(
        Math.ceil(maximumMarkerSize.width / 2) + maximumMarkerPadding.right,
        Math.ceil(maximumMarkerSize.height / 2) + maximumMarkerPadding.bottom,
        Math.ceil(maximumMarkerSize.width / 2) + maximumMarkerPadding.left,
        Math.ceil(maximumMarkerSize.height / 2) + maximumMarkerPadding.top
      );
      median.addThickness(frameInnerPadding);
      median.scale(scale);
      thickness = new Thickness(
        maximumMarkerSize.width + maximumMarkerPadding.left + maximumMarkerPadding.right,
        maximumMarkerSize.height + maximumMarkerPadding.top + maximumMarkerPadding.bottom,
        maximumMarkerSize.width + maximumMarkerPadding.left + maximumMarkerPadding.right,
        maximumMarkerSize.height + maximumMarkerPadding.top + maximumMarkerPadding.bottom
      );
      thickness.addThickness(frameInnerPadding);
      thickness.addThickness(frameOuterPadding);
      thickness.scale(scale);
    }
    return { median, thickness };
  }
  function getMedian() {
    return _data.median;
  }
  function getThickness() {
    return _data.thickness;
  }
  return {
    process,
    getMedian,
    getThickness
  };
}

// node_modules/basicprimitives/src/tasks/layout/LevelTitleSizeTask.js
function LevelTitleSizeTask(levelTitlePlacementOptionTask, levelAnnotationOptionTask, orientationOptionTask, scaleOptionTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    thickness: new ObjectReader({
      left: new ValueReader(["number"], false, 0),
      top: new ValueReader(["number"], false, 0),
      right: new ValueReader(["number"], false, 0),
      bottom: new ValueReader(["number"], false, 0)
    }, false, new Thickness(0, 0, 0, 0))
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, getThickness(), "options", context);
    return context.isChanged;
  }
  function getThickness() {
    var { levelTitlePlaceInside, levelTitlePanelSize, levelTitlePlacementType } = levelTitlePlacementOptionTask.getOptions(), { scale } = scaleOptionTask.getOptions(), { orientationType } = orientationOptionTask.getOptions(), annotations = levelAnnotationOptionTask.getAnnotations(), thickness = new Thickness(0, 0, 0, 0);
    if (annotations.length > 0) {
      if (levelTitlePlaceInside) {
        levelTitlePanelSize = -levelTitlePanelSize;
      }
      switch (levelTitlePlacementType) {
        case AdviserPlacementType.Right:
          switch (orientationType) {
            case OrientationType.Left:
              thickness = new Thickness(0, levelTitlePanelSize, 0, 0);
              break;
            case OrientationType.Right:
              thickness = new Thickness(0, 0, 0, levelTitlePanelSize);
              break;
            case OrientationType.Top:
            case OrientationType.Bottom:
              thickness = new Thickness(0, 0, levelTitlePanelSize, 0);
            default:
              break;
          }
          break;
        case AdviserPlacementType.Left:
        default:
          switch (orientationType) {
            case OrientationType.Left:
              thickness = new Thickness(0, 0, 0, levelTitlePanelSize);
              break;
            case OrientationType.Right:
              thickness = new Thickness(0, levelTitlePanelSize, 0, 0);
              break;
            case OrientationType.Top:
            case OrientationType.Bottom:
              thickness = new Thickness(levelTitlePanelSize, 0, 0, 0);
            default:
              break;
          }
          break;
      }
      thickness.scale(scale);
    }
    return { thickness };
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/options/LayoutOptionsTask.js
function LayoutOptionsTask(getLayout, optionsTask) {
  var _data = {};
  function process() {
    _data = getLayout();
    return true;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions,
    description: "Raw layout options."
  };
}

// node_modules/basicprimitives/src/tasks/layout/CurrentControlSizeTask.js
function CurrentControlSizeTask(layoutOptionsTask, itemsSizesOptionTask, frameSizeTask, levelTitleSizeTask) {
  var _data = {}, _hash = {}, _dataTemplate = new ObjectReader({
    scrollPanelSize: new ObjectReader({
      width: new ValueReader(["number"], true),
      height: new ValueReader(["number"], true)
    }, true),
    optimalPanelSize: new ObjectReader({
      width: new ValueReader(["number"], true),
      height: new ValueReader(["number"], true)
    }, true),
    hasFrame: new ValueReader(["boolean"], true),
    hasLevelTitles: new ValueReader(["boolean"], true)
  });
  function process() {
    var result = false, context = { isChanged: false, hash: _hash }, layoutOptions = layoutOptionsTask.getOptions(), { pageFitMode } = itemsSizesOptionTask.getOptions(), frameThickness = new Thickness(frameSizeTask.getThickness()), levelTitlesThickness = new Thickness(levelTitleSizeTask.getOptions().thickness);
    layoutOptions.hasLevelTitles = false;
    if (levelTitlesThickness.isPositive()) {
      let viewportSize = new Size(layoutOptions.scrollPanelSize);
      viewportSize.removeThickness(levelTitlesThickness);
      if (layoutOptions.scrollPanelSize.space() < viewportSize.space() * 2) {
        layoutOptions.scrollPanelSize = viewportSize;
        layoutOptions.hasLevelTitles = true;
      }
    }
    layoutOptions.hasFrame = false;
    if (frameThickness.isPositive()) {
      let viewportSize = new Size(layoutOptions.scrollPanelSize);
      viewportSize.removeThickness(frameThickness);
      if (layoutOptions.scrollPanelSize.space() < viewportSize.space() * 2) {
        layoutOptions.scrollPanelSize = viewportSize;
        layoutOptions.hasFrame = true;
      }
    }
    layoutOptions.optimalPanelSize = new Size(layoutOptions.scrollPanelSize.width - 25, layoutOptions.scrollPanelSize.height - 25);
    _data = _dataTemplate.read(_data, layoutOptions, "layout", context);
    switch (pageFitMode) {
      case PageFitMode.PageWidth:
      case PageFitMode.PageHeight:
      case PageFitMode.FitToPage:
      case PageFitMode.None:
      case PageFitMode.SelectionOnly:
        result = context.isChanged;
        break;
      default:
        break;
    }
    return result;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/layout/CurrentScrollPositionTask.js
function CurrentScrollPositionTask(layoutOptionsTask) {
  var _data = {
    placeholderOffset: null
  }, _hash = {}, _dataTemplate = new ObjectReader({
    placeholderOffset: new ObjectReader({
      x: new ValueReader(["number"], true),
      y: new ValueReader(["number"], true)
    }, true)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, layoutOptions = layoutOptionsTask.getOptions();
    _data = _dataTemplate.read(_data, layoutOptions, "layout", context);
    return context.isChanged;
  }
  function getPlaceholderOffset() {
    return _data.placeholderOffset;
  }
  return {
    process,
    getPlaceholderOffset
  };
}

// node_modules/basicprimitives/src/tasks/transformations/ItemsPositionsTask.js
function LevelVisibility(level, visibility) {
  this.level = level;
  this.visibility = visibility;
}
function ItemsPositionsTask(currentControlSizeTask, scaleOptionTask, orientationOptionTask, itemsSizesOptionTask, connectorsOptionTask, normalizeOptionTask, createLayoutsTreeTask, itemTemplateParamsTask, cursorItemTask, combinedNormalVisibilityItemsTask) {
  var _data = {
    treeItemsPositions: {},
    // TreeItemPosition();
    size: null
    // Rect();
  };
  function process() {
    var {
      verticalAlignment,
      pageFitMode,
      minimalVisibility,
      padding,
      normalLevelShift,
      dotLevelShift,
      lineLevelShift,
      normalItemsInterval,
      dotItemsInterval,
      lineItemsInterval,
      checkBoxPanelSize,
      buttonsPanelSize,
      groupTitlePanelSize,
      groupTitlePlacementType,
      cousinsIntervalMultiplier
    } = itemsSizesOptionTask.getOptions();
    var { arrowsDirection, linesWidth } = connectorsOptionTask.getOptions();
    var { maximumColumnsInMatrix, horizontalAlignment } = normalizeOptionTask.getOptions();
    var { orientationType } = orientationOptionTask.getOptions();
    var isItemSelected = combinedNormalVisibilityItemsTask.isItemSelected;
    var cursorItemId = cursorItemTask.getCursorTreeItem();
    var getTemplateParams = itemTemplateParamsTask.getTemplateParams;
    var { optimalPanelSize } = currentControlSizeTask.getOptions();
    var panelSize = new Size(optimalPanelSize);
    var { scale } = scaleOptionTask.getOptions();
    panelSize.scale(1 / scale);
    var layoutsTree = createLayoutsTreeTask.getLayoutsTree();
    var rootLayoutId = null;
    layoutsTree.loopLevels(this, function(nodeId, node, levelIndex) {
      rootLayoutId = nodeId;
      return layoutsTree.BREAK;
    });
    var levelIndexes = {};
    var maximumLevelIndex = 0;
    var hasNodes = false;
    layoutsTree.loopLevels(this, function(layoutId, layout, levelIndex) {
      if (layout.loop != null) {
        var parentId = layoutsTree.parentid(layoutId);
        var parentLevelIndex = levelIndexes[parentId] || 0;
        layout.loop(this, function(treeItem, levelIndex2) {
          var itemLevelIndex = parentLevelIndex + levelIndex2;
          levelIndexes[treeItem.id] = itemLevelIndex;
          maximumLevelIndex = Math.max(maximumLevelIndex, itemLevelIndex);
          hasNodes = true;
        });
      }
    });
    var options = {
      verticalAlignment,
      pageFitMode,
      padding,
      minimalVisibility,
      orientationType,
      arrowsDirection,
      linesWidth,
      checkBoxPanelSize,
      buttonsPanelSize,
      groupTitlePanelSize,
      groupTitlePlacementType,
      maximumColumnsInMatrix,
      horizontalAlignment,
      shifts: getShifts(normalLevelShift, dotLevelShift, lineLevelShift, lineLevelShift),
      intervals: getIntervals(normalItemsInterval, dotItemsInterval, lineItemsInterval, lineItemsInterval),
      cousinsIntervalMultiplier
    };
    _data.treeItemsPositions = {};
    _data.size = panelSize;
    if (hasNodes) {
      var { treeItemsPositions, size } = autoFitDiagramToPageSize(panelSize, maximumLevelIndex, rootLayoutId, layoutsTree, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options);
      _data.treeItemsPositions = treeItemsPositions;
      _data.size = size;
      var treeItemPosition = _data.treeItemsPositions[rootLayoutId];
      treeItemPosition.actualPosition = new Rect(0, 0, _data.size.width, _data.size.height);
      var layoutsDirections = {};
      layoutsTree.loopPreOrder(this, function(childLayoutId, childLayout, parentLayoutId, parentLayout) {
        var treeItemPosition2 = _data.treeItemsPositions[childLayoutId];
        var layoutDirection = layoutsDirections[childLayoutId];
        childLayout.arrange(this, treeItemPosition2.actualPosition, layoutDirection, _data.treeItemsPositions, options, function(treeItemId, treeItemPosition3, layoutDirection2) {
          _data.treeItemsPositions[treeItemId] = treeItemPosition3;
          layoutsDirections[treeItemId] = layoutDirection2;
        });
      });
    }
    return true;
  }
  function autoFitDiagramToPageSize(panelSize, maximumLevelIndex, rootLayoutId, layoutsTree, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options) {
    var result, possibleLevelVisibilities, enabledLevelVisibilities;
    var { orientationType, pageFitMode, minimalVisibility } = options;
    switch (orientationType) {
      case OrientationType.Left:
      case OrientationType.Right:
        panelSize.invert();
        break;
    }
    switch (pageFitMode) {
      case PageFitMode.None:
      case PageFitMode.AutoSize:
        possibleLevelVisibilities = [new LevelVisibility(0, Visibility.Normal)];
        enabledLevelVisibilities = getLevelVisibilities(maximumLevelIndex, possibleLevelVisibilities, 0);
        result = measureLayout(rootLayoutId, layoutsTree, enabledLevelVisibilities, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options);
        break;
      default:
        possibleLevelVisibilities = getPossibleLevelVisibilities(maximumLevelIndex, minimalVisibility);
        enabledLevelVisibilities = getLevelVisibilities(maximumLevelIndex, possibleLevelVisibilities, possibleLevelVisibilities.length - 1);
        result = measureLayout(rootLayoutId, layoutsTree, enabledLevelVisibilities, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options);
        if (checkDiagramSize(result.size, panelSize, pageFitMode)) {
          var minimalPlaceholderSize = new Rect(0, 0, result.size.width, result.size.height);
          minimalPlaceholderSize.addRect(0, 0, panelSize.width, panelSize.height);
          minimalPlaceholderSize.offset(0, 0, 5, 5);
          findOptimalSize(this, possibleLevelVisibilities.length - 1, function(index) {
            enabledLevelVisibilities = getLevelVisibilities(maximumLevelIndex, possibleLevelVisibilities, index);
            result = measureLayout(rootLayoutId, layoutsTree, enabledLevelVisibilities, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options);
            return checkDiagramSize(result.size, minimalPlaceholderSize, options.pageFitMode);
          });
        }
        break;
    }
    return result;
  }
  function findOptimalSize(thisArg, maximum, funcCheckSize) {
    var minimum = 0, cursorIndex;
    if (!funcCheckSize.call(thisArg, minimum)) {
      cursorIndex = maximum;
      while (maximum - minimum > 1) {
        cursorIndex = Math.floor((maximum + minimum) / 2);
        if (funcCheckSize.call(thisArg, cursorIndex)) {
          maximum = cursorIndex;
        } else {
          minimum = cursorIndex;
        }
      }
      if (maximum !== cursorIndex) {
        funcCheckSize.call(thisArg, maximum);
      }
    }
  }
  ;
  function measureLayout(rootLayoutId, layoutsTree, levelVisibilities, levelIndexes, cursorItemId, isItemSelected, getTemplateParams, options) {
    var treeItemsPositions = {};
    layoutsTree.loopPostOrder(this, function(childLayoutId, childLayout, parentLayoutId, parentLayout) {
      var levelIndex = levelIndexes[childLayoutId];
      var levelVisibility = levelVisibilities[levelIndex];
      var isCursor = cursorItemId == childLayoutId;
      var isSelected = isItemSelected(childLayoutId);
      var treeItemTemplate = getTemplateParams(childLayoutId);
      treeItemsPositions[childLayoutId] = childLayout.measure(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options);
    });
    return {
      treeItemsPositions,
      size: treeItemsPositions[rootLayoutId].actualSize
    };
  }
  function getLevelVisibilities(maximumLevelIndex, possibleLevelVisibilities, cursorIndex) {
    var index, levelVisibility;
    var result = [];
    for (var levelIndex = 0; levelIndex <= maximumLevelIndex; levelIndex += 1) {
      result.push(Visibility.Normal);
    }
    ;
    for (index = 0; index <= cursorIndex; index += 1) {
      levelVisibility = possibleLevelVisibilities[index];
      result[levelVisibility.level] = levelVisibility.visibility;
    }
    return result;
  }
  function getPossibleLevelVisibilities(maximumLevelIndex, minimalVisibility) {
    var result = [new LevelVisibility(0, Visibility.Normal)];
    var visibilities = [];
    switch (minimalVisibility) {
      case Visibility.Normal:
        break;
      case Visibility.Dot:
        visibilities.push(Visibility.Dot);
        break;
      case Visibility.Auto:
      case Visibility.Line:
      case Visibility.Invisible:
        visibilities.push(Visibility.Dot);
        visibilities.push(Visibility.Line);
        break;
    }
    for (var levelIndex = maximumLevelIndex; levelIndex >= 0; levelIndex -= 1) {
      for (var index = 0; index < visibilities.length; index += 1) {
        result.push(new LevelVisibility(levelIndex, visibilities[index]));
      }
    }
    ;
    return result;
  }
  ;
  function checkDiagramSize(diagramSize, panelSize, pageFitMode) {
    var result = false;
    switch (pageFitMode) {
      case PageFitMode.PageWidth:
        if (panelSize.width >= diagramSize.width) {
          result = true;
        }
        break;
      case PageFitMode.PageHeight:
        if (panelSize.height >= diagramSize.height) {
          result = true;
        }
        break;
      case PageFitMode.FitToPage:
        if (panelSize.height >= diagramSize.height && panelSize.width >= diagramSize.width) {
          result = true;
        }
        break;
    }
    return result;
  }
  ;
  function getShifts(normalLevelShift, dotLevelShift, lineLevelShift, invisibleLineLevelShift) {
    var result = [];
    result[Visibility.Normal] = normalLevelShift;
    result[Visibility.Dot] = dotLevelShift;
    result[Visibility.Line] = lineLevelShift;
    result[Visibility.Invisible] = invisibleLineLevelShift;
    return result;
  }
  ;
  function getIntervals(normalItemsInterval, dotItemsInterval, lineItemsInterval, invisibleLineItemsInterval) {
    var result = [];
    result[Visibility.Normal] = normalItemsInterval;
    result[Visibility.Dot] = dotItemsInterval;
    result[Visibility.Line] = lineItemsInterval;
    result[Visibility.Invisible] = invisibleLineItemsInterval;
    return result;
  }
  ;
  function getItemPosition(itemid) {
    return _data.treeItemsPositions[itemid];
  }
  function getItemsPositions() {
    return _data.treeItemsPositions;
  }
  function getContentSize() {
    return _data.size;
  }
  return {
    process,
    getItemsPositions,
    getItemPosition,
    getContentSize
  };
}

// node_modules/basicprimitives/src/managers/KeyboardNavigationManager.js
function KeyboardNavigationManager() {
  var _placements = [], _rows, _treeLevels, _cursor = null;
  function Cursor(itemid, row) {
    this.itemid = itemid;
    this.row = row;
  }
  function addRect(rect, itemid) {
    var newRect = new Rect(rect);
    newRect.context = itemid;
    _placements.push(newRect);
  }
  function prepair() {
    if (_treeLevels == null) {
      var levelIndex = 0;
      _rows = SortedList();
      getMinimumCrossingRows(this, _placements, function(row) {
        _rows.add(row, levelIndex);
        levelIndex += 1;
      });
      _treeLevels = TreeLevels();
      _placements.sort(function(a, b) {
        return a.horizontalCenter() - b.horizontalCenter();
      });
      for (var index = 0, len = _placements.length; index < len; index += 1) {
        var placement = _placements[index];
        _rows.loopForward(this, placement.y, function(row, levelIndex2) {
          if (row > placement.bottom()) {
            return true;
          }
          _treeLevels.addItem(levelIndex2, placement.context, placement);
        });
      }
    }
  }
  function getCursor(itemid) {
    prepair();
    if (_cursor == null || _cursor.itemid != itemid) {
      _cursor = new Cursor(itemid, _treeLevels.getLevelIndex(itemid));
    }
    return _cursor;
  }
  function getItemAbove(itemid) {
    _cursor = getCursor(itemid);
    moveCursorNextRow(false);
    return _cursor.itemid;
  }
  function getItemBelow(itemid) {
    _cursor = getCursor(itemid);
    moveCursorNextRow(true);
    return _cursor.itemid;
  }
  function moveCursorNextRow(isBelow) {
    var cursorItemRect = _treeLevels.getItemContext(_cursor.itemid);
    var cursorCenter = cursorItemRect.horizontalCenter();
    var previousCursorItem = _cursor.itemid;
    _treeLevels.loopLevelsFromItem(this, _cursor.itemid, isBelow, function(levelIndex) {
      _cursor.row = levelIndex;
      _cursor.itemid = _treeLevels.binarySearch(this, levelIndex, function(itemid, placement) {
        return cursorCenter - placement.horizontalCenter();
      });
      return true;
    });
    if (previousCursorItem == _cursor.itemid) {
      if (isBelow) {
        _cursor.row = _treeLevels.getEndLevelIndex(_cursor.itemid);
      } else {
        _cursor.row = _treeLevels.getLevelIndex(_cursor.itemid);
      }
    }
  }
  function getItemOnLeft(itemid) {
    _cursor = getCursor(itemid);
    var nextItem = _treeLevels.getPrevItem(_cursor.itemid, _cursor.row);
    if (nextItem != null) {
      _cursor.itemid = nextItem;
    }
    return _cursor.itemid;
  }
  function getItemOnRight(itemid) {
    _cursor = getCursor(itemid);
    var nextItem = _treeLevels.getNextItem(_cursor.itemid, _cursor.row);
    if (nextItem != null) {
      _cursor.itemid = nextItem;
    }
    return _cursor.itemid;
  }
  function getNavigationLevels() {
    prepair();
    var result = [];
    _treeLevels.loopLevels(this, function(levelIndex, level) {
      var levelItems = [];
      _treeLevels.loopLevelItems(this, levelIndex, function(itemid, item, position) {
        levelItems.push(itemid);
      });
      result.push(levelItems);
    });
    return result;
  }
  return {
    addRect,
    prepair,
    getItemAbove,
    getItemBelow,
    getItemOnLeft,
    getItemOnRight,
    getNavigationLevels
  };
}

// node_modules/basicprimitives/src/tasks/layout/AlignDiagramTask.js
function AlignDiagramTask(orientationOptionTask, itemsSizesOptionTask, visualTreeOptionTask, scaleOptionTask, currentControlSizeTask, activeItemsTask, itemsPositionsTask) {
  var _data = {
    treeItemsPositions: {},
    // TreeItemPosition();
    panelSize: null
    // Rect();
  }, _activeItems, _treeItemsPositions, _spatialIndex, _keyboardNavigationManager;
  function process() {
    var placeholderSize = new Size(itemsPositionsTask.getContentSize()), { optimalPanelSize } = currentControlSizeTask.getOptions(), { pageFitMode } = itemsSizesOptionTask.getOptions(), { orientationType } = orientationOptionTask.getOptions(), { horizontalAlignment } = visualTreeOptionTask.getOptions(), { scale } = scaleOptionTask.getOptions();
    _spatialIndex = null;
    _keyboardNavigationManager = null;
    _activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};
    _treeItemsPositions = itemsPositionsTask.getItemsPositions();
    var panelSize = new Size(optimalPanelSize);
    switch (orientationType) {
      case OrientationType.Left:
      case OrientationType.Right:
        panelSize.invert();
        break;
    }
    panelSize.scale(1 / scale);
    _data.panelSize = panelSize;
    _data.treeItemsPositions = _treeItemsPositions;
    switch (pageFitMode) {
      case PageFitMode.AutoSize:
        _data.panelSize = new Size(placeholderSize);
        break;
      default:
        _data.panelSize = new Size(placeholderSize);
        if (placeholderSize.width < panelSize.width) {
          _data.treeItemsPositions = {};
          stretchToWidth(_data.treeItemsPositions, placeholderSize.width, panelSize.width, horizontalAlignment);
          _data.panelSize.width = panelSize.width;
        }
        if (placeholderSize.height < panelSize.height) {
          _data.panelSize.height = panelSize.height;
        }
        break;
    }
    switch (orientationType) {
      case OrientationType.Left:
      case OrientationType.Right:
        _data.panelSize.invert();
        break;
    }
    return true;
  }
  function stretchToWidth(treeItemsPositions, treeWidth, panelWidth, horizontalAlignment) {
    var offset;
    switch (horizontalAlignment) {
      case HorizontalAlignmentType.Left:
        offset = 0;
        break;
      case HorizontalAlignmentType.Right:
        offset = panelWidth - treeWidth;
        break;
      case HorizontalAlignmentType.Center:
        offset = (panelWidth - treeWidth) / 2;
        break;
    }
    translateItemPositions(treeItemsPositions, offset, 0);
  }
  function translateItemPositions(treeItemsPositions, offsetX, offsetY) {
    var treeItemId, treeItemPosition;
    for (treeItemId in _treeItemsPositions) {
      if (_treeItemsPositions.hasOwnProperty(treeItemId)) {
        treeItemPosition = new TreeItemPosition(_treeItemsPositions[treeItemId]);
        treeItemPosition.actualPosition.translate(offsetX, offsetY);
        treeItemsPositions[treeItemId] = treeItemPosition;
      }
    }
  }
  function getSizes() {
    var result = [];
    var hash = {};
    for (var itemid in _data.treeItemsPositions) {
      if (_data.treeItemsPositions.hasOwnProperty(itemid)) {
        var treeItemPosition = _data.treeItemsPositions[itemid];
        switch (treeItemPosition.actualVisibility) {
          case Visibility.Normal:
          case Visibility.Dot:
          case Visibility.Line:
            var item = treeItemPosition.actualPosition;
            var size = Math.max(item.width, item.height);
            if (!hash.hasOwnProperty(size)) {
              hash[size] = true;
              result.push(size);
            }
        }
      }
    }
    return result;
  }
  function getSpatialIndex() {
    if (_spatialIndex == null) {
      _spatialIndex = SpatialIndex(getSizes());
      for (var itemid in _data.treeItemsPositions) {
        if (_data.treeItemsPositions.hasOwnProperty(itemid)) {
          var treeItemPosition = _data.treeItemsPositions[itemid];
          if (_activeItems.hasOwnProperty(itemid)) {
            switch (treeItemPosition.actualVisibility) {
              case Visibility.Normal:
              case Visibility.Dot:
              case Visibility.Line:
                var rect = new Rect(treeItemPosition.actualPosition);
                rect.context = itemid;
                _spatialIndex.addRect(rect);
            }
          }
        }
      }
    }
    return _spatialIndex;
  }
  function getTreeItemForMousePosition(x, y, gravityRadius) {
    var result = null, bestDistance = null, spatialIndex = getSpatialIndex(), selection, center;
    selection = new Rect(x, y, 0, 0);
    center = new Point(x, y);
    selection.offset(gravityRadius, gravityRadius, gravityRadius, gravityRadius);
    spatialIndex.loopArea(this, selection, function(rect) {
      var itemid = rect.context;
      if (rect.contains(x, y)) {
        result = itemid;
        return true;
      }
      var treeItemPosition = _data.treeItemsPositions[itemid];
      switch (treeItemPosition.actualVisibility) {
        case Visibility.Dot:
        case Visibility.Line:
          var distance = center.distanceTo(rect.horizontalCenter(), rect.verticalCenter());
          if (bestDistance == null || distance < bestDistance) {
            bestDistance = distance;
            result = itemid;
          }
      }
    });
    return result;
  }
  function getKeyboardNavigationManager() {
    if (_keyboardNavigationManager == null) {
      _keyboardNavigationManager = KeyboardNavigationManager();
      for (var itemid in _data.treeItemsPositions) {
        if (_data.treeItemsPositions.hasOwnProperty(itemid)) {
          var treeItemPosition = _data.treeItemsPositions[itemid];
          if (_activeItems.hasOwnProperty(itemid)) {
            switch (treeItemPosition.actualVisibility) {
              case Visibility.Normal:
                var rect = new Rect(treeItemPosition.actualPosition);
                _keyboardNavigationManager.addRect(rect, itemid);
            }
          }
        }
      }
    }
    return _keyboardNavigationManager;
  }
  function getNextItem(cursorItem, direction) {
    var manager = getKeyboardNavigationManager(), result;
    switch (direction) {
      case OrientationType.Top:
        result = manager.getItemAbove(cursorItem);
        break;
      case OrientationType.Bottom:
        result = manager.getItemBelow(cursorItem);
        break;
      case OrientationType.Left:
        result = manager.getItemOnLeft(cursorItem);
        break;
      case OrientationType.Right:
        result = manager.getItemOnRight(cursorItem);
        break;
    }
    return result;
  }
  function getItemPosition(itemid) {
    return _data.treeItemsPositions[itemid];
  }
  function getItemsPositions() {
    return _data.treeItemsPositions;
  }
  function getContentSize() {
    return _data.panelSize;
  }
  return {
    process,
    getItemPosition,
    getItemsPositions,
    getContentSize,
    getTreeItemForMousePosition,
    getNextItem
  };
}

// node_modules/basicprimitives/src/graphics/Transform.js
function Transform() {
  this.invertArea = false;
  this.invertHorizontally = false;
  this.invertVertically = false;
  this.size = null;
}
Transform.prototype.setOrientation = function(orientationType) {
  switch (orientationType) {
    case OrientationType.Top:
      this.invertArea = false;
      this.invertHorizontally = false;
      this.invertVertically = false;
      break;
    case OrientationType.Bottom:
      this.invertArea = false;
      this.invertHorizontally = false;
      this.invertVertically = true;
      break;
    case OrientationType.Left:
      this.invertArea = true;
      this.invertHorizontally = false;
      this.invertVertically = false;
      break;
    case OrientationType.Right:
      this.invertArea = true;
      this.invertHorizontally = true;
      this.invertVertically = false;
      break;
  }
};
Transform.prototype.getOrientation = function(orientationType) {
  var result = orientationType;
  if (this.invertHorizontally) {
    switch (orientationType) {
      case OrientationType.Left:
        result = OrientationType.Right;
        break;
      case OrientationType.Right:
        result = OrientationType.Left;
        break;
    }
  }
  if (this.invertVertically) {
    switch (orientationType) {
      case OrientationType.Top:
        result = OrientationType.Bottom;
        break;
      case OrientationType.Bottom:
        result = OrientationType.Top;
        break;
    }
  }
  if (this.invertArea) {
    switch (result) {
      case OrientationType.Top:
        result = OrientationType.Left;
        break;
      case OrientationType.Bottom:
        result = OrientationType.Right;
        break;
      case OrientationType.Left:
        result = OrientationType.Top;
        break;
      case OrientationType.Right:
        result = OrientationType.Bottom;
        break;
    }
  }
  return result;
};
Transform.prototype.transformPoint = function(x, y, forward, self, func) {
  var value;
  if (forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
    }
  }
  if (this.invertHorizontally) {
    x = this.size.width - x;
  }
  if (this.invertVertically) {
    y = this.size.height - y;
  }
  if (!forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
    }
  }
  func.call(self, x, y);
};
Transform.prototype.transformPoints = function(x, y, x2, y2, forward, self, func) {
  var value;
  if (forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = x2;
      x2 = y2;
      y2 = value;
    }
  }
  if (this.invertHorizontally) {
    x = this.size.width - x;
    x2 = this.size.width - x2;
  }
  if (this.invertVertically) {
    y = this.size.height - y;
    y2 = this.size.height - y2;
  }
  if (!forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = x2;
      x2 = y2;
      y2 = value;
    }
  }
  func.call(self, x, y, x2, y2);
};
Transform.prototype.transform3Points = function(x, y, x2, y2, x3, y3, forward, self, func) {
  var value;
  if (forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = x2;
      x2 = y2;
      y2 = value;
      value = x3;
      x3 = y3;
      y3 = value;
    }
  }
  if (this.invertHorizontally) {
    x = this.size.width - x;
    x2 = this.size.width - x2;
    x3 = this.size.width - x3;
  }
  if (this.invertVertically) {
    y = this.size.height - y;
    y2 = this.size.height - y2;
    y3 = this.size.height - y3;
  }
  if (!forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = x2;
      x2 = y2;
      y2 = value;
      value = x3;
      x3 = y3;
      y3 = value;
    }
  }
  func.call(self, x, y, x2, y2, x3, y3);
};
Transform.prototype.transformRect = function(x, y, width, height, forward, self, func) {
  var value;
  if (forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = width;
      width = height;
      height = value;
    }
  }
  if (this.invertHorizontally) {
    x = this.size.width - x - width;
  }
  if (this.invertVertically) {
    y = this.size.height - y - height;
  }
  if (!forward) {
    if (this.invertArea) {
      value = x;
      x = y;
      y = value;
      value = width;
      width = height;
      height = value;
    }
  }
  func.call(self, x, y, width, height);
};
Transform.prototype.transformThickness = function(thickness, forward) {
  var value, { left, right, top, bottom } = thickness;
  if (forward) {
    if (this.invertArea) {
      value = left;
      left = top;
      top = value;
      value = right;
      right = bottom;
      bottom = value;
    }
  }
  if (this.invertHorizontally) {
    value = left;
    left = right;
    right = value;
  }
  if (this.invertVertically) {
    value = top;
    top = bottom;
    bottom = value;
  }
  if (!forward) {
    if (this.invertArea) {
      value = left;
      left = top;
      top = value;
      value = right;
      right = bottom;
      bottom = value;
    }
  }
  return new Thickness(left, top, right, bottom);
};

// node_modules/basicprimitives/src/tasks/layout/CreateTransformTask.js
function CreateTransformTask(orientationOptionTask, scaleOptionTask, alignDiagramTask) {
  var _data = {
    transform: null
  };
  function process() {
    var orientationOptions = orientationOptionTask.getOptions();
    var panelSize = new Size(alignDiagramTask.getContentSize());
    _data.transform = new Transform();
    _data.transform.setOrientation(orientationOptions.orientationType);
    _data.transform.size = new Size(panelSize);
    return true;
  }
  function getTreeItemForMousePosition(x, y, gravityRadius) {
    var result = null, { scale } = scaleOptionTask.getOptions();
    x = x / scale;
    y = y / scale;
    _data.transform.transformPoint(x, y, false, this, function(x2, y2) {
      result = alignDiagramTask.getTreeItemForMousePosition(x2, y2, gravityRadius);
    });
    return result;
  }
  function getTransform() {
    return _data.transform;
  }
  return {
    process,
    getTransform,
    getTreeItemForMousePosition,
    description: "Create coordinate system transformation object."
  };
}

// node_modules/basicprimitives/src/graphics/structs/PaletteManager.js
function PaletteManager(options, linesPalette) {
  this.palette = [];
  this.cursor = 0;
  var index, len;
  if (linesPalette.length === 0) {
    this.palette = [new PaletteItem({
      lineColor: options.linesColor,
      lineWidth: options.linesWidth,
      lineType: options.linesType
    })];
    this.paletteLength = this.palette.length;
    this.regularIndex = 0;
  } else {
    for (index = 0, len = linesPalette.length; index < len; index += 1) {
      this.palette.push(new PaletteItem(linesPalette[index]));
    }
    this.paletteLength = this.palette.length;
    this.palette.push(new PaletteItem({
      lineColor: options.linesColor,
      lineWidth: options.linesWidth,
      lineType: options.linesType
    }));
    this.regularIndex = this.palette.length - 1;
  }
  this.palette.push(new PaletteItem({
    lineColor: options.highlightLinesColor,
    lineWidth: options.highlightLinesWidth,
    lineType: options.highlightLinesType
  }));
  this.highlightIndex = this.palette.length - 1;
}
PaletteManager.prototype.selectPalette = function(index) {
  this.cursor = index % this.paletteLength;
};
PaletteManager.prototype.getPalette = function(connectorStyleType) {
  var index = null;
  switch (connectorStyleType) {
    case ConnectorStyleType.Regular:
      index = this.regularIndex;
      break;
    case ConnectorStyleType.Highlight:
      index = this.highlightIndex;
      break;
    case ConnectorStyleType.Extra:
      index = this.cursor;
      break;
  }
  return this.palette[index];
};

// node_modules/basicprimitives/src/tasks/transformations/PaletteManagerTask.js
function PaletteManagerTask(connectorsOptionTask, linePaletteOptionTask) {
  var _paletteManager;
  function process() {
    var linesPalette = [];
    if (linePaletteOptionTask != null) {
      linesPalette = linePaletteOptionTask.getOptions().linesPalette;
    }
    _paletteManager = new PaletteManager(connectorsOptionTask.getOptions(), linesPalette);
    return true;
  }
  function getPaletteManager() {
    return _paletteManager;
  }
  return {
    process,
    getPaletteManager
  };
}

// node_modules/basicprimitives/src/tasks/layout/ApplyLayoutChangesTask.js
function ApplyLayoutChangesTask(getGraphics, setLayout, itemsSizesOptionTask, currentControlSizeTask, scaleOptionTask, alignDiagramTask, frameSizeTask, levelTitleSizeTask) {
  var _data = {
    viewportSize: null,
    frameThickness: null,
    framePlaceholderSize: null
  };
  function process() {
    var graphics = getGraphics(), { scale } = scaleOptionTask.getOptions(), { pageFitMode, autoSizeMinimum, autoSizeMaximum } = itemsSizesOptionTask.getOptions(), placeholderSize = alignDiagramTask.getContentSize(), { scrollPanelSize, hasFrame, hasLevelTitles } = currentControlSizeTask.getOptions(), viewportSize = new Size(scrollPanelSize), frameThickness = frameSizeTask.getThickness(), titlesThickness = new Thickness(levelTitleSizeTask.getOptions().thickness), autoSize = pageFitMode == PageFitMode.AutoSize;
    var mousePanelSize = new Size(placeholderSize);
    mousePanelSize.scale(scale);
    if (autoSize) {
      viewportSize = new Size(mousePanelSize.width + 25, mousePanelSize.height + 25);
      viewportSize.addThickness(frameThickness);
      if (titlesThickness.isPositive()) {
        viewportSize.addThickness(titlesThickness);
      }
      viewportSize.cropBySize(autoSizeMaximum);
      viewportSize.maxSize(autoSizeMinimum);
      var framedViewportSize = new Size(viewportSize);
      framedViewportSize.removeThickness(frameThickness);
      if (titlesThickness.isPositive()) {
        framedViewportSize.removeThickness(titlesThickness);
      }
      if (viewportSize.space() < framedViewportSize.space() * 2) {
        viewportSize = framedViewportSize;
      } else {
        frameThickness = new Thickness(0, 0, 0, 0);
        titlesThickness = new Thickness(0, 0, 0, 0);
      }
    } else {
      if (!hasFrame) {
        frameThickness = new Thickness(0, 0, 0, 0);
      }
      if (!hasLevelTitles && titlesThickness.isPositive()) {
        titlesThickness = new Thickness(0, 0, 0, 0);
      }
    }
    var decorThickness = new Thickness(frameThickness);
    if (titlesThickness.isPositive()) {
      decorThickness.addThickness(titlesThickness);
    }
    var controlSize = new Size(viewportSize);
    controlSize.addThickness(decorThickness);
    var scrollPanelRect = new Rect(decorThickness.left, decorThickness.top, viewportSize.width, viewportSize.height);
    var framePlaceholderSize = new Size(controlSize);
    var frameMousePanelRect = new Rect(0, 0, framePlaceholderSize.width, framePlaceholderSize.height);
    framePlaceholderSize.scale(1 / scale);
    var firstPoint = new Point(0, 0), secondPoint = new Point(0, 0);
    if (titlesThickness.left != 0) {
      firstPoint = new Point(scrollPanelRect.x, scrollPanelRect.y);
      secondPoint = new Point(scrollPanelRect.x - titlesThickness.left, scrollPanelRect.bottom());
    } else if (titlesThickness.right != 0) {
      firstPoint = new Point(scrollPanelRect.right(), scrollPanelRect.y);
      secondPoint = new Point(scrollPanelRect.right() + titlesThickness.right, scrollPanelRect.bottom());
    } else if (titlesThickness.top != 0) {
      firstPoint = new Point(scrollPanelRect.x, scrollPanelRect.y);
      secondPoint = new Point(scrollPanelRect.right(), scrollPanelRect.y - titlesThickness.top);
    } else if (titlesThickness.bottom != 0) {
      firstPoint = new Point(scrollPanelRect.x, scrollPanelRect.bottom());
      secondPoint = new Point(scrollPanelRect.right(), scrollPanelRect.bottom() + titlesThickness.bottom);
    }
    var titlesMousePanelRect = new Rect(firstPoint, secondPoint);
    var titlesPlaceholderSize = new Size(titlesMousePanelRect);
    titlesPlaceholderSize.scale(1 / scale);
    graphics.resize("frameplaceholder", framePlaceholderSize.width, framePlaceholderSize.height);
    graphics.resize("titlesplaceholder", titlesPlaceholderSize.width, titlesPlaceholderSize.height);
    graphics.resize("placeholder", placeholderSize.width, placeholderSize.height);
    setLayout({
      autoSize,
      // resize control if true
      controlSize,
      // Sets control Size in auto scale mode
      scale,
      // scale is needed for scale transform CSS creation
      frameMousePanelRect,
      framePlaceholderSize,
      // the frame content size before CSS Scale Transform applied
      titlesMousePanelRect,
      titlesPlaceholderSize,
      // Titles size before CSS Scale Transform applied
      scrollPanelRect,
      mousePanelSize,
      // Content mouse panel size
      placeholderSize
      // Content size before CSS Scale Transform applied
    });
    _data.viewportSize = viewportSize;
    _data.frameThickness = frameThickness;
    _data.frameOffset = titlesThickness.isPositive() ? titlesThickness : new Thickness(0, 0, 0, 0);
    _data.titlesThickness = titlesThickness;
    _data.framePlaceholderSize = framePlaceholderSize;
    return true;
  }
  function getOptimalPanelSize() {
    return new Size(_data.viewportSize.width - 25, _data.viewportSize.height - 25);
  }
  function getScrollPanelSize() {
    return new Size(_data.viewportSize.width, _data.viewportSize.height);
  }
  function getFrameThickness() {
    return new Thickness(_data.frameThickness);
  }
  function getFrameOffset() {
    return new Thickness(_data.frameOffset);
  }
  function getTitlesThickness() {
    return new Thickness(_data.titlesThickness);
  }
  return {
    process,
    getOptimalPanelSize,
    getScrollPanelSize,
    getFrameThickness,
    getFrameOffset,
    getTitlesThickness
  };
}

// node_modules/basicprimitives/src/tasks/layout/CenterOnCursorTask.js
function CenterOnCursorTask(layoutOptionsTask, applyLayoutChangesTask, currentScrollPositionTask, cursorItemTask, alignDiagramTask, createTransformTask, scaleOptionTask) {
  var _data = {
    placeholderOffset: null
  }, _transform;
  function process() {
    var snapRect, layoutOptions = layoutOptionsTask.getOptions(), cursorTreeItemId = cursorItemTask.getCursorTreeItem(), treeItemPosition = alignDiagramTask.getItemPosition(cursorTreeItemId), contentSize = new Size(alignDiagramTask.getContentSize()), scrollPanelSize, scaleOptions = scaleOptionTask.getOptions(), scale = scaleOptions.scale;
    _data.placeholderOffset = currentScrollPositionTask.getPlaceholderOffset();
    if (layoutOptions.forceCenterOnCursor) {
      _transform = createTransformTask.getTransform();
      if (treeItemPosition != null) {
        snapRect = getTransformedItemPosition(treeItemPosition.actualPosition);
        snapRect.scale(scale);
        contentSize.scale(scale);
        scrollPanelSize = applyLayoutChangesTask.getScrollPanelSize();
        _data.placeholderOffset = new Point(
          Math.max(Math.min(snapRect.horizontalCenter() - scrollPanelSize.width / 2, contentSize.width - scrollPanelSize.width), 0),
          Math.max(Math.min(snapRect.verticalCenter() - scrollPanelSize.height / 2, contentSize.height - scrollPanelSize.height), 0)
        );
      }
    }
    return true;
  }
  function getTransformedItemPosition(position) {
    var result = false;
    _transform.transformRect(
      position.x,
      position.y,
      position.width,
      position.height,
      true,
      this,
      function(x, y, width, height) {
        result = new Rect(x, y, width, height);
      }
    );
    return result;
  }
  function getPlaceholderOffset() {
    return _data.placeholderOffset;
  }
  return {
    process,
    getPlaceholderOffset
  };
}

// node_modules/basicprimitives/src/tasks/layout/ProjectItemsToFrameTask.js
function ProjectItemsToFrameTask(createTransformTask, frameSizeTask, applyLayoutChangesTask, scaleOptionTask, alignDiagramTask, centerOnCursorTask, itemTemplateParamsTask, selectedItemsTask) {
  var _data = {
    positions: {}
  }, _scaleOptions, _spatialIndex;
  function process() {
    var positions = alignDiagramTask.getItemsPositions(), transform = createTransformTask.getTransform();
    _scaleOptions = scaleOptionTask.getOptions(), _spatialIndex = null;
    _data.positions = [];
    var medianPosition = getFrameMedianPosition(), selectedItems = selectedItemsTask.getItems();
    if (medianPosition != null) {
      for (var index = 0, len = selectedItems.length; index < len; index += 1) {
        var treeItemId = selectedItems[index], treeItemPosition = positions[treeItemId], actualPosition = treeItemPosition.actualPosition;
        transform.transformRect(
          actualPosition.x,
          actualPosition.y,
          actualPosition.width,
          actualPosition.height,
          true,
          this,
          function(x, y, width, height) {
            var nodePosition = new Rect(x, y, width, height);
            if (!medianPosition.rect.overlaps(nodePosition)) {
              var projectionPoint = medianPosition.rect.getProjectionPoint(nodePosition.centerPoint());
              if (projectionPoint != null) {
                var templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId), templateConfig = templateParams.template.templateConfig, markerSize = new Size(templateConfig.minimizedItemSize), markerProjectionRect = new Rect(
                  projectionPoint.x - markerSize.width / 2,
                  projectionPoint.y - markerSize.height / 2,
                  markerSize.width,
                  markerSize.height
                );
                markerProjectionRect.translate(-medianPosition.offset.x, -medianPosition.offset.y);
                _data.positions[treeItemId] = markerProjectionRect;
              }
            }
          }
        );
      }
    }
    return true;
  }
  function getFrameMedianPosition() {
    var result = null;
    if (centerOnCursorTask != null) {
      var scale = _scaleOptions.scale, placeholderOffset = new Point(centerOnCursorTask.getPlaceholderOffset()), scrollPanelSize = new Size(applyLayoutChangesTask.getScrollPanelSize()), frameThickness = new Thickness(applyLayoutChangesTask.getFrameThickness()), frameBaseOffset = new Thickness(applyLayoutChangesTask.getFrameOffset()), medianThickness = new Thickness(frameSizeTask.getMedian());
      if (!frameThickness.isEmpty()) {
        placeholderOffset.scale(1 / scale);
        frameThickness.scale(1 / scale);
        frameBaseOffset.scale(1 / scale);
        scrollPanelSize.scale(1 / scale);
        medianThickness.scale(1 / scale);
        var frameOffset = new Point(placeholderOffset.x - frameBaseOffset.left - frameThickness.left, placeholderOffset.y - frameBaseOffset.top - frameThickness.top);
        var medianRect = new Rect(placeholderOffset.x, placeholderOffset.y, scrollPanelSize.width, scrollPanelSize.height);
        medianRect.offset(frameBaseOffset);
        medianRect.offset(medianThickness);
        result = {
          offset: frameOffset,
          rect: medianRect
        };
      }
    }
    return result;
  }
  function getSizes() {
    var result = [];
    var hash = {};
    for (var treeItemId in _data.positions) {
      if (_data.positions.hasOwnProperty(treeItemId)) {
        var rect = _data.positions[treeItemId];
        var size = Math.max(rect.width, rect.height);
        if (!hash.hasOwnProperty(size)) {
          hash[size] = true;
          result.push(size);
        }
      }
    }
    return result;
  }
  function getSpatialIndex() {
    if (_spatialIndex == null) {
      _spatialIndex = SpatialIndex(getSizes());
      for (var treeItemId in _data.positions) {
        if (_data.positions.hasOwnProperty(treeItemId)) {
          var rect = _data.positions[treeItemId];
          rect.context = treeItemId;
          _spatialIndex.addRect(rect);
        }
      }
    }
    return _spatialIndex;
  }
  function getTreeItemForMousePosition(x, y, gravityRadius) {
    var result = null, bestDistance = null, scale = _scaleOptions.scale, spatialIndex = getSpatialIndex(), selection, center;
    x = x / scale;
    y = y / scale;
    selection = new Rect(x, y, 0, 0);
    center = new Point(x, y);
    selection.offset(gravityRadius, gravityRadius, gravityRadius, gravityRadius);
    spatialIndex.loopArea(this, selection, function(rect) {
      var itemid = rect.context;
      var distance = center.distanceTo(rect.horizontalCenter(), rect.verticalCenter());
      if (bestDistance == null || distance < bestDistance) {
        bestDistance = distance;
        result = itemid;
      }
    });
    return result;
  }
  function getPositions() {
    return _data.positions;
  }
  return {
    getPositions,
    getTreeItemForMousePosition,
    process
  };
}

// node_modules/basicprimitives/src/tasks/layout/ViewPortPlacementTask.js
function ViewPortPlacementTask(scaleOptionTask, centerOnCursorTask, createTransformTask, applyLayoutChangesTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    viewPortPosition: new ObjectReader({
      x: new ValueReader(["number"], false, 0),
      y: new ValueReader(["number"], false, 0),
      width: new ValueReader(["number"], false, 0),
      height: new ValueReader(["number"], false, 0)
    }, false, new Rect(0, 0, 0, 0))
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, getTransformedPosition(), "options", context);
    return context.isChanged;
  }
  function getTransformedPosition() {
    var viewPortPosition, transform = createTransformTask.getTransform(), position = getPosition();
    if (position != null) {
      transform.transformRect(
        position.x,
        position.y,
        position.width,
        position.height,
        false,
        this,
        function(x, y, width, height) {
          viewPortPosition = new Rect(x, y, width, height);
        }
      );
    }
    return { viewPortPosition };
  }
  function getPosition() {
    var scaleOptions = scaleOptionTask.getOptions(), scale = scaleOptions.scale, placeholderOffset = centerOnCursorTask ? new Point(centerOnCursorTask.getPlaceholderOffset()) : new Point(0, 0), optimalPanelSize = new Size(applyLayoutChangesTask.getOptimalPanelSize());
    placeholderOffset.scale(1 / scale);
    optimalPanelSize.scale(1 / scale);
    var result = new Rect(
      placeholderOffset.x,
      placeholderOffset.y,
      optimalPanelSize.width,
      optimalPanelSize.height
    );
    return result;
  }
  function getViewPortPosition() {
    return _data.viewPortPosition;
  }
  return {
    process,
    getViewPortPosition
  };
}

// node_modules/basicprimitives/src/tasks/layout/VerticalOffsetTask.js
function VerticalOffsetTask(viewPortPlacementTask) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    verticalOffset: new ObjectReader({
      from: new ValueReader(["number"], false, 0),
      to: new ValueReader(["number"], false, 0)
    }, false, new Interval(0, 0))
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, getOffset(), "options", context);
    return context.isChanged;
  }
  function getOffset() {
    var viewPortPosition = new Rect(viewPortPlacementTask.getViewPortPosition());
    return { verticalOffset: viewPortPosition.verticalInterval() };
  }
  function getVerticalOffset() {
    return _data.verticalOffset;
  }
  return {
    process,
    getVerticalOffset
  };
}

// node_modules/basicprimitives/src/tasks/layout/OrgLogicalLevelsPlacementTask.js
function OrgLogicalLevelsPlacementTask(orgTreeTask, visualTreeTask, alignDiagramTask) {
  var _data = {
    positions: []
  };
  function process() {
    _data.positions = null;
    return true;
  }
  function createPositions() {
    var intervals = [], orgTree = orgTreeTask.getOrgTree(), itemsPositions = alignDiagramTask.getItemsPositions(), branchAligner = visualTreeTask.getBranchAligner(), visited = {};
    orgTree.loopLevels(this, function(nodeId, node, levelIndex2) {
      if (node.itemType == ItemType.Regular) {
        if (node.isVisible) {
          var itemPosition = itemsPositions[nodeId];
          if (itemPosition) {
            var levelOffset = node.levelOffset;
            if (levelOffset === null) {
              levelOffset = branchAligner.getGroupSize(node.parent, GroupType.RowChildren);
            }
            var interval2 = new Interval(itemPosition.topConnectorShift, itemPosition.bottomConnectorShift - 1, levelIndex2 + levelOffset);
            var key = interval2.toString();
            if (!visited[key]) {
              visited[key] = true;
              intervals.push(interval2);
            }
          }
        }
        return;
      }
      return orgTree.SKIP;
    });
    var mergedIntervals = [];
    getMergedIntervals(this, intervals, function(interval2) {
      mergedIntervals.push(interval2);
    });
    intervals = mergedIntervals;
    mergedIntervals = [];
    var currentInterval = null;
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      if (!currentInterval) {
        currentInterval = interval;
        mergedIntervals.push(interval);
      } else {
        if (currentInterval.context === interval.context) {
          currentInterval.to = interval.to;
        } else {
          currentInterval = interval;
          mergedIntervals.push(interval);
        }
      }
    }
    intervals = mergedIntervals;
    if (intervals.length > 0) {
      intervals[0].from = 0;
    }
    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {
      var prev = intervals[index];
      var next = intervals[index + 1];
      prev.to = next.from;
    }
    var minLevelIndex = null;
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);
    }
    var result = {};
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      var levelIndex = interval.context - minLevelIndex;
      var logicalLevelPosition = result[levelIndex];
      if (!logicalLevelPosition) {
        result[levelIndex] = [interval];
      } else {
        logicalLevelPosition.push(interval);
      }
    }
    return result;
  }
  function getPositions() {
    if (!_data.positions) {
      _data.positions = createPositions();
    }
    return _data.positions;
  }
  return {
    getPositions,
    process
  };
}

// node_modules/basicprimitives/src/tasks/layout/MergeLevelIntervalsTask.js
function MergeLevelIntervalsTask(levelAnnotationOptionTask, logicalLevelsPlacementTask) {
  var _data = {
    positions: []
  };
  function process() {
    var annotations = levelAnnotationOptionTask.getAnnotations();
    _data.positions = [];
    if (annotations.length > 0) {
      var positions = logicalLevelsPlacementTask.getPositions();
      _data.positions = createPositions(annotations, positions);
    }
    return true;
  }
  function createPositions(annotations, positions) {
    var index, len, index2, len2, used = {}, result = {};
    for (index = 0, len = annotations.length; index < len; index += 1) {
      var annotationConfig = annotations[index];
      var levels = annotationConfig.levels;
      var intervals = [];
      if (levels != null && levels.length > 0) {
        for (index2 = 0, len2 = levels.length; index2 < len2; index2 += 1) {
          var level = levels[index2];
          if (!used[level]) {
            used[level] = true;
            var intervals = [];
            if (positions[level] != null) {
              intervals = intervals.concat(positions[level]);
            }
          }
        }
      }
      result[index] = [];
      getMergedIntervals(this, intervals, function(interval) {
        result[index].push(interval);
      });
    }
    return result;
  }
  function getPositions() {
    return _data.positions;
  }
  return {
    getPositions,
    process
  };
}

// node_modules/basicprimitives/src/graphics/shapes/BaseShape.js
function BaseShape() {
}
BaseShape.prototype._getLabelPosition = function(x, y, width, height, labelWidth, labelHeight, labelOffset, labelPlacement) {
  var result = null;
  switch (labelPlacement) {
    case PlacementType.Top:
      result = new Rect(x + width / 2 - labelWidth / 2, y - labelOffset - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.TopRight:
      result = new Rect(x + width - labelWidth, y - labelOffset - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.TopLeft:
      result = new Rect(x, y - labelOffset - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.Right:
      result = new Rect(x + width + labelOffset, y + height / 2 - labelHeight / 2, labelWidth, labelHeight);
      break;
    case PlacementType.RightTop:
      result = new Rect(x + width + labelOffset, y, labelWidth, labelHeight);
      break;
    case PlacementType.RightBottom:
      result = new Rect(x + width + labelOffset, y + height - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.BottomRight:
      result = new Rect(x + width - labelWidth, y + height + labelOffset, labelWidth, labelHeight);
      break;
    case PlacementType.BottomLeft:
      result = new Rect(x, y + height + labelOffset, labelWidth, labelHeight);
      break;
    case PlacementType.Left:
      result = new Rect(x - labelWidth - labelOffset, y + height / 2 - labelHeight / 2, labelWidth, labelHeight);
      break;
    case PlacementType.LeftTop:
      result = new Rect(x - labelWidth - labelOffset, y, labelWidth, labelHeight);
      break;
    case PlacementType.LeftBottom:
      result = new Rect(x - labelWidth - labelOffset, y + height - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.Auto:
    case PlacementType.Bottom:
    default:
      result = new Rect(x + width / 2 - labelWidth / 2, y + height + labelOffset, labelWidth, labelHeight);
      break;
  }
  return result;
};
BaseShape.prototype._betweenPoint = function(first, second) {
  return new Point((first.x + second.x) / 2, (first.y + second.y) / 2);
};
BaseShape.prototype._offsetPoint = function(first, second, offset) {
  var result = null, distance = first.distanceTo(second);
  if (distance === 0 || offset === 0) {
    result = new Point(first);
  } else {
    result = new Point(first.x + (second.x - first.x) / distance * offset, first.y + (second.y - first.y) / distance * offset);
  }
  return result;
};

// node_modules/basicprimitives/src/graphics/shapes/MergedRectangles.js
function MergedRectangles(graphics) {
  this.graphics = graphics;
  this.transform = null;
  this.lineWidth = 1;
  this.opacity = 1;
  this.fillColor = null;
  this.lineType = LineType.Solid;
  this.borderColor = null;
}
MergedRectangles.prototype = new BaseShape();
MergedRectangles.prototype.draw = function(rects) {
  var paletteItem = new PaletteItem({
    lineColor: this.borderColor,
    lineWidth: this.lineWidth,
    fillColor: this.fillColor,
    lineType: this.lineType,
    opacity: this.opacity
  }), polyline = new Polyline(paletteItem);
  getMergedRectangles(this, rects, function(points) {
    for (var index = 0, len = points.length; index < len; index += 1) {
      var point = points[index];
      if (index == 0) {
        polyline.addSegment(new MoveSegment(point.x, point.y));
      } else {
        polyline.addSegment(new LineSegment(point.x, point.y));
      }
    }
  });
  polyline.transform(this.transform, true);
  this.graphics.polyline(polyline);
};

// node_modules/basicprimitives/src/tasks/renders/DrawBackgroundAnnotationTask.js
function DrawBackgroundAnnotationTask(getGraphics, createTransformTask, applyLayoutChangesTask, backgroundAnnotationOptionTask, navigationFamilyTask, alignDiagramTask) {
  var _graphics, _positions, _transform;
  function process() {
    var annotations = backgroundAnnotationOptionTask.getAnnotations(), navigationFamily;
    _graphics = getGraphics();
    _graphics.reset("placeholder", Layers.BackgroundAnnotation);
    if (annotations.length > 0) {
      _positions = alignDiagramTask.getItemsPositions();
      _transform = createTransformTask.getTransform();
      navigationFamily = navigationFamilyTask.getLogicalFamily();
      drawAnnotations(annotations, _positions, navigationFamily);
    }
    return false;
  }
  function drawAnnotations(annotations, positions, navigationFamily) {
    var panel, index, len, index2, len2, index3, len3, shape, defaultConfig, rects, rect, itemsHash, item, properties, property, annotationConfig, treeItemPosition;
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotationConfig = annotations[index];
      if (annotationConfig.items != null && annotationConfig.items.length > 0) {
        shape = new MergedRectangles(_graphics);
        shape.transform = _transform;
        defaultConfig = new BackgroundAnnotationConfig();
        properties = ["opacity", "lineWidth", "borderColor", "fillColor", "lineType"];
        for (index3 = 0, len3 = properties.length; index3 < len3; index3 += 1) {
          property = properties[index3];
          shape[property] = annotationConfig.hasOwnProperty(property) ? annotationConfig[property] : defaultConfig[property];
        }
        panel = _graphics.activate("placeholder", Layers.BackgroundAnnotation);
        rects = [];
        itemsHash = {};
        for (index2 = 0, len2 = annotationConfig.items.length; index2 < len2; index2 += 1) {
          item = annotationConfig.items[index2];
          treeItemPosition = alignDiagramTask.getItemPosition(item);
          if (treeItemPosition != null) {
            itemsHash[item] = true;
            rect = new Rect(treeItemPosition.actualPosition);
            rect.offset(annotationConfig.offset);
            rects.push(rect);
            if (annotationConfig.includeChildren) {
              navigationFamily.loopChildren(this, item, function(childItemId, childItem) {
                if (!itemsHash[childItemId]) {
                  itemsHash[childItemId] = true;
                  treeItemPosition = alignDiagramTask.getItemPosition(childItemId);
                  if (treeItemPosition != null) {
                    rect = new Rect(treeItemPosition.actualPosition);
                    rect.offset(annotationConfig.offset);
                    rects.push(rect);
                  }
                }
              });
            }
          }
        }
        shape.draw(rects);
      }
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/graphics/structs/PolylinesBuffer.js
function PolylinesBuffer() {
  var polylines = {};
  function _getPolyline(polylines2, paletteItem) {
    if (!polylines2[paletteItem.toString()]) {
      polylines2[paletteItem.toString()] = new Polyline(paletteItem);
    }
    return polylines2[paletteItem.toString()];
  }
  function getPolyline(paletteItem) {
    return _getPolyline(polylines, paletteItem);
  }
  function loop2(thisArg, onItem) {
    var key, polyline;
    if (onItem != null) {
      for (key in polylines) {
        if (polylines.hasOwnProperty(key)) {
          polyline = polylines[key];
          if (polyline) {
            polyline.optimizeMoveSegments();
            if (onItem.call(thisArg, polyline)) {
              break;
            }
          }
        }
      }
    }
  }
  function addInverted(callbackFun, copyOnly) {
    var backupPolylines, backupPolyline;
    backupPolylines = polylines;
    polylines = {};
    if (callbackFun != null) {
      callbackFun(this);
    }
    loop2(this, function(polyline) {
      backupPolyline = _getPolyline(backupPolylines, polyline.paletteItem);
      if (!copyOnly) {
        backupPolyline.addInverted(polyline);
      } else {
        polyline.mergeTo(backupPolyline);
      }
    });
    polylines = backupPolylines;
  }
  function transform(transformArg, forward) {
    loop2(this, function(polyline) {
      polyline.transform(transformArg, forward);
    });
  }
  return {
    getPolyline,
    loop: loop2,
    addInverted,
    transform
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawHighlightPathAnnotationTask.js
function DrawHighlightPathAnnotationTask(getGraphics, connectorsOptionTask, highlightPathAnnotationOptionTask, connectionsGraphTask, zOrderType) {
  function process() {
    var graph = connectionsGraphTask.getGraph(), highlightOptions = connectorsOptionTask.getOptions(), annotations = highlightPathAnnotationOptionTask.getAnnotations(), graphics = getGraphics();
    switch (zOrderType) {
      case ZOrderType.Background:
        graphics.reset("placeholder", Layers.BackgroundHighlightPathAnnotations);
        break;
      case ZOrderType.Foreground:
        graphics.reset("placeholder", Layers.ForegroundHighlightPathAnnotations);
        break;
    }
    drawAnnotations(graphics, highlightOptions, annotations, graph);
    return false;
  }
  function drawAnnotations(graphics, highlightOptions, annotations, graph) {
    var index, len, index2, len2, index3, len3, firstItemId, nextItemId, treeItem, path, items, connectorEdge, annotationConfig, panel, buffer, from, to;
    if (annotations.length > 0) {
      buffer = new PolylinesBuffer();
      switch (zOrderType) {
        case ZOrderType.Background:
          panel = graphics.activate("placeholder", Layers.BackgroundHighlightPathAnnotations);
          break;
        case ZOrderType.Foreground:
          panel = graphics.activate("placeholder", Layers.ForegroundHighlightPathAnnotations);
          break;
      }
      var pairs = {};
      for (index = 0, len = annotations.length; index < len; index += 1) {
        annotationConfig = annotations[index];
        if (annotationConfig.items != null && annotationConfig.items.length > 0) {
          items = annotationConfig.items.slice(0);
          firstItemId = items[0];
          if (graph.hasNode(firstItemId)) {
            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {
              nextItemId = items[index2];
              if (graph.hasNode(nextItemId)) {
                if (pairs.hasOwnProperty(firstItemId)) {
                  pairs[firstItemId].push(nextItemId);
                } else {
                  pairs[firstItemId] = [nextItemId];
                }
                firstItemId = nextItemId;
              }
            }
          }
        }
      }
      var paths = {};
      for (from in pairs) {
        paths[from] = {};
        if (pairs.hasOwnProperty(from)) {
          graph.getShortestPath(this, from, pairs[from], function(connectorEdge2, fromItem, toItem) {
            return connectorEdge2.weight;
          }, function(path2, to2) {
            paths[from][to2] = path2;
          });
        }
      }
      for (index = 0, len = annotations.length; index < len; index += 1) {
        annotationConfig = annotations[index];
        var paletteItem = new PaletteItem({
          lineColor: annotationConfig.color != null ? annotationConfig.color : highlightOptions.highlightLinesColor,
          lineWidth: annotationConfig.lineWidth != null ? annotationConfig.lineWidth : highlightOptions.highlightLinesWidth,
          lineType: annotationConfig.lineType != null ? annotationConfig.lineType : highlightOptions.highlightLinesType,
          fillColor: null,
          opacity: annotationConfig.opacity
        });
        var polyline = buffer.getPolyline(paletteItem);
        if (annotationConfig.items != null && annotationConfig.items.length > 0) {
          items = annotationConfig.items.slice(0);
          firstItemId = items[0];
          if (graph.hasNode(firstItemId)) {
            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {
              nextItemId = items[index2];
              if (graph.hasNode(nextItemId)) {
                path = paths[firstItemId][nextItemId] || [];
                for (index3 = path.length - 2; index3 >= 0; index3 -= 1) {
                  from = path[index3 + 1];
                  to = path[index3];
                  connectorEdge = graph.edge(from, to);
                  if (connectorEdge.from == from) {
                    connectorEdge.polyline.clone().mergeTo(polyline);
                  } else {
                    polyline.addInverted(connectorEdge.polyline.clone());
                  }
                  if (annotationConfig.showArrows) {
                    if (to == connectorEdge.parentsArrowId || to == connectorEdge.childrenArrowId) {
                      polyline.addArrow(annotationConfig.lineWidth, function(arrowPolyline) {
                        arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));
                      });
                    }
                  }
                }
                firstItemId = nextItemId;
              }
            }
          }
        }
      }
      graphics.polylinesBuffer(buffer);
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/events/RenderEventArgs.js
function RenderEventArgs() {
  this.id = null;
  this.element = null;
  this.context = null;
  this.templateName = null;
  this.renderingMode = null;
  this.isCursor = false;
  this.isSelected = false;
}

// node_modules/basicprimitives/src/tasks/renders/offsetResolver/CollinearVectorBundle.js
function CollinearVectorBundle() {
  var _boundingRect = new Rect(), _vectors = [], _continuations = [];
  function addVector(vector, continuation) {
    _vectors.push(vector);
    _continuations.push(continuation);
    _boundingRect.addRect(vector.from.x, vector.from.y);
    _boundingRect.addRect(vector.to.x, vector.to.y);
  }
  function loopProjections(callback) {
    var index, len, vector;
    if (_boundingRect.width > _boundingRect.height) {
      for (index = 0, len = _vectors.length; index < len; index += 1) {
        vector = _vectors[index];
        callback(vector.from.x, vector.to.x, _continuations[index]);
      }
    } else {
      for (index = 0, len = _vectors.length; index < len; index += 1) {
        vector = _vectors[index];
        callback(vector.from.y, vector.to.y, _continuations[index]);
      }
    }
  }
  function resolve() {
    if (_vectors.length == 1) {
      _continuations[0](0, 1, 1);
    } else {
      var stackSegments = Pile();
      loopProjections(function(from, to, continuation) {
        stackSegments.add(from, to, continuation);
      });
      var totalOffset = stackSegments.resolve(this, function(from, to, context, offset, bundleSize, direction) {
        context(offset, bundleSize, direction);
      });
    }
  }
  return {
    addVector,
    resolve
  };
}

// node_modules/basicprimitives/src/tasks/renders/offsetResolver/ConnectorAnnotationOffsetResolver.js
function ConnectorAnnotationOffsetResolver() {
  var _bundles = {};
  function getOffset(vector, callback) {
    var key = vector.getLineKey();
    if (!_bundles.hasOwnProperty(key)) {
      _bundles[key] = new CollinearVectorBundle();
    }
    _bundles[key].addVector(vector, callback);
  }
  function resolve() {
    for (var key in _bundles) {
      if (_bundles.hasOwnProperty(key)) {
        var bundle = _bundles[key];
        bundle.resolve();
      }
    }
  }
  return {
    getOffset,
    resolve
  };
}

// node_modules/basicprimitives/src/graphics/shapes/ConnectorStraight.js
function ConnectorStraight() {
}
ConnectorStraight.prototype = new BaseShape();
ConnectorStraight.prototype.draw = function(buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {
  var fromPoint, toPoint, betweenPoint, vector, newVector, offset = linesOffset / 2, labelPlacement = null, fromLabelPlacement = PlacementType.Auto, toLabelPlacement = PlacementType.Auto, self = this;
  vector = new Vector(fromRect.centerPoint(), toRect.centerPoint());
  fromRect.loopEdges(function(sideVector, placementType) {
    fromPoint = sideVector.getIntersectionPoint(vector, true, 1);
    fromLabelPlacement = placementType;
    return fromPoint != null;
  });
  toRect.loopEdges(function(sideVector, placementType) {
    toPoint = sideVector.getIntersectionPoint(vector, true, 1);
    toLabelPlacement = placementType;
    return toPoint != null;
  });
  if (fromPoint != null && toPoint != null) {
    var baseVector = new Vector(fromPoint, toPoint);
    connectorAnnotationOffsetResolver.getOffset(baseVector, function(offsetIndex, bundleSize, direction) {
      var tempOffset = (offsetIndex * bundleOffset - (bundleSize - 1) * bundleOffset / 2) * direction;
      baseVector.offset(tempOffset);
      fromPoint = baseVector.from;
      toPoint = baseVector.to;
      switch (connectorShapeType) {
        case ConnectorShapeType.TwoWay:
          newVector = new Vector(toPoint.clone(), fromPoint.clone());
          newVector.offset(offset);
          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);
          newVector = new Vector(fromPoint.clone(), toPoint.clone());
          newVector.offset(offset);
          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);
          break;
        case ConnectorShapeType.OneWay:
          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, false);
          break;
        case ConnectorShapeType.BothWay:
          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, true);
          break;
      }
      if (hasLabel) {
        switch (labelPlacementType) {
          case ConnectorLabelPlacementType.From:
            labelPlacement = self._getLabelPositionBySnapPoint(fromPoint.x, fromPoint.y, labelSize.width, labelSize.height, labelOffset, fromLabelPlacement);
            break;
          case ConnectorLabelPlacementType.Between:
            betweenPoint = self._betweenPoint(fromPoint, toPoint);
            labelPlacement = self._getLabelPositionBySnapPoint(betweenPoint.x, betweenPoint.y, labelSize.width, labelSize.height, labelOffset, PlacementType.Right);
            break;
          case ConnectorLabelPlacementType.To:
            labelPlacement = self._getLabelPositionBySnapPoint(toPoint.x, toPoint.y, labelSize.width, labelSize.height, labelOffset, toLabelPlacement);
            break;
          default:
            break;
        }
        if (onLabelPlacement != null) {
          onLabelPlacement.call(this, labelPlacement, labelConfig);
        }
      }
    });
  }
};
ConnectorStraight.prototype._drawLine = function(buffer, linePaletteItem, fromPoint, toPoint, bothWays) {
  var polyline;
  buffer.addInverted(function(invertedBuffer) {
    polyline = invertedBuffer.getPolyline(linePaletteItem);
    polyline.addSegment(new MoveSegment(fromPoint));
    polyline.addSegment(new LineSegment(toPoint));
    polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
      polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
    });
  }, false);
  if (bothWays) {
    polyline = buffer.getPolyline(linePaletteItem);
    polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
      polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
    });
  }
};
ConnectorStraight.prototype._getLabelPositionBySnapPoint = function(x, y, labelWidth, labelHeight, labelOffset, placementType) {
  var result = null;
  switch (placementType) {
    case PlacementType.Auto:
    case PlacementType.Top:
      result = new Rect(x - labelWidth / 2, y - labelOffset - labelHeight, labelWidth, labelHeight);
      break;
    case PlacementType.Right:
      result = new Rect(x + labelOffset, y - labelHeight / 2, labelWidth, labelHeight);
      break;
    case PlacementType.Bottom:
      result = new Rect(x - labelWidth / 2, y + labelOffset, labelWidth, labelHeight);
      break;
    case PlacementType.Left:
      result = new Rect(x - labelWidth - labelOffset, y - labelHeight / 2, labelWidth, labelHeight);
      break;
  }
  return result;
};

// node_modules/basicprimitives/src/graphics/shapes/ConnectorOffbeat.js
function ConnectorOffbeat() {
}
ConnectorOffbeat.prototype = new BaseShape();
ConnectorOffbeat.prototype.draw = function(buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {
  var minimalGap, connectorRect, fromPoint, toPoint, snapPoint, index, len, offsets, tempOffset, invertX, invertY, fromLabelPlacement = PlacementType.Auto, toLabelPlacement = PlacementType.Auto, labelPlacement = null, polyline, bothWay;
  polyline = buffer.getPolyline(linePaletteItem);
  offsets = [];
  switch (connectorShapeType) {
    case ConnectorShapeType.TwoWay:
      offsets = [-linesOffset / 2, linesOffset / 2];
      bothWay = false;
      break;
    case ConnectorShapeType.OneWay:
      offsets = [0];
      bothWay = false;
      break;
    case ConnectorShapeType.BothWay:
      offsets = [0];
      bothWay = true;
      break;
  }
  minimalGap = Math.max(hasLabel ? labelSize.width : 0, linesOffset * 5);
  if (fromRect.right() + minimalGap < toRect.left() || fromRect.left() > toRect.right() + minimalGap) {
    if (fromRect.left() > toRect.right()) {
      fromPoint = new Point(fromRect.left(), fromRect.verticalCenter());
      toPoint = new Point(toRect.right(), toRect.verticalCenter());
    } else {
      fromPoint = new Point(fromRect.right(), fromRect.verticalCenter());
      toPoint = new Point(toRect.left(), toRect.verticalCenter());
    }
    if (hasLabel) {
      if (fromRect.left() > toRect.right()) {
        fromLabelPlacement = PlacementType.Left;
        toLabelPlacement = PlacementType.Right;
      } else {
        fromLabelPlacement = PlacementType.Right;
        toLabelPlacement = PlacementType.Left;
      }
    }
    connectorRect = new Rect(fromPoint, toPoint);
    invertY = fromPoint.y <= toPoint.y;
    invertX = fromPoint.x < toPoint.x;
    if (connectorRect.height < connectorRect.width) {
      if (connectorRect.height < linesOffset * 2) {
        connectorRect.offset(0, invertY ? linesOffset * 2 : 0, 0, invertY ? 0 : linesOffset * 2);
      }
      for (index = 0, len = offsets.length; index < len; index += 1) {
        tempOffset = offsets[index];
        buffer.addInverted(function(invertedBuffer) {
          var polyline2 = invertedBuffer.getPolyline(linePaletteItem);
          polyline2.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));
          polyline2.addSegment(new QuadraticArcSegment(
            connectorRect.horizontalCenter(),
            (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,
            toPoint.x,
            toPoint.y + tempOffset
          ));
          if (bothWay) {
            polyline2.addArrow(linePaletteItem.lineWidth, function(polyline3) {
              polyline3.mergeTo(buffer.getPolyline(polyline3.paletteItem));
            });
          }
        }, index || connectorShapeType == ConnectorShapeType.OneWay);
        polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
          polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
        });
      }
      if (hasLabel) {
        if (labelSize.width < connectorRect.width / 5 * 2) {
          snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), invertY ? connectorRect.top() : connectorRect.bottom(), toPoint.x, toPoint.y, 0.5);
        } else {
          snapPoint = new Point(fromPoint.x, invertY ? connectorRect.top() : connectorRect.bottom());
        }
        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset : -labelSize.width - linesOffset), invertY ? snapPoint.y - labelSize.height - linesOffset : snapPoint.y + linesOffset, labelSize.width, labelSize.height);
      }
    } else {
      for (index = 0, len = offsets.length; index < len; index += 1) {
        tempOffset = offsets[index];
        buffer.addInverted(function(invertedBuffer) {
          var polyline2 = invertedBuffer.getPolyline(linePaletteItem);
          polyline2.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));
          polyline2.addSegment(new QuadraticArcSegment(
            connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1),
            (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,
            connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1),
            connectorRect.verticalCenter() + tempOffset
          ));
          polyline2.addSegment(new QuadraticArcSegment(
            connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1),
            (invertY ? connectorRect.bottom() : connectorRect.top()) + tempOffset,
            toPoint.x,
            toPoint.y + tempOffset
          ));
          if (bothWay) {
            polyline2.addArrow(linePaletteItem.lineWidth, function(polyline3) {
              polyline3.mergeTo(buffer.getPolyline(polyline3.paletteItem));
            });
          }
        }, index || connectorShapeType == ConnectorShapeType.OneWay);
        polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
          polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
        });
      }
      if (hasLabel) {
        labelPlacement = new Rect(
          connectorRect.horizontalCenter() + (invertY != invertX ? linesOffset : -(linesOffset + labelSize.width)),
          connectorRect.verticalCenter() - labelSize.height / 2,
          labelSize.width,
          labelSize.height
        );
      }
    }
  } else {
    if (fromRect.verticalCenter() < toRect.top() || fromRect.verticalCenter() > toRect.bottom()) {
      invertX = fromRect.x < panelSize.width / 2;
      fromPoint = new Point(invertX ? fromRect.right() : fromRect.left(), fromRect.verticalCenter());
      toPoint = new Point(invertX ? toRect.right() : toRect.left(), toRect.verticalCenter());
      connectorRect = new Rect(fromPoint, toPoint);
      connectorRect.offset(linesOffset * 10, 0, linesOffset * 10, 0);
      invertY = fromPoint.y <= toPoint.y;
      for (index = 0, len = offsets.length; index < len; index += 1) {
        tempOffset = offsets[index];
        buffer.addInverted(function(invertedBuffer) {
          var polyline2 = invertedBuffer.getPolyline(linePaletteItem);
          polyline2.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));
          polyline2.addSegment(new QuadraticArcSegment(
            invertX ? connectorRect.right() + tempOffset * (invertY ? -1 : 1) : connectorRect.left() - tempOffset * (invertY ? -1 : 1),
            connectorRect.verticalCenter(),
            invertX ? toRect.right() : toRect.left(),
            toRect.verticalCenter() - tempOffset
          ));
          if (bothWay) {
            polyline2.addArrow(linePaletteItem.lineWidth, function(polyline3) {
              polyline3.mergeTo(buffer.getPolyline(polyline3.paletteItem));
            });
          }
        }, index || connectorShapeType == ConnectorShapeType.OneWay);
        polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
          polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
        });
      }
      if (hasLabel) {
        fromLabelPlacement = invertX ? PlacementType.Right : PlacementType.Left;
        toLabelPlacement = fromLabelPlacement;
        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, invertX ? connectorRect.right() : connectorRect.left(), connectorRect.verticalCenter(), toPoint.x, toPoint.y, 0.5);
        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset / 2 : -linesOffset / 2 - labelSize.width), snapPoint.y - labelSize.height / 2, labelSize.width, labelSize.height);
      }
    } else {
      fromPoint = new Point(fromRect.horizontalCenter(), fromRect.top());
      toPoint = new Point(toRect.horizontalCenter(), toRect.top());
      connectorRect = new Rect(fromPoint, toPoint);
      connectorRect.offset(0, linesOffset * 7, 0, 0);
      invertX = fromPoint.x < toPoint.x;
      for (index = 0, len = offsets.length; index < len; index += 1) {
        tempOffset = offsets[index];
        buffer.addInverted(function(invertedBuffer) {
          var polyline2 = invertedBuffer.getPolyline(linePaletteItem);
          polyline2.addSegment(new MoveSegment(fromPoint.x + tempOffset, fromPoint.y));
          polyline2.addSegment(new QuadraticArcSegment(
            connectorRect.horizontalCenter(),
            connectorRect.top() - tempOffset * (invertX ? -1 : 1),
            toRect.horizontalCenter() - tempOffset,
            toRect.top()
          ));
          if (bothWay) {
            polyline2.addArrow(linePaletteItem.lineWidth, function(polyline3) {
              polyline3.mergeTo(buffer.getPolyline(polyline3.paletteItem));
            });
          }
        }, index || connectorShapeType == ConnectorShapeType.OneWay);
        polyline.addArrow(linePaletteItem.lineWidth, function(polyline2) {
          polyline2.mergeTo(buffer.getPolyline(polyline2.paletteItem));
        });
      }
      if (hasLabel) {
        fromLabelPlacement = PlacementType.Top;
        toLabelPlacement = PlacementType.Top;
        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), connectorRect.top(), toPoint.x, toPoint.y, 0.5);
        labelPlacement = new Rect(snapPoint.x - labelSize.width / 2, snapPoint.y - (labelOffset + labelSize.height), labelSize.width, labelSize.height);
      }
    }
  }
  if (hasLabel) {
    switch (labelPlacementType) {
      case ConnectorLabelPlacementType.From:
        labelPlacement = this._getLabelPosition(fromRect.x, fromRect.y, fromRect.width, fromRect.height, labelPlacement.width, labelPlacement.height, labelOffset, fromLabelPlacement);
        break;
      case ConnectorLabelPlacementType.To:
        labelPlacement = this._getLabelPosition(toRect.x, toRect.y, toRect.width, toRect.height, labelPlacement.width, labelPlacement.height, labelOffset, toLabelPlacement);
        break;
      default:
        break;
    }
  }
  if (onLabelPlacement != null) {
    onLabelPlacement(labelPlacement, labelConfig);
  }
};

// node_modules/basicprimitives/src/tasks/renders/DrawConnectorAnnotationTask.js
function DrawConnectorAnnotationTask(getGraphics, createTransformTask, applyLayoutChangesTask, orientationOptionTask, connectorAnnotationOptionTask, alignDiagramTask, annotationLabelTemplateTask, zOrderType) {
  var _graphics, _transform, _orientationOptions, _annotationLabelTemplate, _panelSize;
  function process() {
    _graphics = getGraphics();
    _transform = createTransformTask.getTransform();
    _orientationOptions = orientationOptionTask.getOptions();
    _annotationLabelTemplate = annotationLabelTemplateTask.getTemplate();
    _panelSize = new Size(alignDiagramTask.getContentSize());
    switch (zOrderType) {
      case ZOrderType.Background:
        _graphics.reset("placeholder", Layers.BackgroundConnectorAnnotation);
        break;
      case ZOrderType.Foreground:
        _graphics.reset("placeholder", Layers.ForegroundConnectorAnnotation);
        break;
    }
    drawAnnotations(connectorAnnotationOptionTask.getAnnotations(), alignDiagramTask.getItemPosition);
    return false;
  }
  function drawAnnotations(annotations, getItemPosition) {
    var panel, index, len, layer = Layers.ForegroundConnectorAnnotation, fromItemPosition, fromActualPosition, toItemPosition, toActualPosition, shape, annotationConfig, uiHash, buffer = new PolylinesBuffer(), labelPlacement, connectorAnnotationOffsetResolver = ConnectorAnnotationOffsetResolver(), maximumLineWidth = 0;
    switch (zOrderType) {
      case ZOrderType.Background:
        panel = _graphics.activate("placeholder", Layers.BackgroundConnectorAnnotation);
        break;
      case ZOrderType.Foreground:
        panel = _graphics.activate("placeholder", Layers.ForegroundConnectorAnnotation);
        break;
    }
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotationConfig = annotations[index];
      maximumLineWidth = Math.max(maximumLineWidth, annotationConfig.lineWidth);
    }
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotationConfig = annotations[index];
      if (annotationConfig.fromItem != null && annotationConfig.toItem != null) {
        fromItemPosition = getItemPosition(annotationConfig.fromItem);
        toItemPosition = getItemPosition(annotationConfig.toItem);
        if (fromItemPosition != null && toItemPosition != null) {
          fromActualPosition = fromItemPosition.actualPosition;
          toActualPosition = toItemPosition.actualPosition;
          switch (annotationConfig.connectorPlacementType) {
            case ConnectorPlacementType.Offbeat:
              shape = new ConnectorOffbeat();
              break;
            case ConnectorPlacementType.Straight:
              shape = new ConnectorStraight();
              break;
          }
          var labelSize;
          _transform.transformRect(
            0,
            0,
            annotationConfig.labelSize.width,
            annotationConfig.labelSize.height,
            false,
            this,
            function(x, y, width, height) {
              labelSize = new Size(width, height);
            }
          );
          var panelSize = null;
          _transform.transformRect(
            0,
            0,
            _panelSize.width,
            _panelSize.height,
            false,
            this,
            function(x, y, width, height) {
              panelSize = new Size(width, height);
            }
          );
          var linePaletteItem = new PaletteItem({
            lineColor: annotationConfig.color,
            lineWidth: annotationConfig.lineWidth,
            lineType: annotationConfig.lineType
          });
          var hasLabel = !isNullOrEmpty(annotationConfig.label);
          var fromRect = new Rect(fromActualPosition).offset(annotationConfig.offset);
          var toRect = new Rect(toActualPosition).offset(annotationConfig.offset);
          var linesOffset = annotationConfig.lineWidth * 3;
          var bundleOffset = maximumLineWidth * 6;
          shape.draw(
            buffer,
            linePaletteItem,
            fromRect,
            toRect,
            linesOffset,
            bundleOffset,
            labelSize,
            panelSize,
            annotationConfig.connectorShapeType,
            4,
            annotationConfig.labelPlacementType,
            hasLabel,
            connectorAnnotationOffsetResolver,
            function(labelPlacement2, labelConfig) {
              var hasLabel2 = !isNullOrEmpty(labelConfig.label);
              if (hasLabel2 && labelPlacement2 != null) {
                _transform.transformRect(
                  labelPlacement2.x,
                  labelPlacement2.y,
                  labelPlacement2.width,
                  labelPlacement2.height,
                  true,
                  this,
                  function(x, y, width, height) {
                    labelPlacement2 = new Rect(x, y, width, height);
                  }
                );
                uiHash = new RenderEventArgs();
                uiHash.context = labelConfig;
                _graphics.template(
                  labelPlacement2.x,
                  labelPlacement2.y,
                  0,
                  0,
                  0,
                  0,
                  labelPlacement2.width,
                  labelPlacement2.height,
                  _annotationLabelTemplate.template(),
                  _annotationLabelTemplate.getHashCode(),
                  _annotationLabelTemplate.render,
                  uiHash,
                  null
                );
              }
            },
            annotationConfig
          );
        }
      }
    }
    connectorAnnotationOffsetResolver.resolve();
    buffer.transform(_transform, true);
    _graphics.polylinesBuffer(buffer);
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/graphics/shapes/Callout.js
function Callout(graphics) {
  this.m_graphics = graphics;
  this.pointerPlacement = PlacementType.Auto;
  this.cornerRadius = "10%";
  this.offset = 0;
  this.opacity = 1;
  this.lineWidth = 1;
  this.pointerWidth = "10%";
  this.borderColor = Colors.Black;
  this.lineType = LineType.Solid;
  this.fillColor = Colors.LightGray;
  this.m_map = [
    [PlacementType.TopLeft, PlacementType.Left, PlacementType.BottomLeft],
    [PlacementType.Top, null, PlacementType.Bottom],
    [PlacementType.TopRight, PlacementType.Right, PlacementType.BottomRight]
  ];
}
Callout.prototype = new BaseShape();
Callout.prototype.draw = function(snapPoint, position) {
  position = new Rect(position).offset(this.offset);
  var pointA = new Point(position.x, position.y), pointB = new Point(position.right(), position.y), pointC = new Point(position.right(), position.bottom()), pointD = new Point(position.left(), position.bottom()), snapPoints = [null, null, null, null, null, null, null, null], points = [pointA, pointB, pointC, pointD], radius = this.m_graphics.getPxSize(this.cornerRadius, Math.min(pointA.distanceTo(pointB), pointB.distanceTo(pointC))), placementType, point, index, attr, linePaletteItem, buffer, polyline;
  attr = {};
  if (this.fillColor !== null) {
    attr.fillColor = this.fillColor;
    attr.opacity = this.opacity;
  }
  if (this.lineColor !== null) {
    attr.lineColor = this.borderColor;
  }
  attr.lineWidth = this.lineWidth;
  attr.lineType = this.lineType;
  linePaletteItem = new PaletteItem(attr);
  buffer = new PolylinesBuffer();
  polyline = buffer.getPolyline(linePaletteItem);
  if (snapPoint !== null) {
    placementType = this.pointerPlacement === PlacementType.Auto ? this._getPlacement(snapPoint, pointA, pointC) : this.pointerPlacement;
    if (placementType !== null) {
      snapPoints[placementType] = snapPoint;
    }
  }
  for (index = 0; index < points.length; index += 1) {
    this._drawSegment(polyline, points[0], points[1], points[2], this.pointerWidth, radius, snapPoints[1], snapPoints[2]);
    point = points.shift();
    points.push(point);
    point = snapPoints.shift();
    snapPoints.push(point);
    point = snapPoints.shift();
    snapPoints.push(point);
  }
  this.m_graphics.polylinesBuffer(buffer);
};
Callout.prototype._getPlacement = function(point, point1, point2) {
  var row = null, column = null;
  if (point.x < point1.x) {
    row = 0;
  } else if (point.x > point2.x) {
    row = 2;
  } else {
    row = 1;
  }
  if (point.y < point1.y) {
    column = 0;
  } else if (point.y > point2.y) {
    column = 2;
  } else {
    column = 1;
  }
  return this.m_map[row][column];
};
Callout.prototype._drawSegment = function(polyline, pointA, pointB, pointC, base, radius, sideSnapPoint, cornerSnapPoint) {
  var pointA1 = this._offsetPoint(pointA, pointB, radius), pointB1 = this._offsetPoint(pointB, pointA, radius), pointB2 = this._offsetPoint(pointB, pointC, radius), pointS, pointS1, pointS2;
  base = this.m_graphics.getPxSize(base, pointA.distanceTo(pointB) / 2);
  if (polyline.length() === 0) {
    polyline.addSegment(new MoveSegment(pointA1));
  }
  if (sideSnapPoint !== null) {
    pointS = this._betweenPoint(pointA, pointB);
    pointS1 = this._offsetPoint(pointS, pointA, base);
    pointS2 = this._offsetPoint(pointS, pointB, base);
    polyline.addSegment(new LineSegment(pointS1));
    polyline.addSegment(new LineSegment(sideSnapPoint));
    polyline.addSegment(new LineSegment(pointS2));
  }
  polyline.addSegment(new LineSegment(pointB1));
  if (cornerSnapPoint !== null) {
    polyline.addSegment(new LineSegment(cornerSnapPoint));
    polyline.addSegment(new LineSegment(pointB2));
  } else {
    polyline.addSegment(new QuadraticArcSegment(pointB, pointB2));
  }
};

// node_modules/basicprimitives/src/graphics/shapes/Marker.js
function Marker() {
}
Marker.Markers = {};
Marker.DrawCircle = function(polyline, position) {
  var quarter = Math.min(position.width / 2, position.height / 2);
  position = new Rect(position.horizontalCenter() - quarter, position.verticalCenter() - quarter, quarter * 2, quarter * 2);
  Marker.DrawOval(polyline, position);
};
Marker.DrawRectangle = function(polyline, position) {
  polyline.addSegment(new MoveSegment(position.x, position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.x, position.y));
  polyline.addSegment(new LineSegment(position.right(), position.y));
  polyline.addSegment(new LineSegment(position.right(), position.bottom()));
  polyline.addSegment(new LineSegment(position.x, position.bottom()));
  polyline.addSegment(new LineSegment(position.x, position.verticalCenter()));
};
Marker.DrawOval = function(polyline, position) {
  var cpX, cpY;
  cpX = position.width / 2 * 0.5522848;
  cpY = position.height / 2 * 0.5522848;
  polyline.addSegment(new MoveSegment(position.x, position.verticalCenter()));
  polyline.addSegment(new CubicArcSegment(position.x, position.verticalCenter() - cpY, position.horizontalCenter() - cpX, position.y, position.horizontalCenter(), position.y));
  polyline.addSegment(new CubicArcSegment(position.horizontalCenter() + cpX, position.y, position.right(), position.verticalCenter() - cpY, position.right(), position.verticalCenter()));
  polyline.addSegment(new CubicArcSegment(position.right(), position.verticalCenter() + cpY, position.horizontalCenter() + cpX, position.bottom(), position.horizontalCenter(), position.bottom()));
  polyline.addSegment(new CubicArcSegment(position.horizontalCenter() - cpX, position.bottom(), position.x, position.verticalCenter() + cpY, position.x, position.verticalCenter()));
};
Marker.DrawTriangle = function(polyline, position) {
  polyline.addSegment(new MoveSegment(position.left(), position.bottom()));
  polyline.addSegment(new LineSegment(position.horizontalCenter(), position.y));
  polyline.addSegment(new LineSegment(position.right(), position.bottom()));
  polyline.addSegment(new LineSegment(position.left(), position.bottom()));
};
Marker.DrawCrossOut = function(polyline, position) {
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.x, position.y));
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.right(), position.bottom()));
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.right(), position.y));
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.left(), position.bottom()));
};
Marker.DrawRhombus = function(polyline, position) {
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.bottom()));
  polyline.addSegment(new LineSegment(position.left(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.horizontalCenter(), position.y));
  polyline.addSegment(new LineSegment(position.right(), position.verticalCenter()));
  polyline.addSegment(new LineSegment(position.horizontalCenter(), position.bottom()));
};
Marker.DrawWedge = function(polyline, position) {
  polyline.addSegment(new MoveSegment(position.horizontalCenter(), position.y));
  polyline.addSegment(new LineSegment(position.right(), position.y));
  polyline.addSegment(new LineSegment(position.horizontalCenter(), position.bottom()));
  polyline.addSegment(new LineSegment(position.left(), position.y));
  polyline.addSegment(new LineSegment(position.horizontalCenter(), position.y));
};
Marker.DrawFramedOval = function(polyline, position) {
  Marker.DrawRectangle(polyline, position);
  Marker.DrawOval(polyline, position);
};
Marker.DrawFramedTriangle = function(polyline, position) {
  Marker.DrawRectangle(polyline, position);
  Marker.DrawTriangle(polyline, position);
};
Marker.DrawFramedWedge = function(polyline, position) {
  Marker.DrawRectangle(polyline, position);
  Marker.DrawWedge(polyline, position);
};
Marker.DrawFramedRhombus = function(polyline, position) {
  Marker.DrawRectangle(polyline, position);
  Marker.DrawRhombus(polyline, position);
};
Marker.DrawNone = function(polyline, position) {
};
Marker.Markers[ShapeType.Circle] = Marker.DrawCircle;
Marker.Markers[ShapeType.Rectangle] = Marker.DrawRectangle;
Marker.Markers[ShapeType.Oval] = Marker.DrawOval;
Marker.Markers[ShapeType.Triangle] = Marker.DrawTriangle;
Marker.Markers[ShapeType.CrossOut] = Marker.DrawCrossOut;
Marker.Markers[ShapeType.Rhombus] = Marker.DrawRhombus;
Marker.Markers[ShapeType.Wedge] = Marker.DrawWedge;
Marker.Markers[ShapeType.FramedOval] = Marker.DrawFramedOval;
Marker.Markers[ShapeType.FramedTriangle] = Marker.DrawFramedTriangle;
Marker.Markers[ShapeType.FramedWedge] = Marker.DrawFramedWedge;
Marker.Markers[ShapeType.FramedRhombus] = Marker.DrawFramedRhombus;
Marker.Markers[ShapeType.None] = Marker.DrawNone;
Marker.prototype.draw = function(polylinesBuffer, shapeType, position, paletteItem) {
  var polyline;
  polyline = polylinesBuffer.getPolyline(paletteItem);
  Marker.Markers[shapeType](polyline, position);
};

// node_modules/basicprimitives/src/graphics/shapes/Shape.js
function Shape(graphics) {
  this.m_graphics = graphics;
  this.transform = null;
  this.orientationType = OrientationType.Top;
  this.panelSize = null;
  this.shapeType = ShapeType.Rectangle;
  this.offset = new Thickness(0, 0, 0, 0);
  this.lineWidth = 1;
  this.labelOffset = 4;
  this.cornerRadius = "10%";
  this.opacity = 1;
  this.fillColor = null;
  this.labelSize = new Size(60, 30);
  this.lineType = LineType.Solid;
  this.borderColor = null;
  this.hasLabel = false;
  this.labelTemplate = null;
  this.labelPlacement = PlacementType.Auto;
}
Shape.prototype = new BaseShape();
Shape.prototype.draw = function(position, uiHash) {
  var labelPlacement, calloutShape, linePaletteItem, buffer, marker;
  position = new Rect(position).offset(this.offset);
  this.transform = new Transform();
  this.transform.size = this.panelSize;
  this.transform.setOrientation(this.orientationType);
  if (this.hasLabel) {
    labelPlacement = this._getLabelPosition(position.x, position.y, position.width, position.height, this.labelSize.width, this.labelSize.height, this.labelOffset, this.labelPlacement);
  }
  switch (this.shapeType) {
    case ShapeType.Rectangle:
      calloutShape = new Callout(this.m_graphics);
      calloutShape.cornerRadius = this.cornerRadius;
      calloutShape.opacity = this.opacity;
      calloutShape.lineWidth = this.lineWidth;
      calloutShape.lineType = this.lineType;
      calloutShape.borderColor = this.borderColor;
      calloutShape.fillColor = this.fillColor;
      calloutShape.draw(null, position);
      break;
    default:
      linePaletteItem = new PaletteItem({
        lineColor: this.borderColor,
        lineWidth: this.lineWidth,
        lineType: this.lineType,
        fillColor: this.fillColor,
        opacity: this.opacity
      });
      this.transform.transformRect(
        position.x,
        position.y,
        position.width,
        position.height,
        false,
        this,
        function(x, y, width, height) {
          position = new Rect(x, y, width, height);
        }
      );
      marker = new Marker();
      buffer = new PolylinesBuffer();
      marker.draw(buffer, this.shapeType, position, linePaletteItem);
      buffer.transform(this.transform, true);
      this.m_graphics.polylinesBuffer(buffer);
      break;
  }
  if (this.hasLabel) {
    this.m_graphics.template(
      labelPlacement.x,
      labelPlacement.y,
      0,
      0,
      0,
      0,
      labelPlacement.width,
      labelPlacement.height,
      this.labelTemplate.template(),
      this.labelTemplate.getHashCode(),
      this.labelTemplate.render,
      uiHash,
      null
    );
  }
};

// node_modules/basicprimitives/src/tasks/renders/DrawShapeAnnotationTask.js
function DrawShapeAnnotationTask(getGraphics, createTransformTask, applyLayoutChangesTask, orientationOptionTask, shapeAnnotationOptionTask, alignDiagramTask, annotationLabelTemplateTask, zOrderType) {
  var _graphics, _transform, _orientationOptions, _annotationLabelTemplate;
  function process() {
    _graphics = getGraphics();
    _transform = createTransformTask.getTransform();
    _orientationOptions = orientationOptionTask.getOptions();
    _annotationLabelTemplate = annotationLabelTemplateTask.getTemplate();
    switch (zOrderType) {
      case ZOrderType.Background:
        _graphics.reset("placeholder", Layers.BackgroundAnnotations);
        break;
      case ZOrderType.Foreground:
        _graphics.reset("placeholder", Layers.ForegroundAnnotations);
        break;
    }
    _drawAnnotations(shapeAnnotationOptionTask.getAnnotations(), alignDiagramTask.getItemPosition);
    return false;
  }
  function _drawAnnotations(annotations, getItemPosition) {
    var panel, index, len, index2, len2, index3, len3, shape, defaultConfig, itemPosition, position, properties, property, annotationConfig, uiHash;
    switch (zOrderType) {
      case ZOrderType.Background:
        panel = _graphics.activate("placeholder", Layers.BackgroundAnnotations);
        break;
      case ZOrderType.Foreground:
        panel = _graphics.activate("placeholder", Layers.ForegroundAnnotations);
        break;
    }
    for (index = 0, len = annotations.length; index < len; index += 1) {
      annotationConfig = annotations[index];
      if (annotationConfig.items != null && annotationConfig.items.length > 0) {
        position = new Rect();
        for (index2 = 0, len2 = annotationConfig.items.length; index2 < len2; index2 += 1) {
          itemPosition = getItemPosition(annotationConfig.items[index2]);
          if (itemPosition != null) {
            position.addRect(itemPosition.actualPosition);
          }
        }
        if (!position.isEmpty()) {
          shape = new Shape(_graphics);
          defaultConfig = new ShapeAnnotationConfig();
          properties = ["opacity", "cornerRadius", "shapeType", "offset", "lineWidth", "borderColor", "fillColor", "lineType", "labelSize", "labelOffset", "labelPlacement", "zOrderType"];
          for (index3 = 0, len3 = properties.length; index3 < len3; index3 += 1) {
            property = properties[index3];
            shape[property] = annotationConfig.hasOwnProperty(property) ? annotationConfig[property] : defaultConfig[property];
          }
          shape.position = position;
          shape.orientationType = _orientationOptions.orientationType;
          shape.panelSize = panel.size;
          shape.labelTemplate = _annotationLabelTemplate;
          shape.hasLabel = annotationConfig.templateName != null || annotationConfig.label != null;
          uiHash = new RenderEventArgs();
          uiHash.context = annotationConfig;
          uiHash.templateName = shape.labelTemplate;
          _transform.transformRect(
            position.x,
            position.y,
            position.width,
            position.height,
            true,
            this,
            function(x, y, width, height) {
              var position2 = new Rect(x, y, width, height);
              shape.draw(position2, uiHash);
            }
          );
        }
      }
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawCursorTask.js
function DrawCursorTask(getGraphics, createTransformTask, applyLayoutChangesTask, combinedContextsTask, alignDiagramTask, itemTemplateParamsTask, cursorItemTask, selectedItemsTask) {
  var _graphics, _transform;
  function process() {
    var treeItemId = cursorItemTask.getCursorTreeItem();
    _graphics = getGraphics();
    _graphics.reset("placeholder", Layers.Cursor);
    if (treeItemId != null) {
      _transform = createTransformTask.getTransform();
      drawCursor(treeItemId);
    }
    return false;
  }
  function drawCursor(treeItemId) {
    var treeItem, uiHash, panel = _graphics.activate("placeholder", Layers.Cursor), treeItemPosition = alignDiagramTask.getItemPosition(treeItemId);
    if (treeItemPosition != null) {
      var actualPosition = treeItemPosition.actualPosition, position = new Rect(treeItemPosition.contentPosition), templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId), template = templateParams.template, templateConfig = template.templateConfig, cursorPadding = templateConfig.cursorPadding;
      position.offset(cursorPadding.left, cursorPadding.top, cursorPadding.right, cursorPadding.bottom);
      uiHash = new RenderEventArgs();
      uiHash.context = combinedContextsTask.getConfig(treeItemId);
      uiHash.isCursor = true;
      uiHash.isSelected = selectedItemsTask.isSelected(treeItemId);
      uiHash.templateName = templateConfig.name;
      _transform.transformRect(
        actualPosition.x,
        actualPosition.y,
        actualPosition.width,
        actualPosition.height,
        true,
        this,
        function(x, y, width, height) {
          var element = _graphics.template(
            x,
            y,
            width,
            height,
            position.x,
            position.y,
            position.width,
            position.height,
            template.cursorTemplate.template(),
            template.cursorTemplate.getHashCode(),
            template.cursorTemplate.render,
            uiHash,
            { "borderWidth": templateConfig.cursorBorderWidth }
          );
        }
      );
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawHighlightTask.js
function DrawHighlightTask(getGraphics, createTransformTask, applyLayoutChangesTask, combinedContextsTask, alignDiagramTask, itemTemplateParamsTask, highlightItemTask, cursorItemTask, selectedItemsTask) {
  var _graphics, _transform;
  function process() {
    var treeItemId = highlightItemTask.getHighlightTreeItem();
    _graphics = getGraphics();
    _graphics.reset("placeholder", Layers.Highlight);
    if (treeItemId != null) {
      _transform = createTransformTask.getTransform();
      drawHighlight(treeItemId);
    }
    return false;
  }
  function drawHighlight(treeItemId) {
    var uiHash, panel = _graphics.activate("placeholder", Layers.Highlight), treeItemPosition = alignDiagramTask.getItemPosition(treeItemId), actualPosition = treeItemPosition.actualPosition, templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId), template = templateParams.template, templateConfig = template.templateConfig, highlightPadding = templateConfig.highlightPadding;
    uiHash = new RenderEventArgs();
    uiHash.context = combinedContextsTask.getConfig(treeItemId);
    uiHash.isCursor = cursorItemTask.getCursorTreeItem() == treeItemId;
    uiHash.isSelected = selectedItemsTask.isSelected(treeItemId);
    uiHash.templateName = templateConfig.name;
    _transform.transformRect(
      actualPosition.x,
      actualPosition.y,
      actualPosition.width,
      actualPosition.height,
      true,
      this,
      function(x, y, width, height) {
        var position = new Rect(0, 0, Math.round(width), Math.round(height));
        position.offset(highlightPadding.left, highlightPadding.top, highlightPadding.right, highlightPadding.bottom);
        var element;
        if (treeItemPosition.actualVisibility == Visibility.Normal) {
          element = _graphics.template(
            x,
            y,
            width,
            height,
            position.x,
            position.y,
            position.width,
            position.height,
            template.highlightTemplate.template(),
            template.highlightTemplate.getHashCode(),
            template.highlightTemplate.render,
            uiHash,
            { "borderWidth": templateConfig.highlightBorderWidth }
          );
        } else {
          element = _graphics.template(
            Math.round(x),
            Math.round(y),
            Math.round(width),
            Math.round(height),
            Math.round(position.x),
            Math.round(position.y),
            Math.round(position.width),
            Math.round(position.height),
            template.dotHighlightTemplate.template(),
            template.dotHighlightTemplate.getHashCode(),
            template.dotHighlightTemplate.render,
            uiHash,
            { "borderWidth": templateConfig.highlightBorderWidth }
          );
        }
      }
    );
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawHighlightAnnotationTask.js
function DrawHighlightAnnotationTask(getGraphics, createTransformTask, applyLayoutChangesTask, scaleOptionTask, combinedContextsTask, calloutOptionTask, readTemplatesTask, alignDiagramTask, centerOnCursorTask, highlightItemTask, cursorItemTask, selectedItemsTask, frameSizeTask) {
  var _graphics, _transform, _calloutShape = new Callout(getGraphics()), _options;
  function process() {
    var treeItemId = highlightItemTask.getHighlightTreeItem();
    _graphics = getGraphics();
    _graphics.reset("calloutplaceholder", Layers.Annotation);
    if (treeItemId !== null) {
      _transform = createTransformTask.getTransform();
      _options = calloutOptionTask.getOptions();
      drawHighlightAnnotation(treeItemId);
    }
    return false;
  }
  function drawHighlightAnnotation(treeItemId) {
    var panel, itemConfig, calloutPanelPosition, position, uiHash, calloutTemplateName, calloutTemplate, showCallout = true, treeItemPosition = alignDiagramTask.getItemPosition(treeItemId), actualPosition = treeItemPosition.actualPosition;
    switch (treeItemPosition.actualVisibility) {
      case Visibility.Dot:
      case Visibility.Line:
      case Visibility.Normal:
        itemConfig = calloutOptionTask.getItemOptions(treeItemId);
        switch (itemConfig.showCallout) {
          case Enabled.False:
            showCallout = false;
            break;
          case Enabled.True:
            showCallout = false;
            break;
          default:
            showCallout = _options.showCallout;
            break;
        }
        if (showCallout) {
          panel = _graphics.activate("placeholder", Layers.Item);
          _transform.transformRect(
            actualPosition.x,
            actualPosition.y,
            actualPosition.width,
            actualPosition.height,
            true,
            this,
            function(x, y, width, height) {
              var snapRect = new Rect(x, y, width, height), snapPoint = new Point(snapRect.centerPoint()), { medianRect, viewPortRect } = getFrameMedianPosition(), projectionPoint = medianRect.getProjectionPoint(snapRect.centerPoint());
              if (projectionPoint == null) {
                projectionPoint = snapPoint;
              }
              if (treeItemPosition.actualVisibility >= _options.calloutMaximumVisibility && treeItemPosition.actualVisibility != Visibility.Invisible || !medianRect.overlaps(snapRect)) {
                calloutTemplateName = !isNullOrEmpty(itemConfig.calloutTemplateName) ? itemConfig.calloutTemplateName : !isNullOrEmpty(itemConfig.templateName) ? itemConfig.templateName : !isNullOrEmpty(_options.defaultCalloutTemplateName) ? _options.defaultCalloutTemplateName : _options.defaultTemplateName;
                calloutTemplate = readTemplatesTask.getTemplate(calloutTemplateName, readTemplatesTask.DefaultWidgetTemplateName);
                position = getAnnotationPosition(projectionPoint, viewPortRect, calloutTemplate.templateConfig.itemSize);
                calloutPanelPosition = new Rect(position);
                calloutPanelPosition.addRect(projectionPoint.x, projectionPoint.y);
                calloutPanelPosition.offset(50);
                projectionPoint.x -= calloutPanelPosition.x;
                projectionPoint.y -= calloutPanelPosition.y;
                position.x -= calloutPanelPosition.x;
                position.y -= calloutPanelPosition.y;
                uiHash = new RenderEventArgs();
                uiHash.context = combinedContextsTask.getConfig(treeItemId);
                uiHash.isCursor = cursorItemTask.getCursorTreeItem() == treeItemId;
                uiHash.isSelected = selectedItemsTask.isSelected(treeItemId);
                uiHash.templateName = calloutTemplate.templateConfig.name;
                _graphics.show("calloutplaceholder");
                panel = _graphics.activate("calloutplaceholder", Layers.Annotation);
                _graphics.position("calloutplaceholder", calloutPanelPosition.x, calloutPanelPosition.y, calloutPanelPosition.width, calloutPanelPosition.height);
                _graphics.template(
                  position.x,
                  position.y,
                  position.width,
                  position.height,
                  0,
                  0,
                  position.width,
                  position.height,
                  calloutTemplate.itemTemplate.template(),
                  calloutTemplate.itemTemplate.getHashCode(),
                  calloutTemplate.itemTemplate.render,
                  uiHash,
                  null
                );
                _calloutShape.pointerPlacement = PlacementType.Auto;
                _calloutShape.cornerRadius = _options.calloutCornerRadius;
                _calloutShape.offset = _options.calloutOffset;
                _calloutShape.opacity = _options.calloutOpacity;
                _calloutShape.lineWidth = _options.calloutLineWidth;
                _calloutShape.pointerWidth = _options.calloutPointerWidth;
                _calloutShape.borderColor = _options.calloutBorderColor;
                _calloutShape.fillColor = _options.calloutfillColor;
                _calloutShape.draw(projectionPoint, position);
              } else {
                _graphics.hide("calloutplaceholder");
              }
            }
          );
        } else {
          _graphics.hide("calloutplaceholder");
        }
        break;
      case Visibility.Invisible:
        _graphics.hide("calloutplaceholder");
        break;
    }
  }
  function getFrameMedianPosition() {
    var scaleOptions = scaleOptionTask.getOptions(), scale = scaleOptions.scale, placeholderOffset = new Point(centerOnCursorTask.getPlaceholderOffset()), scrollPanelSize = new Size(applyLayoutChangesTask.getScrollPanelSize()), frameBaseOffset = new Thickness(applyLayoutChangesTask.getFrameOffset()), medianThickness = new Thickness(frameSizeTask.getMedian());
    placeholderOffset.scale(1 / scale);
    frameBaseOffset.scale(1 / scale);
    scrollPanelSize.scale(1 / scale);
    medianThickness.scale(1 / scale);
    var viewPortRect = new Rect(placeholderOffset.x, placeholderOffset.y, scrollPanelSize.width, scrollPanelSize.height);
    var medianRect = new Rect(viewPortRect);
    medianRect.offset(frameBaseOffset);
    medianRect.offset(medianThickness);
    return {
      medianRect,
      viewPortRect
    };
  }
  function getAnnotationPosition(snapPoint, panelRect, itemSize) {
    var result = new Rect(snapPoint.x, snapPoint.y, itemSize.width, itemSize.height);
    switch (_options.orientationType) {
      case OrientationType.Top:
      case OrientationType.Bottom:
        result.y -= itemSize.height / 4;
        if (snapPoint.x < panelRect.horizontalCenter()) {
          result.x += _options.calloutPlacementOffset;
        } else {
          result.x -= _options.calloutPlacementOffset + itemSize.width;
        }
        break;
      default:
        result.x -= itemSize.width / 4;
        if (snapPoint.y < panelRect.verticalCenter()) {
          result.y += _options.calloutPlacementOffset;
        } else {
          result.y -= _options.calloutPlacementOffset + itemSize.height;
        }
        break;
    }
    if (result.x < panelRect.x) {
      result.x = panelRect.x + _options.calloutPlacementOffset;
    } else if (result.right() > panelRect.right()) {
      result.x -= result.right() - panelRect.right() + _options.calloutPlacementOffset;
    }
    if (result.y < panelRect.y) {
      result.y = panelRect.y + _options.calloutPlacementOffset;
    } else if (result.bottom() > panelRect.bottom()) {
      result.y -= result.bottom() - panelRect.bottom() + _options.calloutPlacementOffset;
    }
    return result;
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawTreeItemsTask.js
function DrawTreeItemsTask(getGraphics, createTransformTask, applyLayoutChangesTask, scaleOptionTask, itemsSizesOptionTask, combinedContextsTask, alignDiagramTask, centerOnCursorTask, itemTemplateParamsTask, cursorItemTask, selectedItemsTask, groupTitleTemplateTask, checkBoxTemplateTask, buttonsTemplateTask) {
  var _positions, _graphics, _transform, _itemsSizesOptions, _buttonsTemplate, _checkBoxTemplate, _groupTitleTemplate;
  function process() {
    _graphics = getGraphics();
    _itemsSizesOptions = itemsSizesOptionTask.getOptions();
    _positions = alignDiagramTask.getItemsPositions();
    _transform = createTransformTask.getTransform();
    _buttonsTemplate = buttonsTemplateTask.getTemplate();
    _checkBoxTemplate = checkBoxTemplateTask.getTemplate();
    _groupTitleTemplate = groupTitleTemplateTask.getTemplate();
    _graphics.reset("placeholder", Layers.Item);
    _graphics.reset("placeholder", Layers.Controls);
    redrawTreeItems();
    return false;
  }
  function redrawTreeItems() {
    var uiHash, element, cursorItemId = cursorItemTask.getCursorTreeItem(), treeItemPosition, actualPosition, viewPortPosition = getViewPortPosition();
    for (var treeItemId in _positions) {
      if (_positions.hasOwnProperty(treeItemId)) {
        treeItemPosition = _positions[treeItemId], actualPosition = treeItemPosition.actualPosition;
        if (treeItemPosition.actualVisibility == Visibility.Normal) {
          _transform.transformRect(
            actualPosition.x,
            actualPosition.y,
            actualPosition.width,
            actualPosition.height,
            true,
            this,
            function(x, y, width, height) {
              var nodePosition = new Rect(x, y, width, height);
              if (viewPortPosition == null || viewPortPosition.overlaps(nodePosition)) {
                var templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId);
                if (templateParams != null) {
                  var template = templateParams.template;
                  uiHash = new RenderEventArgs();
                  uiHash.id = treeItemId;
                  uiHash.context = combinedContextsTask.getConfig(treeItemId);
                  uiHash.isCursor = treeItemId == cursorItemId;
                  uiHash.isSelected = selectedItemsTask.isSelected(treeItemId);
                  uiHash.templateName = template.templateConfig.name;
                  uiHash.template = templateParams.template;
                  uiHash.isActive = templateParams.isActive;
                  uiHash.hasSelectorCheckbox = templateParams.hasSelectorCheckbox;
                  uiHash.hasButtons = templateParams.hasButtons;
                  uiHash.hasGroupTitle = templateParams.hasGroupTitle;
                  uiHash.onButtonsRender = templateParams.onButtonsRender;
                  _graphics.activate("placeholder", Layers.Item);
                  element = _graphics.template(
                    x,
                    y,
                    width,
                    height,
                    treeItemPosition.contentPosition.x,
                    treeItemPosition.contentPosition.y,
                    treeItemPosition.contentPosition.width,
                    treeItemPosition.contentPosition.height,
                    template.itemTemplate.template(),
                    template.itemTemplate.getHashCode(),
                    template.itemTemplate.render,
                    uiHash,
                    { "borderWidth": template.templateConfig.itemBorderWidth }
                  );
                  if (templateParams.hasGroupTitle) {
                    var groupTitlePosition = 0;
                    switch (_itemsSizesOptions.groupTitlePlacementType) {
                      case AdviserPlacementType.Left:
                      case AdviserPlacementType.Auto:
                        groupTitlePosition = 2;
                        break;
                      case AdviserPlacementType.Right:
                        groupTitlePosition = width - (_itemsSizesOptions.groupTitlePanelSize - 4);
                        break;
                      default:
                    }
                    element = _graphics.template(
                      x,
                      y,
                      width,
                      height,
                      groupTitlePosition,
                      treeItemPosition.contentPosition.y,
                      _itemsSizesOptions.groupTitlePanelSize - 4,
                      treeItemPosition.contentPosition.height + 2,
                      _groupTitleTemplate.template(),
                      _groupTitleTemplate.getHashCode(),
                      _groupTitleTemplate.render,
                      uiHash,
                      null
                    );
                  }
                  if (templateParams.hasSelectorCheckbox) {
                    _graphics.activate("placeholder", Layers.Controls);
                    element = _graphics.template(
                      x,
                      y,
                      width,
                      height,
                      treeItemPosition.contentPosition.x,
                      height - (_itemsSizesOptions.checkBoxPanelSize - 4),
                      treeItemPosition.contentPosition.width,
                      _itemsSizesOptions.checkBoxPanelSize - 4,
                      _checkBoxTemplate.template(),
                      _checkBoxTemplate.getHashCode(),
                      _checkBoxTemplate.render,
                      uiHash,
                      null
                    );
                  }
                  if (templateParams.hasButtons) {
                    _graphics.activate("placeholder", Layers.Controls);
                    var buttonsPanelPosition = 0;
                    switch (_itemsSizesOptions.groupTitlePlacementType) {
                      case AdviserPlacementType.Left:
                      case AdviserPlacementType.Auto:
                        buttonsPanelPosition = width - (_itemsSizesOptions.buttonsPanelSize - 4);
                        break;
                      case AdviserPlacementType.Right:
                        buttonsPanelPosition = 2;
                        break;
                      default:
                    }
                    element = _graphics.template(
                      x,
                      y,
                      width,
                      height,
                      buttonsPanelPosition,
                      treeItemPosition.contentPosition.y,
                      _itemsSizesOptions.buttonsPanelSize - 4,
                      Math.max(treeItemPosition.contentPosition.height, height - treeItemPosition.contentPosition.y),
                      _buttonsTemplate.template(),
                      template.templateConfig.name + _buttonsTemplate.getHashCode(),
                      _buttonsTemplate.render,
                      uiHash,
                      null
                    );
                  }
                }
              }
            }
          );
        }
      }
    }
  }
  function getViewPortPosition() {
    var result = null;
    if (centerOnCursorTask != null) {
      var scaleOptions = scaleOptionTask.getOptions(), scale = scaleOptions.scale, placeholderOffset = new Point(centerOnCursorTask.getPlaceholderOffset()), panelSize = new Rect(alignDiagramTask.getContentSize()), optimalPanelSize = new Size(applyLayoutChangesTask.getOptimalPanelSize());
      placeholderOffset.scale(1 / scale);
      optimalPanelSize.scale(1 / scale);
      result = new Rect(
        placeholderOffset.x,
        placeholderOffset.y,
        Math.min(optimalPanelSize.width, panelSize.width),
        Math.min(optimalPanelSize.height, panelSize.height)
      );
    }
    return result;
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/graphics/structs/DotSegment.js
function DotSegment(x, y, width, height, cornerRadius) {
  this.segmentType = SegmentType.Dot;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.cornerRadius = cornerRadius;
}

// node_modules/basicprimitives/src/tasks/renders/DrawMinimizedItemsTask.js
function DrawMinimizedItemsTask(getGraphics, createTransformTask, applyLayoutChangesTask, minimizedItemsOptionTask, itemTemplateParamsTask, alignDiagramTask) {
  var _graphics, _transform, _debug = false, _options, _positions;
  function process() {
    _graphics = getGraphics();
    _transform = createTransformTask.getTransform();
    _options = minimizedItemsOptionTask.getOptions();
    _positions = alignDiagramTask.getItemsPositions();
    _graphics.reset("placeholder", Layers.Marker);
    drawMinimizedItems();
    return false;
  }
  function drawMinimizedItems() {
    var markers = new PolylinesBuffer(), paletteItems = {}, polyline, marker = new Marker(), itemTitleColor, itemFillColor, minimizedItemShapeType, minimizedItemCornerRadius, treeItemPosition, actualPosition, minimizedItemsOptions, templateParams, templateConfig;
    for (var treeItemId in _positions) {
      if (_positions.hasOwnProperty(treeItemId)) {
        treeItemPosition = _positions[treeItemId], actualPosition = treeItemPosition.actualPosition, minimizedItemsOptions = minimizedItemsOptionTask.getItemOptions(treeItemId);
        _transform.transformRect(
          actualPosition.x,
          actualPosition.y,
          actualPosition.width,
          actualPosition.height,
          true,
          this,
          function(x, y, width, height) {
            switch (treeItemPosition.actualVisibility) {
              case Visibility.Dot:
                templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId);
                templateConfig = templateParams.template.templateConfig;
                itemTitleColor = null;
                itemFillColor = null;
                minimizedItemShapeType = null;
                minimizedItemCornerRadius = 0;
                if (minimizedItemsOptions != null) {
                  itemTitleColor = minimizedItemsOptions.itemTitleColor;
                  itemFillColor = minimizedItemsOptions.itemTitleColor;
                  minimizedItemShapeType = minimizedItemsOptions.minimizedItemShapeType;
                }
                itemTitleColor = itemTitleColor || templateConfig.minimizedItemBorderColor || Colors.Navy;
                itemFillColor = itemFillColor || templateConfig.minimizedItemFillColor || Colors.Navy;
                if (minimizedItemShapeType == null) {
                  minimizedItemShapeType = templateConfig.minimizedItemShapeType !== null ? templateConfig.minimizedItemShapeType : _options.minimizedItemShapeType;
                }
                minimizedItemCornerRadius = templateConfig.minimizedItemCornerRadius === null ? templateConfig.minimizedItemSize.width : templateConfig.minimizedItemCornerRadius;
                if (minimizedItemShapeType == null || minimizedItemShapeType == ShapeType.None) {
                  polyline = markers.getPolyline(new PaletteItem({
                    "lineColor": itemTitleColor,
                    "lineWidth": templateConfig.minimizedItemLineWidth,
                    "lineType": templateConfig.minimizedItemLineType,
                    "fillColor": itemFillColor,
                    "opacity": templateConfig.minimizedItemOpacity
                  }));
                  polyline.addSegment(new DotSegment(x, y, width, height, minimizedItemCornerRadius));
                } else {
                  marker.draw(
                    markers,
                    minimizedItemShapeType,
                    new Rect(x, y, width, height),
                    new PaletteItem({
                      "lineColor": itemTitleColor,
                      "lineWidth": templateConfig.minimizedItemLineWidth,
                      "lineType": templateConfig.minimizedItemLineType,
                      "fillColor": itemFillColor,
                      "opacity": templateConfig.minimizedItemOpacity
                    })
                  );
                }
                break;
              case Visibility.Invisible:
                if (_debug) {
                  itemTitleColor = Colors.Red;
                  if (!paletteItems.hasOwnProperty(itemTitleColor)) {
                    paletteItems[itemTitleColor] = new PaletteItem({
                      "lineColor": itemTitleColor,
                      "lineWidth": 1,
                      "lineType": LineType.Solid,
                      "fillColor": itemTitleColor,
                      "opacity": 1
                    });
                  }
                  polyline = markers.getPolyline(paletteItems[itemTitleColor]);
                  polyline.addSegment(new DotSegment(x - 4, y - 4, 8, 8, 4));
                }
                break;
              default:
                break;
            }
          }
        );
      }
    }
    _graphics.activate("placeholder", Layers.Marker);
    _graphics.polylinesBuffer(markers);
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawConnectorsTask.js
function DrawConnectorsTask(getGraphics, connectionsGraphTask, connectorsOptionTask, showElbowDots, paletteManagerTask) {
  function process() {
    var graphics = getGraphics();
    var graph = connectionsGraphTask.getGraph();
    var connectorsOptions = connectorsOptionTask.getOptions();
    var paletteManager = paletteManagerTask.getPaletteManager();
    graphics.reset("placeholder", Layers.Connector);
    graphics.activate("placeholder", Layers.Connector);
    var buffer = new PolylinesBuffer();
    var elbowDotRadius = Math.round(connectorsOptions.elbowDotSize / 2);
    var processed = {};
    var processedDots = {};
    graph.loopNodes(this, null, function(itemid) {
      graph.loopNodeEdges(this, itemid, function(to, connectorEdge) {
        if (!processed.hasOwnProperty(to)) {
          var paletteItem = null;
          if (connectorEdge.fromOffset <= 1) {
            paletteItem = paletteManager.getPalette(ConnectorStyleType.Regular);
          } else {
            paletteManager.selectPalette(connectorEdge.fromOffset);
            paletteItem = paletteManager.getPalette(ConnectorStyleType.Extra);
          }
          var polyline = buffer.getPolyline(paletteItem);
          if (showElbowDots && connectorEdge.dotId != null && connectorsOptions.elbowType != ElbowType.None && !processedDots.hasOwnProperty(connectorEdge.dotId)) {
            var dotPolyline = buffer.getPolyline(polyline.arrowPaletteItem);
            var dotPoint = connectorEdge.dotId == connectorEdge.from ? connectorEdge.polyline.getStartPoint() : connectorEdge.polyline.getEndPoint();
            dotPolyline.addSegment(new DotSegment(dotPoint.x - elbowDotRadius, dotPoint.y - elbowDotRadius, elbowDotRadius * 2, elbowDotRadius * 2, elbowDotRadius));
            processedDots[connectorEdge.dotId] = true;
          }
          var arrowId = null;
          if (connectorEdge.hasArrow) {
            switch (connectorsOptions.arrowsDirection) {
              case GroupByType.Parents:
                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.parentsArrowId : connectorEdge.childrenArrowId;
                break;
              case GroupByType.Children:
                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.childrenArrowId : connectorEdge.parentsArrowId;
                break;
            }
          }
          if (arrowId == null) {
            var newSegment = connectorEdge.polyline.clone();
            if (connectorEdge.hasMiddle && connectorsOptions.arrowsDirection != GroupByType.None) {
              var isForward = true;
              if (connectorEdge.from == connectorEdge.middleParent) {
                isForward = connectorsOptions.arrowsDirection == GroupByType.Children;
              } else {
                isForward = connectorsOptions.arrowsDirection == GroupByType.Parents;
              }
              if (connectorEdge.isOppositeFlow) {
                isForward = !isForward;
              }
              newSegment.addOffsetArrow(isForward, connectorsOptions.linesWidth, 0.4, connectorsOptions.extraArrowsMinimumSpace, function(arrowPolyline) {
                arrowPolyline.mergeTo(buffer.getPolyline(polyline.arrowPaletteItem));
              });
            }
            if (connectorEdge.from == itemid) {
              newSegment.mergeTo(polyline);
            } else {
              polyline.addInverted(newSegment);
            }
          } else {
            if (arrowId == connectorEdge.to) {
              connectorEdge.polyline.clone().mergeTo(polyline);
            } else {
              polyline.addInverted(connectorEdge.polyline.clone());
            }
            polyline.addArrow(connectorsOptions.linesWidth, function(arrowPolyline) {
              arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));
            });
          }
        }
      });
      processed[itemid] = true;
    });
    graphics.polylinesBuffer(buffer);
    return false;
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/graphics/structs/Label.js
function Label() {
  this.text = null;
  this.position = null;
  this.weight = 0;
  this.isActive = true;
  this.labelType = LabelType.Regular;
  this.labelOrientation = TextOrientationType.Horizontal;
  this.horizontalAlignmentType = HorizontalAlignmentType.Center;
  this.verticalAlignmentType = VerticalAlignmentType.Bottom;
  this.parent = Rect.prototype;
  this.parent.constructor.apply(this, arguments);
}
Label.prototype = new Rect();

// node_modules/basicprimitives/src/tasks/renders/DrawItemLabelsTask.js
function DrawItemLabelsTask(getGraphics, createTransformTask, applyLayoutChangesTask, labelsOptionTask, alignDiagramTask) {
  function process() {
    var labelsOption = labelsOptionTask.getOptions();
    var params = {
      graphics: getGraphics(),
      transform: createTransformTask.getTransform(),
      treeItemsPositions: alignDiagramTask.getItemsPositions()
    };
    var options = {
      showLabels: labelsOption.showLabels,
      labelFontSize: labelsOption.labelFontSize,
      labelFontFamily: labelsOption.labelFontFamily,
      labelFontStyle: labelsOption.labelFontStyle,
      labelFontWeight: labelsOption.labelFontWeight,
      labelColor: labelsOption.labelColor,
      itemsOptions: labelsOptionTask.getItemsOptions(),
      labelSize: labelsOption.labelSize,
      labelOrientation: labelsOption.labelOrientation,
      labelPlacement: labelsOption.labelPlacement,
      labelOffset: labelsOption.labelOffset
    };
    params.graphics.reset("placeholder", Layers.Label);
    redrawLabels(params, options);
    return false;
  }
  function redrawLabels(params, options) {
    var labels = [];
    if (options.showLabels == Enabled.Auto || options.showLabels == Enabled.True) {
      for (var treeItemId in params.treeItemsPositions) {
        if (params.treeItemsPositions.hasOwnProperty(treeItemId)) {
          var labelOptions = options.itemsOptions[treeItemId], treeItemPosition = params.treeItemsPositions[treeItemId], actualPosition = treeItemPosition.actualPosition;
          if (labelOptions != null) {
            params.transform.transformRect(
              actualPosition.x,
              actualPosition.y,
              actualPosition.width,
              actualPosition.height,
              true,
              this,
              function(x, y, width, height) {
                switch (treeItemPosition.actualVisibility) {
                  case Visibility.Normal:
                    if (options.showLabels == Enabled.Auto) {
                      label2 = new Label(x, y, width, height);
                      label2.weight = 1e4;
                      label2.labelType = LabelType.Dummy;
                      labels.push(label2);
                    }
                    break;
                  case Visibility.Dot:
                  case Visibility.Line:
                    var label2 = createLabel(x, y, width, height, labelOptions, treeItemPosition, options);
                    if (label2 != null) {
                      labels.push(label2);
                    }
                    break;
                  default:
                    break;
                }
              }
            );
          }
        }
      }
    }
    if (options.showLabels == Enabled.Auto) {
      getCrossingRectangles(this, labels, function(label1, label2) {
        if (label1.isActive && label2.isActive) {
          switch (label1.labelType) {
            case LabelType.Dummy:
              switch (label2.labelType) {
                case LabelType.Dummy:
                  break;
                case LabelType.Regular:
                  label2.isActive = false;
                  break;
                case LabelType.Fixed:
                  label2.isActive = false;
                  break;
              }
              break;
            case LabelType.Fixed:
              switch (label2.labelType) {
                case LabelType.Dummy:
                  label1.isActive = false;
                  break;
                case LabelType.Regular:
                  label2.isActive = false;
                  break;
                case LabelType.Fixed:
                  break;
              }
              break;
            case LabelType.Regular:
              switch (label2.labelType) {
                case LabelType.Dummy:
                  label1.isActive = false;
                  break;
                case LabelType.Regular:
                  if (label1.weight <= label2.weight) {
                    label1.isActive = false;
                  } else {
                    label2.isActive = false;
                  }
                  break;
                case LabelType.Fixed:
                  label1.isActive = false;
                  break;
              }
              break;
          }
        }
      });
    }
    params.graphics.activate("placeholder", Layers.Label);
    var attr = {
      "fontSize": options.labelFontSize,
      "fontFamily": options.labelFontFamily,
      "fontStyle": options.labelFontStyle,
      "fontWeight": options.labelFontWeight,
      "fontColor": options.labelColor
    };
    for (var index = 0, len = labels.length; index < len; index += 1) {
      var label = labels[index];
      if (label.isActive) {
        switch (label.labelType) {
          case LabelType.Regular:
          case LabelType.Fixed:
            params.graphics.text(
              label.x,
              label.y,
              label.width,
              label.height,
              label.text,
              label.labelOrientation,
              label.horizontalAlignmentType,
              label.verticalAlignmentType,
              attr
            );
            break;
        }
      }
    }
  }
  function createLabel(x, y, width, height, labelOptions, treeItemPosition, options) {
    var result = null, labelWidth, labelHeight, labelSize, labelPlacement, weight;
    if (!isNullOrEmpty(labelOptions.label)) {
      var labelType = getLabelType(treeItemPosition.actualVisibility, labelOptions.showLabel, options.showLabels);
      switch (labelType) {
        case LabelType.Regular:
          weight = treeItemPosition.actualSize.width + treeItemPosition.actualSize.height;
          break;
        case LabelType.Fixed:
          weight = 1e4;
          break;
        case LabelType.None:
          weight = 0;
          break;
      }
      if (labelType != LabelType.None) {
        labelSize = labelOptions.labelSize != null ? labelOptions.labelSize : options.labelSize;
        var labelOrientation = labelOptions.labelOrientation != TextOrientationType.Auto ? labelOptions.labelOrientation : options.labelOrientation != TextOrientationType.Auto ? options.labelOrientation : TextOrientationType.Horizontal;
        labelPlacement = labelOptions.labelPlacement != PlacementType.Auto ? labelOptions.labelPlacement : options.labelPlacement != PlacementType.Auto ? options.labelPlacement : PlacementType.Top;
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            labelWidth = labelSize.width;
            labelHeight = labelSize.height;
            break;
          case TextOrientationType.RotateLeft:
          case TextOrientationType.RotateRight:
            labelHeight = labelSize.width;
            labelWidth = labelSize.height;
            break;
        }
        var position = getLabelPosition(labelPlacement, labelOrientation, x, y, width, height, labelWidth, labelHeight, options.labelOffset);
        result = new Label(position.position);
        result.labelType = labelType;
        result.weight = weight;
        result.text = labelOptions.label;
        result.labelOrientation = labelOrientation;
        result.horizontalAlignmentType = position.horizontalAlignmentType;
        result.verticalAlignmentType = position.verticalAlignmentType;
      }
    }
    return result;
  }
  function getLabelType(actualVisibility, showLabel, showLabels) {
    var result = LabelType.None;
    switch (showLabel) {
      case Enabled.Auto:
        switch (showLabels) {
          case Enabled.Auto:
            switch (actualVisibility) {
              case Visibility.Line:
              case Visibility.Dot:
                result = LabelType.Regular;
                break;
              default:
                break;
            }
            break;
          case Enabled.False:
            break;
          case Enabled.True:
            result = LabelType.Fixed;
            break;
        }
        break;
      case Enabled.False:
        break;
      case Enabled.True:
        result = LabelType.Fixed;
        break;
    }
    return result;
  }
  function getLabelPosition(labelPlacement, labelOrientation, x, y, width, height, labelWidth, labelHeight, labelOffset) {
    var position, horizontalAlignmentType, verticalAlignmentType;
    switch (labelPlacement) {
      case PlacementType.Auto:
      case PlacementType.Top:
        position = new Rect(x + width / 2 - labelWidth / 2, y - labelOffset - labelHeight, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
        }
        break;
      case PlacementType.TopRight:
      case PlacementType.RightTop:
        position = new Rect(x + width + labelOffset, y - labelOffset - labelHeight, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
        }
        break;
      case PlacementType.Right:
        position = new Rect(x + width + labelOffset, y + height / 2 - labelHeight / 2, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
        }
        break;
      case PlacementType.BottomRight:
      case PlacementType.RightBottom:
        position = new Rect(x + width + labelOffset, y + height + labelOffset, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
        }
        break;
      case PlacementType.Bottom:
        position = new Rect(x + width / 2 - labelWidth / 2, y + height + labelOffset, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
        }
        break;
      case PlacementType.BottomLeft:
      case PlacementType.LeftBottom:
        position = new Rect(x - labelWidth - labelOffset, y + height + labelOffset, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
        }
        break;
      case PlacementType.Left:
        position = new Rect(x - labelWidth - labelOffset, y + height / 2 - labelHeight / 2, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Middle;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Center;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
        }
        break;
      case PlacementType.TopLeft:
      case PlacementType.LeftTop:
        position = new Rect(x - labelWidth - labelOffset, y - labelOffset - labelHeight, labelWidth, labelHeight);
        switch (labelOrientation) {
          case TextOrientationType.Horizontal:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateLeft:
            horizontalAlignmentType = HorizontalAlignmentType.Left;
            verticalAlignmentType = VerticalAlignmentType.Bottom;
            break;
          case TextOrientationType.RotateRight:
            horizontalAlignmentType = HorizontalAlignmentType.Right;
            verticalAlignmentType = VerticalAlignmentType.Top;
            break;
        }
        break;
    }
    return {
      position,
      horizontalAlignmentType,
      verticalAlignmentType
    };
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawFrameItemsTask.js
function DrawFrameItemsTask(getGraphics, applyLayoutChangesTask, projectItemsToFrameTask, itemTemplateParamsTask, minimizedItemsOptionTask) {
  var _graphics;
  function process() {
    var frameThickness = new Thickness(applyLayoutChangesTask.getFrameThickness());
    _graphics = getGraphics();
    _graphics.reset("frameplaceholder", Layers.Marker);
    if (!frameThickness.isEmpty()) {
      drawFrameItems();
    }
    return false;
  }
  function drawFrameItems() {
    var markers = new PolylinesBuffer(), positions = projectItemsToFrameTask.getPositions(), options = minimizedItemsOptionTask.getOptions(), marker = new Marker(), polyline;
    for (var treeItemId in positions) {
      if (positions.hasOwnProperty(treeItemId)) {
        var actualPosition = positions[treeItemId], templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId), templateConfig = templateParams.template.templateConfig, minimizedItemsOptions = minimizedItemsOptionTask.getItemOptions(treeItemId), itemTitleColor = null, itemFillColor = null, minimizedItemShapeType = null, minimizedItemCornerRadius = 0;
        if (minimizedItemsOptions != null) {
          itemTitleColor = minimizedItemsOptions.itemTitleColor;
          itemFillColor = minimizedItemsOptions.itemTitleColor;
          minimizedItemShapeType = minimizedItemsOptions.minimizedItemShapeType;
        }
        itemTitleColor = itemTitleColor || templateConfig.minimizedItemBorderColor || Colors.Navy;
        itemFillColor = itemFillColor || templateConfig.minimizedItemFillColor || Colors.Navy;
        if (minimizedItemShapeType == null) {
          minimizedItemShapeType = templateConfig.minimizedItemShapeType !== null ? templateConfig.minimizedItemShapeType : options.minimizedItemShapeType;
        }
        minimizedItemCornerRadius = templateConfig.minimizedItemCornerRadius === null ? templateConfig.minimizedItemSize.width : templateConfig.minimizedItemCornerRadius;
        if (minimizedItemShapeType == null || minimizedItemShapeType == ShapeType.None) {
          polyline = markers.getPolyline(new PaletteItem({
            "lineColor": itemTitleColor,
            "lineWidth": templateConfig.minimizedItemLineWidth,
            "lineType": templateConfig.minimizedItemLineType,
            "fillColor": itemFillColor,
            "opacity": templateConfig.minimizedItemOpacity
          }));
          polyline.addSegment(new DotSegment(actualPosition.x, actualPosition.y, actualPosition.width, actualPosition.height, minimizedItemCornerRadius));
        } else {
          marker.draw(
            markers,
            minimizedItemShapeType,
            actualPosition,
            new PaletteItem({
              "lineColor": itemTitleColor,
              "lineWidth": templateConfig.minimizedItemLineWidth,
              "lineType": templateConfig.minimizedItemLineType,
              "fillColor": itemFillColor,
              "opacity": templateConfig.minimizedItemOpacity
            })
          );
        }
      }
    }
    _graphics.activate("frameplaceholder", Layers.Marker);
    _graphics.polylinesBuffer(markers);
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawFrameHighlightTask.js
function DrawFrameHighlightTask(getGraphics, projectItemsToFrameTask, combinedContextsTask, itemTemplateParamsTask, highlightItemTask, cursorItemTask) {
  var _graphics;
  function process() {
    var treeItemId = highlightItemTask.getHighlightTreeItem();
    _graphics = getGraphics();
    _graphics.reset("frameplaceholder", Layers.Highlight);
    if (treeItemId != null) {
      drawHighlight(treeItemId);
    }
    return false;
  }
  function drawHighlight(treeItemId) {
    var uiHash, positions = projectItemsToFrameTask.getPositions(), position = positions[treeItemId];
    if (position != null) {
      var templateParams = itemTemplateParamsTask.getTemplateParams(treeItemId), template = templateParams.template, templateConfig = template.templateConfig, highlightPadding = templateConfig.highlightPadding;
      _graphics.activate("frameplaceholder", Layers.Highlight);
      uiHash = new RenderEventArgs();
      uiHash.context = combinedContextsTask.getConfig(treeItemId);
      uiHash.isCursor = cursorItemTask.getCursorTreeItem() == treeItemId;
      uiHash.isSelected = true;
      uiHash.templateName = templateConfig.name;
      var contentPosition = new Rect(0, 0, Math.round(position.width), Math.round(position.height));
      contentPosition.offset(highlightPadding.left, highlightPadding.top, highlightPadding.right, highlightPadding.bottom);
      _graphics.template(
        Math.round(position.x),
        Math.round(position.y),
        Math.round(position.width),
        Math.round(position.height),
        Math.round(contentPosition.x),
        Math.round(contentPosition.y),
        Math.round(contentPosition.width),
        Math.round(contentPosition.height),
        template.dotHighlightTemplate.template(),
        template.dotHighlightTemplate.getHashCode(),
        template.dotHighlightTemplate.render,
        uiHash,
        { "borderWidth": templateConfig.highlightBorderWidth }
      );
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawLevelAnnotationTitlesTask.js
function DrawLevelAnnotationTitlesTask(getGraphics, verticalOffsetTask, createTransformTask, applyLayoutChangesTask, levelAnnotationOptionTask, mergeLevelIntervalsTask, levelAnnotationTemplateTask, levelTitlePlacementOptionTask) {
  var _graphics, _positions, _transform, _template;
  function process() {
    var annotations = levelAnnotationOptionTask.getAnnotations();
    _graphics = getGraphics();
    _graphics.reset("titlesplaceholder", Layers.LevelAnnotation);
    if (annotations.length > 0) {
      _positions = mergeLevelIntervalsTask.getPositions();
      _transform = createTransformTask.getTransform();
      _template = levelAnnotationTemplateTask.getTitleTemplate();
      drawAnnotations(annotations, _positions);
    }
    return false;
  }
  function drawAnnotations(annotations, positions) {
    var verticalOffset = new Interval(verticalOffsetTask.getVerticalOffset()), { levelTitlePanelSize } = levelTitlePlacementOptionTask.getOptions();
    _graphics.activate("titlesplaceholder", Layers.LevelAnnotation);
    var transformedVerticalOffset;
    _transform.transformRect(
      0,
      verticalOffset.from,
      0,
      verticalOffset.width(),
      true,
      this,
      function(x, y, width, height) {
        transformedVerticalOffset = new Rect(x, y, width, height);
      }
    );
    for (var index = 0, len = annotations.length; index < len; index += 1) {
      var annotationConfig = annotations[index];
      var intervals = positions[index];
      if (intervals != null) {
        for (var index3 = 0, len3 = intervals.length; index3 < len3; index3 += 1) {
          var interval = intervals[index3];
          var position = new Rect(0, interval.from, levelTitlePanelSize, interval.width());
          var verticalInterval = position.verticalInterval();
          if (verticalInterval.overlaps(verticalOffset)) {
            var offset = new Thickness(0, annotationConfig.offset.top, 0, annotationConfig.offset.bottom);
            position.offset(offset);
            var uiHash = new RenderEventArgs();
            uiHash.context = annotationConfig;
            _transform.transformRect(
              position.x,
              position.y,
              position.width,
              position.height,
              true,
              this,
              function(x, y, width, height) {
                _graphics.template(
                  x - transformedVerticalOffset.x,
                  y - transformedVerticalOffset.y,
                  width,
                  height,
                  0,
                  0,
                  width,
                  height,
                  _template.template(),
                  _template.getHashCode(),
                  _template.render,
                  uiHash,
                  null
                );
              }
            );
          }
        }
      }
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/tasks/renders/DrawLevelAnnotationBackgroundTask.js
function DrawLevelAnnotationBackgroundTask(getGraphics, verticalOffsetTask, createTransformTask, applyLayoutChangesTask, levelAnnotationOptionTask, mergeLevelIntervalsTask, levelAnnotationTemplateTask) {
  var _graphics, _positions, _transform, _backgroundTemplate;
  function process() {
    var annotations = levelAnnotationOptionTask.getAnnotations();
    _graphics = getGraphics();
    _graphics.reset("placeholder", Layers.LevelAnnotation);
    if (annotations.length > 0) {
      _positions = mergeLevelIntervalsTask.getPositions();
      _transform = createTransformTask.getTransform();
      _backgroundTemplate = levelAnnotationTemplateTask.getBackgroundTemplate();
      drawAnnotations(annotations, _positions);
    }
    return false;
  }
  function drawAnnotations(annotations, positions) {
    var verticalOffset = new Interval(verticalOffsetTask.getVerticalOffset()), panel = _graphics.activate("placeholder", Layers.LevelAnnotation), panelRect;
    _transform.transformRect(
      0,
      0,
      panel.size.width,
      panel.size.height,
      false,
      this,
      function(x, y, width, height) {
        panelRect = new Rect(x, y, width, height);
      }
    );
    for (var index = 0, len = annotations.length; index < len; index += 1) {
      var annotationConfig = annotations[index];
      var lineWidth = _transform.transformThickness(annotationConfig.lineWidth, true);
      var intervals = positions[index];
      if (intervals != null) {
        for (var index3 = 0, len3 = intervals.length; index3 < len3; index3 += 1) {
          var interval = intervals[index3];
          var position = new Rect(0, interval.from, panelRect.width, interval.width());
          position.offset(annotationConfig.offset);
          var verticalInterval = position.verticalInterval();
          if (verticalInterval.overlaps(verticalOffset)) {
            var uiHash = new RenderEventArgs();
            uiHash.context = annotationConfig;
            mergeObjects(uiHash.context, { lineWidth });
            _transform.transformRect(
              position.x,
              position.y,
              position.width,
              position.height,
              true,
              this,
              function(x, y, width, height) {
                _graphics.template(
                  x,
                  y,
                  width,
                  height,
                  0,
                  0,
                  width,
                  height,
                  _backgroundTemplate.template(),
                  _backgroundTemplate.getHashCode(),
                  _backgroundTemplate.render,
                  uiHash,
                  null
                );
              }
            );
          }
        }
      }
    }
  }
  return {
    process
  };
}

// node_modules/basicprimitives/src/OrgTaskManagerFactory.js
function TaskManagerFactory(getOptions, getGraphics, getLayout, setLayout, templates) {
  var tasks = new TaskManager();
  tasks.addDependency("options", getOptions);
  tasks.addDependency("graphics", getGraphics);
  tasks.addDependency("getLayout", getLayout);
  tasks.addDependency("setLayout", setLayout);
  tasks.addDependency("templates", templates);
  tasks.addDependency("defaultConfig", new OrgConfig());
  tasks.addDependency("defaultItemConfig", new OrgItemConfig());
  tasks.addDependency("defaultTemplateConfig", new TemplateConfig());
  tasks.addDependency("defaultBackgroundAnnotationConfig", new BackgroundAnnotationConfig());
  tasks.addDependency("defaultConnectorAnnotationConfig", new ConnectorAnnotationConfig());
  tasks.addDependency("defaultHighlightPathAnnotationConfig", new HighlightPathAnnotationConfig());
  tasks.addDependency("defaultShapeAnnotationConfig", new ShapeAnnotationConfig());
  tasks.addDependency("defaultLevelAnnotationConfig", new LevelAnnotationConfig());
  tasks.addDependency("showElbowDots", false);
  tasks.addDependency("null", null);
  tasks.addDependency("foreground", ZOrderType.Foreground);
  tasks.addDependency("background", ZOrderType.Background);
  tasks.addTask("OptionsTask", ["options"], OptionsTask, Colors.Black);
  tasks.addTask("CalloutOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], CalloutOptionTask, Colors.Navy);
  tasks.addTask("ConnectorsOptionTask", ["OptionsTask", "defaultConfig"], ConnectorsOptionTask, Colors.Navy);
  tasks.addTask("ItemsOptionTask", ["OptionsTask", "defaultItemConfig"], OrgItemsOptionTask, Colors.Navy);
  tasks.addTask("ItemsContentOptionTask", ["OptionsTask", "defaultItemConfig"], ItemsContentOptionTask, Colors.Navy);
  tasks.addTask("ItemsSizesOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], ItemsSizesOptionTask, Colors.Navy);
  tasks.addTask("MinimumVisibleLevelsOptionTask", ["OptionsTask", "defaultConfig"], MinimumVisibleLevelsOptionTask, Colors.Navy);
  tasks.addTask("LabelsOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], LabelsOptionTask, Colors.Navy);
  tasks.addTask("TemplatesOptionTask", ["OptionsTask", "defaultConfig", "defaultTemplateConfig"], TemplatesOptionTask, Colors.Navy);
  tasks.addTask("OrientationOptionTask", ["OptionsTask", "defaultConfig"], OrientationOptionTask, Colors.Navy);
  tasks.addTask("VisualTreeOptionTask", ["OptionsTask", "defaultConfig"], OrgVisualTreeOptionTask, Colors.Navy);
  tasks.addTask("MinimizedItemsOptionTask", ["OptionsTask"], MinimizedItemsOptionTask, Colors.Navy);
  tasks.addTask("CursorItemOptionTask", ["OptionsTask", "defaultConfig"], CursorItemOptionTask, Colors.Navy);
  tasks.addTask("HighlightItemOptionTask", ["OptionsTask", "defaultConfig"], HighlightItemOptionTask, Colors.Navy);
  tasks.addTask("SelectedItemsOptionTask", ["OptionsTask"], SelectedItemsOptionTask, Colors.Navy);
  tasks.addTask("CursorSelectionPathModeOptionTask", ["OptionsTask", "defaultConfig"], CursorSelectionPathModeOptionTask, Colors.Navy);
  tasks.addTask("SplitAnnotationsOptionTask", ["OptionsTask"], SplitAnnotationsOptionTask, Colors.Cyan);
  tasks.addTask("ForegroundShapeAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultShapeAnnotationConfig", "foreground"], ShapeAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundShapeAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultShapeAnnotationConfig", "background"], ShapeAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ForegroundHighlightPathAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultHighlightPathAnnotationConfig", "foreground"], HighlightPathAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundHighlightPathAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultHighlightPathAnnotationConfig", "background"], HighlightPathAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ForegroundConnectorAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultConnectorAnnotationConfig", "foreground"], ConnectorAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundConnectorAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultConnectorAnnotationConfig", "background"], ConnectorAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultBackgroundAnnotationConfig"], BackgroundAnnotationOptionTask, Colors.Navy);
  tasks.addTask("LevelAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultLevelAnnotationConfig"], LevelAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ScaleOptionTask", ["OptionsTask", "defaultConfig"], ScaleOptionTask, Colors.Navy);
  tasks.addTask("FrameOptionTask", ["OptionsTask", "defaultConfig"], FrameOptionTask, Colors.Navy);
  tasks.addTask("LevelTitlePlacementOptionTask", ["OptionsTask", "defaultConfig"], LevelTitlePlacementOptionTask, Colors.Navy);
  tasks.addTask("LevelTitleTemplateOptionTask", ["OptionsTask", "defaultConfig"], LevelTitleTemplateOptionTask, Colors.Navy);
  tasks.addTask("CombinedContextsTask", ["ItemsContentOptionTask"], CombinedContextsTask, Colors.Cyan);
  tasks.addTask("OrgTreeTask", ["ItemsOptionTask"], OrgTreeTask, Colors.Red);
  tasks.addTask("ReadTemplatesTask", ["TemplatesOptionTask", "templates"], ReadTemplatesTask, Colors.Cyan);
  tasks.addTask("ActiveItemsTask", ["ItemsSizesOptionTask", "ReadTemplatesTask"], ActiveItemsTask, Colors.Cyan);
  tasks.addTask("ItemTemplateParamsTask", ["ItemsSizesOptionTask", "CursorItemOptionTask", "ReadTemplatesTask"], ItemTemplateParamsTask, Colors.Cyan);
  tasks.addTask("GroupTitleTemplateTask", ["TemplatesOptionTask", "templates"], GroupTitleTemplateTask, Colors.Cyan);
  tasks.addTask("CheckBoxTemplateTask", ["ItemsSizesOptionTask", "templates"], CheckBoxTemplateTask, Colors.Cyan);
  tasks.addTask("ButtonsTemplateTask", ["ItemsSizesOptionTask", "templates"], ButtonsTemplateTask, Colors.Cyan);
  tasks.addTask("AnnotationLabelTemplateTask", ["ItemsOptionTask", "templates"], AnnotationLabelTemplateTask, Colors.Cyan);
  tasks.addTask("LevelAnnotationTemplateTask", ["OrientationOptionTask", "LevelTitleTemplateOptionTask", "templates"], LevelAnnotationTemplateTask, Colors.Cyan);
  tasks.addTask("VisualTreeTask", ["OrgTreeTask", "ActiveItemsTask", "VisualTreeOptionTask"], VisualTreeTask, Colors.Red);
  tasks.addTask("VisualTreeLevelsTask", ["VisualTreeTask", "ItemTemplateParamsTask"], VisualTreeLevelsTask, Colors.Red);
  tasks.addTask("ExtractNestedLayoutsTask", ["OptionsTask"], OrgExtractNestedLayoutsTask, Colors.Red);
  tasks.addTask("CreateLayoutsTreeTask", ["VisualTreeTask", "VisualTreeLevelsTask", "ExtractNestedLayoutsTask"], OrgCreateLayoutsTreeTask, Colors.Red);
  tasks.addTask("ConnectionsGraphTask", ["graphics", "CreateTransformTask", "ConnectorsOptionTask", "VisualTreeLevelsTask", "ExtractNestedLayoutsTask", "AlignDiagramTask"], ConnectionsGraphTask, Colors.Cyan);
  tasks.addTask("HighlightItemTask", ["HighlightItemOptionTask", "ActiveItemsTask"], HighlightItemTask, Colors.Cyan);
  tasks.addTask("CursorItemTask", ["CursorItemOptionTask", "ActiveItemsTask"], CursorItemTask, Colors.Cyan);
  tasks.addTask("CursorNeighboursTask", ["CursorItemTask", "VisualTreeTask"], OrgCursorNeighboursTask, Colors.Cyan);
  tasks.addTask("SelectedItemsTask", ["SelectedItemsOptionTask", "ItemsOptionTask"], SelectedItemsTask, Colors.Cyan);
  tasks.addTask("SelectionPathItemsTask", ["VisualTreeTask", "CursorItemTask", "SelectedItemsTask", "CursorSelectionPathModeOptionTask"], OrgSelectionPathItemsTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundShapeAnnotationTask", ["ForegroundShapeAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundShapeAnnotationTask", ["BackgroundShapeAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundAnnotationTask", ["BackgroundAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundHighlightPathAnnotationTask", ["ForegroundHighlightPathAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundHighlightPathAnnotationTask", ["BackgroundHighlightPathAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundConnectorAnnotationTask", ["ForegroundConnectorAnnotationOptionTask"], NormalVisibilityItemsByConnectorAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundConnectorAnnotationTask", ["BackgroundConnectorAnnotationOptionTask"], NormalVisibilityItemsByConnectorAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByMinimumVisibleLevelsTask", ["MinimumVisibleLevelsOptionTask", "OrgTreeTask"], OrgNormalVisibilityItemsByMinimumVisibleLevelsTask, Colors.Cyan);
  tasks.addTask("CombinedNormalVisibilityItemsTask", [
    "ItemsSizesOptionTask",
    "CursorItemTask",
    "CursorNeighboursTask",
    "SelectedItemsTask",
    "SelectionPathItemsTask",
    "NormalVisibilityItemsByForegroundShapeAnnotationTask",
    "NormalVisibilityItemsByBackgroundShapeAnnotationTask",
    "NormalVisibilityItemsByBackgroundAnnotationTask",
    "NormalVisibilityItemsByForegroundHighlightPathAnnotationTask",
    "NormalVisibilityItemsByBackgroundHighlightPathAnnotationTask",
    "NormalVisibilityItemsByForegroundConnectorAnnotationTask",
    "NormalVisibilityItemsByBackgroundConnectorAnnotationTask",
    "NormalVisibilityItemsByMinimumVisibleLevelsTask"
  ], CombinedNormalVisibilityItemsTask, Colors.Cyan);
  tasks.addTask("FrameSizeTask", ["FrameOptionTask", "ReadTemplatesTask", "ScaleOptionTask"], FrameSizeTask, Colors.Navy);
  tasks.addTask("LevelTitleSizeTask", ["LevelTitlePlacementOptionTask", "LevelAnnotationOptionTask", "OrientationOptionTask", "ScaleOptionTask"], LevelTitleSizeTask, Colors.Navy);
  tasks.addTask("LayoutOptionsTask", ["getLayout", "OptionsTask"], LayoutOptionsTask, Colors.Black);
  tasks.addTask("CurrentControlSizeTask", ["LayoutOptionsTask", "ItemsSizesOptionTask", "FrameSizeTask", "LevelTitleSizeTask"], CurrentControlSizeTask, Colors.Black);
  tasks.addTask("CurrentScrollPositionTask", ["LayoutOptionsTask"], CurrentScrollPositionTask, Colors.Black);
  tasks.addTask("ItemsPositionsTask", [
    "CurrentControlSizeTask",
    "ScaleOptionTask",
    "OrientationOptionTask",
    "ItemsSizesOptionTask",
    "ConnectorsOptionTask",
    "VisualTreeOptionTask",
    "CreateLayoutsTreeTask",
    "ItemTemplateParamsTask",
    "CursorItemTask",
    "CombinedNormalVisibilityItemsTask"
  ], ItemsPositionsTask, Colors.Red);
  tasks.addTask("AlignDiagramTask", ["OrientationOptionTask", "ItemsSizesOptionTask", "VisualTreeOptionTask", "ScaleOptionTask", "CurrentControlSizeTask", "ActiveItemsTask", "ItemsPositionsTask"], AlignDiagramTask, Colors.Red);
  tasks.addTask("CreateTransformTask", ["OrientationOptionTask", "ScaleOptionTask", "AlignDiagramTask"], CreateTransformTask, Colors.Cyan);
  tasks.addTask("PaletteManagerTask", ["ConnectorsOptionTask", "null"], PaletteManagerTask, Colors.Cyan);
  tasks.addTask("ApplyLayoutChangesTask", ["graphics", "setLayout", "ItemsSizesOptionTask", "CurrentControlSizeTask", "ScaleOptionTask", "AlignDiagramTask", "FrameSizeTask", "LevelTitleSizeTask"], ApplyLayoutChangesTask, Colors.Green);
  tasks.addTask("CenterOnCursorTask", ["LayoutOptionsTask", "ApplyLayoutChangesTask", "CurrentScrollPositionTask", "CursorItemTask", "AlignDiagramTask", "CreateTransformTask", "ScaleOptionTask"], CenterOnCursorTask, Colors.Cyan);
  tasks.addTask("ProjectItemsToFrameTask", [
    "CreateTransformTask",
    "FrameSizeTask",
    "ApplyLayoutChangesTask",
    "ScaleOptionTask",
    "AlignDiagramTask",
    "CenterOnCursorTask",
    "ItemTemplateParamsTask",
    "SelectedItemsTask"
  ], ProjectItemsToFrameTask, Colors.Green);
  tasks.addTask("ViewPortPlacementTask", ["ScaleOptionTask", "CenterOnCursorTask", "CreateTransformTask", "ApplyLayoutChangesTask"], ViewPortPlacementTask, Colors.Green);
  tasks.addTask("VerticalOffsetTask", ["ViewPortPlacementTask"], VerticalOffsetTask, Colors.Green);
  tasks.addTask("LogicalLevelsPlacementTask", ["OrgTreeTask", "VisualTreeTask", "AlignDiagramTask"], OrgLogicalLevelsPlacementTask, Colors.Green);
  tasks.addTask("MergeLevelIntervalsTask", ["LevelAnnotationOptionTask", "LogicalLevelsPlacementTask"], MergeLevelIntervalsTask, Colors.Green);
  tasks.addTask("DrawBackgroundAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "BackgroundAnnotationOptionTask", "VisualTreeTask", "AlignDiagramTask"], DrawBackgroundAnnotationTask, Colors.Green);
  tasks.addTask("DrawBackgroundHighlightPathAnnotationTask", ["graphics", "ConnectorsOptionTask", "ForegroundHighlightPathAnnotationOptionTask", "ConnectionsGraphTask", "foreground"], DrawHighlightPathAnnotationTask, Colors.Cyan);
  tasks.addTask("DrawForegroundHighlightPathAnnotationTask", ["graphics", "ConnectorsOptionTask", "BackgroundHighlightPathAnnotationOptionTask", "ConnectionsGraphTask", "background"], DrawHighlightPathAnnotationTask, Colors.Cyan);
  tasks.addTask("DrawForegroundConnectorAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "ForegroundConnectorAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "foreground"], DrawConnectorAnnotationTask, Colors.Green);
  tasks.addTask("DrawBackgroundConnectorAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "BackgroundConnectorAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "background"], DrawConnectorAnnotationTask, Colors.Green);
  tasks.addTask("DrawForegroundShapeAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "ForegroundShapeAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "foreground"], DrawShapeAnnotationTask, Colors.Green);
  tasks.addTask("DrawBackgroundShapeAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "BackgroundShapeAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "background"], DrawShapeAnnotationTask, Colors.Green);
  tasks.addTask("DrawCursorTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "CombinedContextsTask", "AlignDiagramTask", "ItemTemplateParamsTask", "CursorItemTask", "SelectedItemsTask"], DrawCursorTask, Colors.Green);
  tasks.addTask("DrawHighlightTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "CombinedContextsTask", "AlignDiagramTask", "ItemTemplateParamsTask", "HighlightItemTask", "CursorItemTask", "SelectedItemsTask"], DrawHighlightTask, Colors.Green);
  tasks.addTask("DrawHighlightAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "ScaleOptionTask", "CombinedContextsTask", "CalloutOptionTask", "ReadTemplatesTask", "AlignDiagramTask", "CenterOnCursorTask", "HighlightItemTask", "CursorItemTask", "SelectedItemsTask", "FrameSizeTask"], DrawHighlightAnnotationTask, Colors.Green);
  tasks.addTask("DrawTreeItemsTask", [
    "graphics",
    "CreateTransformTask",
    "ApplyLayoutChangesTask",
    "ScaleOptionTask",
    "ItemsSizesOptionTask",
    "CombinedContextsTask",
    "AlignDiagramTask",
    "CenterOnCursorTask",
    "ItemTemplateParamsTask",
    "CursorItemTask",
    "SelectedItemsTask",
    "GroupTitleTemplateTask",
    "CheckBoxTemplateTask",
    "ButtonsTemplateTask"
  ], DrawTreeItemsTask, Colors.Green);
  tasks.addTask("DrawMinimizedItemsTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "MinimizedItemsOptionTask", "ItemTemplateParamsTask", "AlignDiagramTask"], DrawMinimizedItemsTask, Colors.Green);
  tasks.addTask("DrawConnectorsTask", ["graphics", "ConnectionsGraphTask", "ConnectorsOptionTask", "showElbowDots", "PaletteManagerTask"], DrawConnectorsTask, Colors.Green);
  tasks.addTask("DrawItemLabelsTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "LabelsOptionTask", "AlignDiagramTask"], DrawItemLabelsTask, Colors.Green);
  tasks.addTask("DrawFrameItemsTask", ["graphics", "ApplyLayoutChangesTask", "ProjectItemsToFrameTask", "ItemTemplateParamsTask", "MinimizedItemsOptionTask"], DrawFrameItemsTask, Colors.Green);
  tasks.addTask("DrawFrameHighlightTask", ["graphics", "ProjectItemsToFrameTask", "CombinedContextsTask", "ItemTemplateParamsTask", "HighlightItemTask", "CursorItemTask"], DrawFrameHighlightTask, Colors.Green);
  tasks.addTask("DrawLevelAnnotationBackgroundTask", ["graphics", "VerticalOffsetTask", "CreateTransformTask", "ApplyLayoutChangesTask", "LevelAnnotationOptionTask", "MergeLevelIntervalsTask", "LevelAnnotationTemplateTask"], DrawLevelAnnotationBackgroundTask, Colors.Green);
  tasks.addTask("DrawLevelAnnotationTitlesTask", ["graphics", "VerticalOffsetTask", "CreateTransformTask", "ApplyLayoutChangesTask", "LevelAnnotationOptionTask", "MergeLevelIntervalsTask", "LevelAnnotationTemplateTask", "LevelTitlePlacementOptionTask"], DrawLevelAnnotationTitlesTask, Colors.Green);
  return tasks;
}

// node_modules/basicprimitives/src/graphics/Cache.js
function Cache() {
  this.threshold = 20;
  this.m_visible = {};
  this.m_invisible = {};
}
Cache.prototype.begin = function() {
  var placeholder, type, index, control;
  for (placeholder in this.m_visible) {
    if (this.m_visible.hasOwnProperty(placeholder)) {
      for (type in this.m_visible[placeholder]) {
        if (this.m_visible[placeholder].hasOwnProperty(type)) {
          for (index = this.m_visible[placeholder][type].length - 1; index >= 0; index -= 1) {
            control = this.m_visible[placeholder][type][index];
            control.style.visibility = "hidden";
            this.m_invisible[placeholder][type].push(control);
          }
          this.m_visible[placeholder][type].length = 0;
        }
      }
    }
  }
};
Cache.prototype.end = function() {
  var placeholder, type, control;
  for (placeholder in this.m_visible) {
    if (this.m_visible.hasOwnProperty(placeholder)) {
      for (type in this.m_visible[placeholder]) {
        if (this.m_visible[placeholder].hasOwnProperty(type)) {
          control = null;
          if (this.m_invisible[placeholder][type].length > this.threshold) {
            while ((control = this.m_invisible[placeholder][type].pop()) !== void 0) {
              control.parentNode.removeChild(control);
            }
          }
        }
      }
    }
  }
};
Cache.prototype.reset = function(placeholder, layer) {
  placeholder = placeholder + "-" + layer;
  var control = null, type, index;
  for (type in this.m_visible[placeholder]) {
    if (this.m_visible[placeholder].hasOwnProperty(type)) {
      for (index = this.m_visible[placeholder][type].length - 1; index >= 0; index -= 1) {
        control = this.m_visible[placeholder][type][index];
        this.m_invisible[placeholder][type].push(control);
        control.style.visibility = "hidden";
      }
      this.m_visible[placeholder][type].length = 0;
    }
  }
};
Cache.prototype.clear = function() {
  var placeholder, type, control;
  for (placeholder in this.m_visible) {
    if (this.m_visible.hasOwnProperty(placeholder)) {
      for (type in this.m_visible[placeholder]) {
        if (this.m_visible[placeholder].hasOwnProperty(type)) {
          control = null;
          while ((control = this.m_visible[placeholder][type].pop()) !== void 0) {
            control.parentNode.removeChild(control);
          }
          while ((control = this.m_invisible[placeholder][type].pop()) !== void 0) {
            control.parentNode.removeChild(control);
          }
        }
      }
    }
  }
};
Cache.prototype.get = function(placeholder, layer, type) {
  placeholder = placeholder + "-" + layer;
  var result = null;
  if (this.m_visible[placeholder] === void 0) {
    this.m_visible[placeholder] = {};
    this.m_invisible[placeholder] = {};
  }
  if (this.m_visible[placeholder][type] === void 0) {
    this.m_visible[placeholder][type] = [];
    this.m_invisible[placeholder][type] = [];
  }
  result = this.m_invisible[placeholder][type].pop() || null;
  if (result !== null) {
    this.m_visible[placeholder][type].push(result);
    result.style.visibility = "inherit";
  }
  return result;
};
Cache.prototype.put = function(placeholder, layer, type, control) {
  placeholder = placeholder + "-" + layer;
  this.m_visible[placeholder][type].push(control);
};

// node_modules/basicprimitives/src/graphics/Placeholder.js
function Placeholder(name2) {
  this.name = name2;
  this.layers = {};
  this.activeLayer = null;
  this.size = null;
  this.rect = null;
  this.div = null;
}

// node_modules/basicprimitives/src/graphics/Layer.js
function Layer(name2) {
  this.name = name2;
  this.canvas = null;
  this.svgcanvas = null;
}

// node_modules/basicprimitives/src/graphics/Graphics.js
function Graphics(element) {
  this.m_element = element;
  this.m_placeholders = {};
  this.m_activePlaceholder = null;
  this.m_cache = new Cache();
  this.debug = false;
  this.layerNames = {};
  loop(this, Layers, function(key, value) {
    this.layerNames[value] = key;
  });
}
Graphics.prototype.clean = function() {
  var key, placeholder, layerKey, layer;
  this.m_cache.clear();
  this.m_cache = null;
  this.m_element = null;
  for (key in this.m_placeholders) {
    if (this.m_placeholders.hasOwnProperty(key)) {
      placeholder = this.m_placeholders[key];
      for (layerKey in placeholder.layers) {
        if (placeholder.layers.hasOwnProperty(layerKey)) {
          layer = placeholder.layers[layerKey];
          layer.canvas.parentNode.removeChild(layer.canvas);
          layer.canvas = null;
        }
      }
      placeholder.layers.length = 0;
      placeholder.activeLayer = null;
      placeholder.size = null;
      placeholder.rect = null;
      placeholder.div = null;
    }
  }
  this.m_placeholders.length = 0;
  this.m_activePlaceholder = null;
};
Graphics.prototype.resize = function(name2, width, height) {
  var placeholder = this.m_placeholders[name2];
  if (placeholder === void 0) {
    placeholder = this._activatePlaceholder(name2);
  }
  this.resizePlaceholder(placeholder, 0, 0, width, height);
};
Graphics.prototype.position = function(name2, left, top, width, height) {
  var placeholder = this.m_placeholders[name2];
  if (placeholder === void 0) {
    placeholder = this._activatePlaceholder(name2);
  }
  this.resizePlaceholder(placeholder, left, top, width, height);
};
Graphics.prototype.show = function(name2) {
  var placeholder = this.m_placeholders[name2];
  if (placeholder != null) {
    jsonml_html_default.applyStyles(placeholder.div, {
      display: "inherit",
      visibility: "inherit"
    });
  }
};
Graphics.prototype.hide = function(name2) {
  var placeholder = this.m_placeholders[name2];
  if (placeholder != null) {
    jsonml_html_default.applyStyles(placeholder.div, {
      "display": "none",
      "visibility": "hidden"
    });
  }
};
Graphics.prototype.resizePlaceholder = function(placeholder, left, top, width, height) {
  var layerKey, layer;
  placeholder.size = new Size(width, height);
  placeholder.rect = new Rect(left, top, width, height);
  jsonml_html_default.applyStyles(placeholder.div, placeholder.rect.getCSS());
  for (layerKey in placeholder.layers) {
    if (placeholder.layers.hasOwnProperty(layerKey)) {
      layer = placeholder.layers[layerKey];
      if (layer.name !== -1) {
        jsonml_html_default.applyStyles(layer.canvas, {
          "position": "absolute",
          "width": "0px",
          "height": "0px"
        });
      }
    }
  }
};
Graphics.prototype.begin = function() {
  this.m_cache.begin();
};
Graphics.prototype.end = function() {
  this.m_cache.end();
};
Graphics.prototype.reset = function(arg0, arg1) {
  var placeholderName = "none", layerName = -1;
  switch (arguments.length) {
    case 1:
      if (typeof arg0 === "string") {
        placeholderName = arg0;
      } else {
        layerName = arg0;
      }
      break;
    case 2:
      placeholderName = arg0;
      layerName = arg1;
      break;
  }
  this.m_cache.reset(placeholderName, layerName);
};
Graphics.prototype.activate = function(arg0, arg1) {
  switch (arguments.length) {
    case 1:
      if (typeof arg0 === "string") {
        this._activatePlaceholder(arg0);
        this._activateLayer(-1);
      } else {
        this._activatePlaceholder("none");
        this._activateLayer(arg0);
      }
      break;
    case 2:
      this._activatePlaceholder(arg0);
      this._activateLayer(arg1);
      break;
  }
  return this.m_activePlaceholder;
};
Graphics.prototype._activatePlaceholder = function(placeholderName) {
  var placeholder = this.m_placeholders[placeholderName], div, divs;
  if (placeholder === void 0) {
    div = null;
    if (placeholderName === "none") {
      div = this.m_element;
    } else {
      divs = this.m_element.getElementsByClassName(placeholderName);
      div = divs.length > 0 ? divs[0] : this.m_element;
    }
    placeholder = new Placeholder(placeholderName);
    placeholder.div = div;
    placeholder.size = getInnerSize(div);
    placeholder.rect = new Rect(0, 0, placeholder.size.width, placeholder.size.height);
    this.m_placeholders[placeholderName] = placeholder;
  }
  this.m_activePlaceholder = placeholder;
  return this.m_activePlaceholder;
};
Graphics.prototype._activateLayer = function(layerName) {
  var layer = this.m_activePlaceholder.layers[layerName], placeholder, canvas, position, maximumLayer, layerKey;
  if (layer === void 0) {
    placeholder = this.m_activePlaceholder;
    if (layerName === -1) {
      layer = new Layer(layerName);
      layer.canvas = placeholder.div;
    } else {
      canvas = jsonml_html_default.toHTML([
        "div",
        {
          "style": {
            "position": "absolute",
            "width": "0px",
            "height": "0px"
          },
          "class": ["Layer" + layerName, "Layer" + this.layerNames[layerName]]
        }
      ]);
      maximumLayer = null;
      for (layerKey in placeholder.layers) {
        if (placeholder.layers.hasOwnProperty(layerKey)) {
          layer = placeholder.layers[layerKey];
          if (layer.name < layerName) {
            maximumLayer = maximumLayer !== null ? Math.max(maximumLayer, layer.name) : layer.name;
          }
        }
      }
      layer = new Layer(layerName);
      layer.canvas = canvas;
      if (maximumLayer === null) {
        this.prepend(placeholder.div, layer.canvas);
      } else {
        this.insertAfter(placeholder.layers[maximumLayer].canvas, layer.canvas);
      }
    }
    placeholder.layers[layerName] = layer;
  }
  this.m_activePlaceholder.activeLayer = layer;
};
Graphics.prototype.prepend = function(parent, newElement) {
  if (parent.firstChild == null) {
    parent.appendChild(newElement);
  } else {
    parent.insertBefore(newElement, parent.firstChild);
  }
};
Graphics.prototype.insertAfter = function(insertAfterElement, newElement) {
  var parent = insertAfterElement.parentNode;
  if (parent.lastChild == insertAfterElement) {
    parent.appendChild(newElement);
  } else {
    parent.insertBefore(newElement, insertAfterElement.nextSibling);
  }
};
Graphics.prototype.text = function(x, y, width, height, label, orientation, horizontalAlignment, verticalAlignment, attr) {
  var placeholder = this.m_activePlaceholder, style = {
    "position": "absolute",
    "padding": 0,
    "margin": 0,
    "textAlign": getTextAlign(horizontalAlignment),
    "fontSize": attr.fontSize,
    "fontFamily": attr.fontFamily,
    "fontWeight": attr.fontWeight,
    "fontStyle": attr.fontStyle,
    "color": attr.fontColor,
    "lineHeight": 1
  }, rotation = "", element, tdstyle;
  switch (orientation) {
    case TextOrientationType.Horizontal:
    case TextOrientationType.Auto:
      style.left = x + "px";
      style.top = y + "px";
      style.width = width + "px";
      style.height = height + "px";
      break;
    case TextOrientationType.RotateLeft:
      style.left = x + Math.round(width / 2 - height / 2) + "px";
      style.top = y + Math.round(height / 2 - width / 2) + "px";
      style.width = height + "px";
      style.height = width + "px";
      rotation = "rotate(-90deg)";
      break;
    case TextOrientationType.RotateRight:
      style.left = x + Math.round(width / 2 - height / 2) + "px";
      style.top = y + Math.round(height / 2 - width / 2) + "px";
      style.width = height + "px";
      style.height = width + "px";
      rotation = "rotate(90deg)";
      break;
  }
  style["-webkit-transform-origin"] = "center center";
  style["-moz-transform-origin"] = "center center";
  style["-o-transform-origin"] = "center center";
  style["-ms-transform-origin"] = "center center";
  style["-webkit-transform"] = rotation;
  style["-moz-transform"] = rotation;
  style["-o-transform"] = rotation;
  style["-ms-transform"] = rotation;
  style.transform = rotation;
  style.maxWidth = style.width;
  style.maxHeight = style.height;
  label = label.replace(new RegExp("\n", "g"), "<br/>");
  switch (verticalAlignment) {
    case VerticalAlignmentType.Top:
      if (this.debug) {
        style.border = "solid 1px black";
      }
      element = this.m_cache.get(placeholder.name, placeholder.activeLayer.name, "text");
      if (element === null) {
        element = jsonml_html_default.toHTML([
          "div",
          {
            "style": style,
            $: function(element2) {
              element2.innerHTML = label;
            }
          }
        ]);
        placeholder.activeLayer.canvas.appendChild(element);
        this.m_cache.put(placeholder.name, placeholder.activeLayer.name, "text", element);
      } else {
        jsonml_html_default.applyStyles(element, style);
        element.innerHTML = label;
      }
      break;
    default:
      style.borderCollapse = "collapse";
      tdstyle = {
        "verticalAlign": getVerticalAlignment(verticalAlignment),
        "padding": 0
      };
      if (this.debug) {
        tdstyle.border = "solid 1px black";
      }
      element = this.m_cache.get(placeholder.name, placeholder.activeLayer.name, "textintable");
      if (element === null) {
        element = jsonml_html_default.toHTML([
          "table",
          {
            "style": style
          },
          [
            "tbody",
            [
              "tr",
              [
                "td",
                {
                  "style": tdstyle,
                  $: function(element2) {
                    element2.innerHTML = label;
                  }
                }
              ]
            ]
          ]
        ]);
        placeholder.activeLayer.canvas.appendChild(element);
        this.m_cache.put(placeholder.name, placeholder.activeLayer.name, "textintable", element);
      } else {
        jsonml_html_default.applyStyles(element, style);
        var td = element.getElementsByTagName("td")[0];
        jsonml_html_default.applyStyles(td, tdstyle);
        td.innerHTML = label;
      }
      break;
  }
};
Graphics.prototype.polylinesBuffer = function(buffer) {
  buffer.loop(this, function(polyline) {
    if (polyline.length() > 0) {
      this.polyline(polyline);
    }
  });
};
Graphics.prototype.template = function(x, y, width, height, contentx, contenty, contentWidth, contentHeight, template, hashCode, onRenderTemplate, uiHash, attr) {
  var placeholder = this.m_activePlaceholder, element, templateKey = "template" + (hashCode !== null ? hashCode : getHashCode(template)), gap = 0, style;
  element = this.m_cache.get(placeholder.name, placeholder.activeLayer.name, templateKey);
  if (attr !== null) {
    if (attr.borderWidth !== void 0) {
      attr.borderWidth = attr.borderWidth.toString();
      gap = this.getPxSize(attr.borderWidth);
    }
  }
  style = {
    "width": contentWidth - gap + "px",
    "height": contentHeight - gap + "px",
    "top": y + contenty + "px",
    "left": x + contentx + "px"
  };
  mergeObjects(style, attr);
  if (uiHash == null) {
    uiHash = new RenderEventArgs();
  }
  uiHash.x = x + contentx;
  uiHash.y = y + contenty;
  uiHash.width = contentWidth - gap;
  uiHash.height = contentHeight - gap;
  if (element == null) {
    element = this.getElementByTemplate(template);
    style = mergeObjects(style, {
      "position": "absolute",
      "padding": "0px",
      "margin": "0px"
    }, attr);
    jsonml_html_default.applyStyles(element, style);
    uiHash.element = element;
    uiHash.renderingMode = RenderingMode.Create;
    if (onRenderTemplate !== null) {
      onRenderTemplate(null, uiHash);
    }
    placeholder.activeLayer.canvas.appendChild(element);
    this.m_cache.put(placeholder.name, placeholder.activeLayer.name, templateKey, element);
  } else {
    uiHash.element = element;
    uiHash.renderingMode = RenderingMode.Update;
    jsonml_html_default.applyStyles(element, style);
    if (onRenderTemplate !== null) {
      onRenderTemplate(null, uiHash);
    }
  }
  return element;
};
Graphics.prototype.getElementByTemplate = function(template) {
  var result = null;
  if (Array.isArray(template)) {
    result = jsonml_html_default.toHTML(template);
  } else {
    var parent = document.createElement("div");
    parent.innerHTML = template;
    result = parent.firstChild;
  }
  return result;
};
Graphics.prototype.getPxSize = function(value, base) {
  var result = value;
  if (typeof value === "string") {
    if (value.indexOf("pt") > 0) {
      result = parseInt(value, 10) * 96 / 72;
    } else if (value.indexOf("%") > 0) {
      result = parseFloat(value) / 100 * base;
    } else {
      result = parseInt(value, 10);
    }
  }
  return result;
};

// node_modules/basicprimitives/src/graphics/Element.js
function Element(arg0, arg1) {
  this.ns = null;
  this.name = null;
  this.attr = {};
  this.style = {};
  this.children = [];
  switch (arguments.length) {
    case 1:
      this.name = arg0;
      break;
    case 2:
      this.ns = arg0;
      this.name = arg1;
      break;
    default:
      break;
  }
}
Element.prototype.setAttribute = function(key, value) {
  this.attr[key] = value;
};
Element.prototype.appendChild = function(child) {
  this.children[this.children.length] = child;
};
Element.prototype.create = function(ie8mode) {
  var result = null, name2, child, index;
  if (this.ns !== null) {
    result = document.createElementNS(this.ns, this.name);
  } else {
    result = document.createElement(this.name);
  }
  for (name2 in this.attr) {
    if (this.attr.hasOwnProperty(name2)) {
      if (ie8mode !== void 0) {
        result[name2] = this.attr[name2];
      } else {
        result.setAttribute(name2, this.attr[name2]);
      }
    }
  }
  for (name2 in this.style) {
    if (this.style.hasOwnProperty(name2)) {
      result.style[name2] = this.style[name2];
    }
  }
  for (index = 0; index < this.children.length; index += 1) {
    child = this.children[index];
    if (typeof child === "string") {
      result.appendChild(document.createTextNode(child));
    } else {
      result.appendChild(child.create(ie8mode));
    }
  }
  return result;
};
Element.prototype.update = function(target, ie8mode) {
  var name2, length, index, child, value;
  for (name2 in this.style) {
    if (this.style.hasOwnProperty(name2)) {
      value = this.style[name2];
      if (target.style[name2] !== value) {
        target.style[name2] = value;
      }
    }
  }
  for (name2 in this.attr) {
    if (this.attr.hasOwnProperty(name2)) {
      value = this.attr[name2];
      if (ie8mode !== void 0) {
        if (target[name2] !== value) {
          target[name2] = value;
        }
      } else {
        if (target.getAttribute(name2) !== value) {
          target.setAttribute(name2, value);
        }
      }
    }
  }
  length = this.children.length;
  for (index = 0; index < length; index += 1) {
    child = this.children[index];
    if (typeof child === "string") {
      if (target.innerHtml !== child) {
        target.innerHtml = child;
      }
    } else {
      this.children[index].update(target.children[index], ie8mode);
    }
  }
};

// node_modules/basicprimitives/src/graphics/SvgGraphics.js
function SvgGraphics(element) {
  this.parent = Graphics.prototype;
  this.parent.constructor.apply(this, arguments);
  this._svgxmlns = "http://www.w3.org/2000/svg";
}
SvgGraphics.prototype = new Graphics();
SvgGraphics.prototype.clean = function() {
  var key, placeholder, layerKey, layer;
  for (key in this.m_placeholders) {
    if (this.m_placeholders.hasOwnProperty(key)) {
      placeholder = this.m_placeholders[key];
      for (layerKey in placeholder.layers) {
        if (placeholder.layers.hasOwnProperty(layerKey)) {
          layer = placeholder.layers[layerKey];
          if (layer.svgcanvas !== null) {
            layer.svgcanvas.parentNode.removeChild(layer.svgcanvas);
            layer.svgcanvas = null;
          }
        }
      }
    }
  }
  this.parent.clean.apply(this, arguments);
};
SvgGraphics.prototype.resizePlaceholder = function(placeholder, left, top, width, height) {
  var layerKey, layer;
  this.parent.resizePlaceholder.apply(this, arguments);
  for (layerKey in placeholder.layers) {
    if (placeholder.layers.hasOwnProperty(layerKey)) {
      layer = placeholder.layers[layerKey];
      if (layer.svgcanvas !== null) {
        jsonml_html_default.applyStyles(layer.svgcanvas, {
          "position": "absolute",
          "width": width + "px",
          "height": height + "px"
        });
        layer.svgcanvas.setAttribute("viewBox", "0 0 " + width + " " + height);
      }
    }
  }
};
SvgGraphics.prototype._getCanvas = function() {
  var placeholder = this.m_activePlaceholder, layer = placeholder.activeLayer, panelSize = placeholder.rect;
  if (layer.svgcanvas === null) {
    layer.svgcanvas = document.createElementNS(this._svgxmlns, "svg");
    layer.svgcanvas.setAttribute("viewBox", panelSize.x + " " + panelSize.y + " " + panelSize.width + " " + panelSize.height);
    jsonml_html_default.applyStyles(layer.svgcanvas, {
      "width": panelSize.width + "px",
      "height": panelSize.height + "px"
    });
    this.prepend(placeholder.activeLayer.canvas, layer.svgcanvas);
  }
  return layer.svgcanvas;
};
SvgGraphics.prototype.polyline = function(polylineData) {
  var placeholder = this.m_activePlaceholder, polyline, data, attr = polylineData.paletteItem.toAttr(), element, svgcanvas, step, radius, cornerRadius;
  polyline = new Element(this._svgxmlns, "path");
  if (attr.fillColor !== void 0) {
    polyline.setAttribute("fill", attr.fillColor);
    polyline.setAttribute("fill-opacity", attr.opacity);
  } else {
    polyline.setAttribute("fill-opacity", 0);
  }
  if (attr.lineWidth !== void 0 && attr.borderColor !== void 0) {
    polyline.setAttribute("stroke", attr.borderColor);
    polyline.setAttribute("stroke-width", attr.lineWidth);
    if (attr.opacity !== void 0) {
      polyline.setAttribute("stroke-opacity", attr.opacity);
    } else {
      polyline.setAttribute("stroke-opacity", 1);
    }
  } else {
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("stroke-width", 0);
  }
  if (attr.lineType != null) {
    step = Math.round(attr.lineWidth) || 1;
    switch (attr.lineType) {
      case LineType.Solid:
        polyline.setAttribute("stroke-dasharray", "");
        break;
      case LineType.Dotted:
        polyline.setAttribute("stroke-dasharray", step + "," + step);
        break;
      case LineType.Dashed:
        polyline.setAttribute("stroke-dasharray", step * 5 + "," + step * 3);
        break;
    }
  }
  data = "";
  polylineData.loop(this, function(segment) {
    switch (segment.segmentType) {
      case SegmentType.Move:
        data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
        break;
      case SegmentType.Line:
        data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
        break;
      case SegmentType.QuadraticArc:
        data += "Q" + (Math.round(segment.cpX) + 0.5) + " " + (Math.round(segment.cpY) + 0.5) + " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
        break;
      case SegmentType.Dot:
        if (segment.width == segment.height && segment.width / 2 <= segment.cornerRadius) {
          radius = segment.width / 2;
          data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
          data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
          data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
        } else if (segment.cornerRadius === 0) {
          data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
          data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
          data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
        } else {
          cornerRadius = Math.min(segment.cornerRadius, Math.min(segment.width / 2, segment.height / 2));
          data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
          data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          data += "L" + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
          data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
          data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
          data += "L" + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
          data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
          data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
        }
        break;
      case SegmentType.CubicArc:
        data += "C" + (Math.round(segment.cpX1) + 0.5) + " " + (Math.round(segment.cpY1) + 0.5) + " " + (Math.round(segment.cpX2) + 0.5) + " " + (Math.round(segment.cpY2) + 0.5) + " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
        break;
    }
  });
  polyline.setAttribute("d", data);
  element = this.m_cache.get(placeholder.name, placeholder.activeLayer.name, "path");
  if (element === null) {
    element = polyline.create();
    svgcanvas = this._getCanvas();
    svgcanvas.appendChild(element);
    this.m_cache.put(placeholder.name, placeholder.activeLayer.name, "path", element);
  } else {
    polyline.update(element);
  }
};

// node_modules/basicprimitives/src/tasks/options/FamItemsOptionTask.js
function FamItemsOptionTask(optionsTask, defaultItemConfig) {
  var _data = {}, _hash = {}, _sourceHash = {};
  var _dataTemplate = new ObjectReader({
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        parents: new ArrayReader(
          new ValueReader(["string", "number"], true),
          true
        ),
        isActive: new ValueReader(["boolean"], false, defaultItemConfig.isActive)
      }),
      true,
      "id",
      true
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash,
      sourceHash: _sourceHash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getItems() {
    return _data.items;
  }
  function getConfig(itemId) {
    return _sourceHash["options-items"][itemId];
  }
  return {
    process,
    getItems,
    getConfig
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/FamNormalVisibilityItemsByMinimumVisibleLevelsTask.js
function FamNormalVisibilityItemsByMinimumVisibleLevelsTask(minimumVisibleLevelsOptionTask, orderFamilyNodesTask) {
  var _data = {
    items: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, treeLevels = orderFamilyNodesTask.getTreeLevels(), { pageFitMode, minimalVisibility, minimumVisibleLevels } = minimumVisibleLevelsOptionTask.getOptions();
    _data.items = _dataTemplate.read(_data.items, getSelectedItems(treeLevels, pageFitMode, minimalVisibility, minimumVisibleLevels), "items", context);
    return context.isChanged;
  }
  function getSelectedItems(treeLevels, pageFitMode, minimalVisibility, minimumVisibleLevels) {
    var result = [];
    if (minimumVisibleLevels > 0) {
      if (PageFitMode.PageWidth == pageFitMode || PageFitMode.PageHeight || PageFitMode.FitToPage) {
        if (minimalVisibility != Visibility.Normal) {
          var index = 0, currentLevel = null;
          treeLevels.loopLevels(this, function(levelIndex, level) {
            treeLevels.loopLevelItems(this, levelIndex, function(nodeId, node, position) {
              if (node.isVisible) {
                if (currentLevel !== levelIndex) {
                  currentLevel = levelIndex;
                  index += 1;
                }
                result.push(nodeId);
              }
            });
            if (index >= minimumVisibleLevels) {
              return true;
            }
          });
        }
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/layout/FamLogicalLevelsPlacementTask.js
function FamLogicalLevelsPlacementTask(orderFamilyNodesTask, alignDiagramTask) {
  var _data = {
    positions: []
  };
  function process() {
    _data.positions = null;
    return true;
  }
  function createPositions() {
    var intervals = [], treeLevels = orderFamilyNodesTask.getTreeLevels(), itemsPositions = alignDiagramTask.getItemsPositions(), index = 0;
    treeLevels.loopLevels(this, function(levelIndex2, level) {
      treeLevels.loopLevelItems(this, levelIndex2, function(nodeId, node, position) {
        if (node.isVisible && node.isActive) {
          var itemPosition = itemsPositions[nodeId];
          if (itemPosition) {
            var interval2 = new Interval(itemPosition.topConnectorShift || itemPosition.actualPosition.y, itemPosition.bottomConnectorShift - 1, index++);
            intervals.push(interval2);
          }
          return true;
        }
      });
    });
    var mergedIntervals = [];
    getMergedIntervals(this, intervals, function(interval2) {
      mergedIntervals.push(interval2);
    });
    intervals = mergedIntervals;
    mergedIntervals = [];
    var currentInterval = null;
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      if (!currentInterval) {
        currentInterval = interval;
        mergedIntervals.push(interval);
      } else {
        if (currentInterval.context === interval.context) {
          currentInterval.to = interval.to;
        } else {
          currentInterval = interval;
          mergedIntervals.push(interval);
        }
      }
    }
    intervals = mergedIntervals;
    if (intervals.length > 0) {
      intervals[0].from = 0;
    }
    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {
      var prev = intervals[index];
      var next = intervals[index + 1];
      prev.to = next.from;
    }
    var minLevelIndex = null;
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);
    }
    var result = {};
    for (var index = 0, len = intervals.length; index < len; index += 1) {
      var interval = intervals[index];
      var levelIndex = interval.context - minLevelIndex;
      var logicalLevelPosition = result[levelIndex];
      if (!logicalLevelPosition) {
        result[levelIndex] = [interval];
      } else {
        logicalLevelPosition.push(interval);
      }
    }
    return result;
  }
  function getPositions() {
    if (!_data.positions) {
      _data.positions = createPositions();
    }
    return _data.positions;
  }
  return {
    getPositions,
    process
  };
}

// node_modules/basicprimitives/src/tasks/options/FamVisualTreeOptionTask.js
function FamVisualTreeOptionTask(optionsTask) {
  var _data = {
    leavesPlacementType: ChildrenPlacementType.Horizontal,
    childrenPlacementType: ChildrenPlacementType.Horizontal,
    maximumColumnsInMatrix: 6,
    horizontalAlignment: HorizontalAlignmentType.Center
  };
  function process() {
    return false;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/options/HideGrandParentsConnectorsOptionTask.js
function HideGrandParentsConnectorsOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    hideGrandParentsConnectors: new ValueReader(["boolean"], false, defaultConfig.hideGrandParentsConnectors)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/options/NormalizeOptionTask.js
function NormalizeOptionTask(optionsTask, defaultConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    groupByType: new EnumerationReader(GroupByType, false, defaultConfig.groupByType),
    alignBylevels: new ValueReader(["boolean"], false, defaultConfig.alignBylevels)
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/options/ExtractNestedLayoutsOptionTask.js
function ExtractNestedLayoutsOptionTask(optionsTask, defaultConfig, defaultItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    enableMatrixLayout: new ValueReader(["boolean"], false, defaultConfig.enableMatrixLayout),
    minimumMatrixSize: new ValueReader(["number"], false, defaultConfig.minimumMatrixSize),
    maximumColumnsInMatrix: new ValueReader(["number"], false, defaultConfig.maximumColumnsInMatrix),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        matrixId: new ValueReader(["string", "number"], false, defaultItemConfig.matrixId),
        addToMatrix: new ValueReader(["boolean"], false, defaultItemConfig.addToMatrix)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  function getConfig(itemId) {
    return _hash["options-items"][itemId];
  }
  return {
    process,
    getOptions,
    getConfig
  };
}

// node_modules/basicprimitives/src/tasks/options/OrderFamilyNodesOptionTask.js
function OrderFamilyNodesOptionTask(optionsTask, defaultConfig, defaultItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    enableMatrixLayout: new ValueReader(["boolean"], false, defaultConfig.enableMatrixLayout),
    minimumMatrixSize: new ValueReader(["number"], false, defaultConfig.minimumMatrixSize),
    maximumColumnsInMatrix: new ValueReader(["number"], false, defaultConfig.maximumColumnsInMatrix),
    items: new ArrayReader(
      new ObjectReader({
        id: new ValueReader(["string", "number"], true),
        position: new ValueReader(["number"], true),
        relativeItem: new ValueReader(["string", "number"], true),
        placementType: new EnumerationReader(AdviserPlacementType, false, defaultItemConfig.placementType),
        primaryParent: new ValueReader(["string", "number"], true),
        matrixId: new ValueReader(["string", "number"], false, defaultItemConfig.matrixId),
        addToMatrix: new ValueReader(["boolean"], false, defaultItemConfig.addToMatrix)
      }),
      true,
      "id"
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  function getConfig(itemId) {
    return _hash["options-items"][itemId];
  }
  return {
    process,
    getOptions,
    getConfig
  };
}

// node_modules/basicprimitives/src/tasks/options/LinePaletteOptionTask.js
function LinePaletteOptionTask(optionsTask, defaultPaletteItemConfig) {
  var _data = {}, _hash = {};
  var _dataTemplate = new ObjectReader({
    linesPalette: new ArrayReader(
      new ObjectReader({
        lineColor: new ValueReader(["string"], false, defaultPaletteItemConfig.lineColor),
        lineWidth: new ValueReader(["number"], false, defaultPaletteItemConfig.lineWidth),
        lineType: new EnumerationReader(LineType, false, defaultPaletteItemConfig.lineType)
      }),
      false
    )
  });
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getOptions() {
    return _data;
  }
  return {
    process,
    getOptions
  };
}

// node_modules/basicprimitives/src/tasks/options/selection/NeighboursSelectionModeOptionTask.js
function NeighboursSelectionModeOptionTask(optionsTask, defaultConfig) {
  var _data = {};
  var _dataTemplate = new ObjectReader({
    neighboursSelectionMode: new EnumerationReader(NeighboursSelectionMode, false, defaultConfig.neighboursSelectionMode)
  });
  function process() {
    var context = {
      isChanged: false
    };
    _data = _dataTemplate.read(_data, optionsTask.getOptions(), "options", context);
    return context.isChanged;
  }
  function getNeighboursSelectionMode() {
    return _data.neighboursSelectionMode;
  }
  return {
    process,
    getNeighboursSelectionMode
  };
}

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/UserDefinedNodesOrder.js
function UserDefinedNodesOrder() {
}
UserDefinedNodesOrder.prototype.getUserDefinedPositions = function(items) {
  var userItem, index, len, relationTree = Tree(), referencedItems = {};
  for (index = 0, len = items.length; index < len; index += 1) {
    userItem = items[index];
    if (userItem.relativeItem != null) {
      referencedItems[userItem.relativeItem] = true;
    }
    if (userItem.id != null) {
      referencedItems[userItem.id] = true;
    }
  }
  for (index = 0, len = items.length; index < len; index += 1) {
    userItem = items[index];
    if (referencedItems.hasOwnProperty(userItem.id)) {
      var relativeItem = userItem.relativeItem || null;
      relationTree.add(relativeItem, userItem.id, userItem);
    }
  }
  function Set(position2, items2) {
    this.position = position2;
    this.items = items2;
  }
  var itemsOrder = {};
  var lefts = {};
  var rights = {};
  relationTree.loopPostOrder(this, function(nodeid, node, parentid, parent) {
    var items2 = [], leftItems = lefts[nodeid], rightItems = rights[nodeid], index2;
    if (leftItems != null) {
      leftItems.sort(function(a, b) {
        return b.position - a.position;
      });
      for (index2 = 0; index2 < leftItems.length; index2 += 1) {
        items2 = items2.concat(leftItems[index2].items);
      }
    }
    items2.push(nodeid);
    if (rightItems != null) {
      rightItems.sort(function(a, b) {
        return a.position - b.position;
      });
      for (index2 = 0; index2 < rightItems.length; index2 += 1) {
        items2 = items2.concat(rightItems[index2].items);
      }
    }
    if (parentid != null) {
      if (node.placementType == AdviserPlacementType.Left) {
        if (!lefts.hasOwnProperty(parentid)) {
          lefts[parentid] = [];
        }
        lefts[parentid].push(new Set(node.position, items2));
      } else {
        if (!rights.hasOwnProperty(parentid)) {
          rights[parentid] = [];
        }
        rights[parentid].push(new Set(node.position, items2));
      }
    } else {
      itemsOrder[nodeid] = items2;
    }
  });
  var position = {}, group = {};
  for (var rootItemId in itemsOrder) {
    if (itemsOrder.hasOwnProperty(rootItemId)) {
      items = itemsOrder[rootItemId];
      for (index = 0; index < items.length; index += 1) {
        var itemid = items[index];
        position[itemid] = index;
        group[itemid] = rootItemId;
      }
    }
  }
  return {
    position,
    group
  };
};

// node_modules/basicprimitives/src/tasks/transformations/UserDefinedNodesOrderTask.js
function UserDefinedNodesOrderTask(orderFamilyNodesOptionTask) {
  var _data = {
    position: null,
    /* hash[itemid] = position*/
    group: null
    /* hash[itemid] = root itemid */
  }, _userDefinedNodesOrder = new UserDefinedNodesOrder();
  function process() {
    var options = orderFamilyNodesOptionTask.getOptions();
    var result = _userDefinedNodesOrder.getUserDefinedPositions(options.items);
    _data.position = result.position;
    _data.group = result.group;
    return true;
  }
  function getPositions() {
    return _data.position;
  }
  function getGroups() {
    return _data.group;
  }
  return {
    process,
    getPositions,
    getGroups
  };
}

// node_modules/basicprimitives/src/models/FamilyItem.js
function FamilyItem(arg0) {
  var property;
  this.id = null;
  this.familyId = null;
  this.itemConfig = null;
  this.isVisible = true;
  this.isActive = true;
  this.isLevelNeutral = false;
  this.level = null;
  this.levelGravity = GroupByType.None;
  this.hideParentConnection = false;
  this.hideChildrenConnection = false;
  switch (arguments.length) {
    case 1:
      for (property in arg0) {
        if (arg0.hasOwnProperty(property)) {
          this[property] = arg0[property];
        }
      }
      break;
  }
}

// node_modules/basicprimitives/src/tasks/transformations/LogicalFamilyTask.js
function LogicalFamilyTask(itemsOptionTask) {
  var _data = {
    logicalFamily: null,
    maximumId: null
  };
  function process(debug) {
    var index, len, itemConfig, famItem, items = itemsOptionTask.getItems(), logicalFamily = Family(), maximumId = 0, parsedId;
    if (items.length > 0) {
      for (index = 0, len = items.length; index < len; index += 1) {
        itemConfig = items[index];
        if (itemConfig != null) {
          famItem = new FamilyItem({
            id: itemConfig.id,
            itemConfig,
            isActive: itemConfig.isActive
          });
          logicalFamily.add(itemConfig.parents, famItem.id, famItem);
          parsedId = parseInt(itemConfig.id, 10);
          maximumId = Math.max(isNaN(parsedId) ? 0 : parsedId, maximumId);
        }
      }
    }
    _data.logicalFamily = logicalFamily;
    _data.maximumId = maximumId;
    if (debug && !logicalFamily.validate()) {
      throw "References are broken in family structure!";
    }
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/RemoveLoopsTask.js
function RemoveLoopsTask(logicalFamilyTask) {
  var _data = {
    logicalFamily: null,
    maximumId: null,
    loops: []
    // populate collection of pairs between fake parents and fake children
  };
  function process(debug) {
    var logicalFamily = logicalFamilyTask.getLogicalFamily(), maximumId = logicalFamilyTask.getMaximumId();
    var result = removeLoops(logicalFamily, maximumId, debug);
    _data.logicalFamily = result.logicalFamily;
    _data.maximumId = result.maximumId;
    _data.loops = result.loops;
    if (debug && !logicalFamily.validate()) {
      throw "References are broken in family structure!";
    }
    return true;
  }
  function removeLoops(logicalFamily, maximumId, debug) {
    var fakeChild, fakeParent, index, len, index2, len2, edgesToReverse = getFamilyLoops(logicalFamily, debug), fakePairs = [];
    var loops = [];
    var loopsHash = {};
    for (index = 0, len = edgesToReverse.length; index < len; index += 1) {
      var edge = edgesToReverse[index];
      if (!loopsHash.hasOwnProperty(edge.to)) {
        loopsHash[edge.to] = { itemid: edge.to, parents: [edge.from] };
        loops.push(loopsHash[edge.to]);
      } else {
        loopsHash[edge.to].parents.push(edge.from);
      }
    }
    var fakeChildren = {};
    if (loops.length > 0) {
      logicalFamily = logicalFamily.clone();
      for (index = 0, len = loops.length; index < len; index += 1) {
        var loop2 = loops[index];
        var parents = loop2.parents;
        var itemParents = [];
        logicalFamily.loopParents(this, loop2.itemid, function(parentid2, parent) {
          itemParents.push(parentid2);
          return logicalFamily.SKIP;
        });
        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {
          logicalFamily.removeChildRelation(itemParents[index2], loop2.itemid);
        }
        maximumId += 1;
        var isConnectionsVisible = itemParents.length <= parents.length;
        fakeParent = new FamilyItem({
          id: maximumId,
          isVisible: false,
          isActive: false,
          isLevelNeutral: false,
          hideParentConnection: isConnectionsVisible,
          hideChildrenConnection: isConnectionsVisible,
          levelGravity: GroupByType.Children,
          itemConfig: { title: "fake parent #" + maximumId, description: "This is a fake parent item, it was created by loops removal task." }
        });
        logicalFamily.add([], fakeParent.id, fakeParent);
        logicalFamily.adopt([fakeParent.id], loop2.itemid);
        fakePairs.push({ from: fakeParent.id, to: loop2.itemid, isOppositeFlow: false });
        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {
          var parentid = parents[index2];
          fakeChild = fakeChildren[parentid];
          if (fakeChild == null) {
            maximumId += 1;
            fakeChild = new FamilyItem({
              id: maximumId,
              isVisible: false,
              isActive: false,
              isLevelNeutral: false,
              hideParentConnection: true,
              hideChildrenConnection: true,
              levelGravity: GroupByType.Parents,
              itemConfig: { title: "fake child #" + maximumId, description: "This is a fake child item, it was created by loops removal task." }
            });
            fakeChildren[parentid] = fakeChild;
            logicalFamily.add([parentid], fakeChild.id, fakeChild);
            fakePairs.push({ from: parentid, to: fakeChild.id, isOppositeFlow: false });
          }
          logicalFamily.adopt([fakeParent.id], fakeChild.id);
          fakePairs.push({ from: fakeParent.id, to: fakeChild.id, isOppositeFlow: true });
        }
        var parentsHash = {};
        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {
          parentsHash[parents[index2]] = true;
        }
        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {
          if (!parentsHash.hasOwnProperty(itemParents[index2])) {
            logicalFamily.adopt([itemParents[index2]], fakeParent.id);
          }
        }
      }
    }
    return {
      maximumId,
      logicalFamily,
      loops: fakePairs
    };
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  function getLoops() {
    return _data.loops;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId,
    getLoops
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/LabelAnnotationOptionTask.js
function LabelAnnotationOptionTask(splitAnnotationsOptionTask, logicalFamilyTask, defaultLabelAnnotationConfig) {
  var _data = {
    annotations: [],
    configs: {},
    maximumId: null
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader(
      {
        zOrderType: new EnumerationReader(ZOrderType, false, defaultLabelAnnotationConfig.zOrderType),
        fromItem: new ValueReader(["string", "number"], true),
        toItems: new ArrayReader(
          new ValueReader(["string", "number"], true),
          true
        ),
        title: new ValueReader(["string"], true),
        itemTitleColor: new ValueReader(["string"], false, defaultLabelAnnotationConfig.itemTitleColor),
        templateName: new ValueReader(["string"], true)
      },
      false
    ),
    false,
    null,
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash,
      sourceHash: {}
    }, maximumId = logicalFamilyTask.getMaximumId(), index, len, annotation;
    _data.annotations = _dataTemplate.read(_data.annotations, splitAnnotationsOptionTask.getAnnotations(AnnotationType.Label), "annotations", context);
    _data.configs = {};
    var sourceItems = context.sourceHash.annotations;
    for (index = 0, len = _data.annotations.length; index < len; index += 1) {
      annotation = _data.annotations[index];
      maximumId += 1;
      annotation.id = maximumId;
      _data.configs[annotation.id] = sourceItems[index];
    }
    _data.maximumId = maximumId;
    return context.isChanged;
  }
  function getAnnotations() {
    return _data.annotations;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  function getConfig(itemId) {
    return _data.configs[itemId];
  }
  return {
    process,
    getAnnotations,
    getMaximumId,
    getConfig
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/LabelAnnotationTemplateOptionTask.js
function LabelAnnotationTemplateOptionTask(labelAnnotationOptionTask, defaultLabelAnnotationConfig) {
  var _data = {
    annotations: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader({
      id: new ValueReader(["number"], true),
      title: new ValueReader(["string"], true),
      itemTitleColor: new ValueReader(["string"], false, defaultLabelAnnotationConfig.itemTitleColor),
      templateName: new ValueReader(["string"], true)
    }),
    true,
    "id"
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data.annotations = _dataTemplate.read(_data.annotations, labelAnnotationOptionTask.getAnnotations(), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _data.annotations;
  }
  return {
    process,
    getAnnotations
  };
}

// node_modules/basicprimitives/src/tasks/options/annotations/LabelAnnotationPlacementOptionTask.js
function LabelAnnotationPlacementOptionTask(labelAnnotationOptionTask, defaultLabelAnnotationConfig) {
  var _data = {
    annotations: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ObjectReader({
      id: new ValueReader(["number"], true),
      fromItem: new ValueReader(["string", "number"], true),
      toItems: new ArrayReader(
        new ValueReader(["string", "number"], true),
        true
      )
    }),
    true,
    "id"
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    };
    _data.annotations = _dataTemplate.read(_data.annotations, labelAnnotationOptionTask.getAnnotations(), "annotations", context);
    return context.isChanged;
  }
  function getAnnotations() {
    return _data.annotations;
  }
  function getMaximumId() {
    return labelAnnotationOptionTask.getMaximumId();
  }
  return {
    process,
    getAnnotations,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/models/EdgeItem.js
function EdgeItem(key0, val0, key1, val1) {
  this.values = [val0, val1];
  this[key0] = 0;
  this[key1] = 1;
}
EdgeItem.prototype.getNear = function(key) {
  return this.values[this[key]];
};
EdgeItem.prototype.getFar = function(key) {
  return this.values[Math.abs(this[key] - 1)];
};
EdgeItem.prototype.setNear = function(key, value) {
  this.values[this[key]] = value;
};
EdgeItem.prototype.setFar = function(key, value) {
  this.values[Math.abs(this[key] - 1)] = value;
};
EdgeItem.prototype.toString = function() {
  return this.parent + "," + this.child;
};

// node_modules/basicprimitives/src/tasks/transformations/AddLabelAnnotationsTask.js
function AddLabelAnnotationsTask(labelAnnotationPlacementOptionTask, removeLoopsTask) {
  var _data = {
    logicalFamily: null,
    maximumId: null
  };
  function process(debug) {
    var logicalFamily = removeLoopsTask.getLogicalFamily(), annotations = labelAnnotationPlacementOptionTask.getAnnotations();
    logicalFamily = logicalFamily.clone();
    addLabelAnnotations(logicalFamily, annotations);
    _data.logicalFamily = logicalFamily;
    _data.maximumId = labelAnnotationPlacementOptionTask.getMaximumId();
    if (debug && !logicalFamily.validate()) {
      throw "References are broken in family structure!";
    }
    return true;
  }
  function addLabelAnnotations(logicalFamily, annotations) {
    var edges = Graph(), configsHash = {}, configs, config, fromItem, index, len;
    if (annotations.length > 0) {
      for (index = 0, len = annotations.length; index < len; index += 1) {
        config = annotations[index];
        if (!configsHash.hasOwnProperty(config.fromItem)) {
          configsHash[config.fromItem] = [config];
          logicalFamily.loopChildren(this, config.fromItem, function(childid, child, level) {
            edges.addEdge(config.fromItem, childid, new EdgeItem(config.fromItem, config.fromItem, childid, childid));
            return logicalFamily.SKIP;
          });
          logicalFamily.loopParents(this, config.fromItem, function(parentid, parent, level) {
            edges.addEdge(parentid, config.fromItem, new EdgeItem(parentid, parentid, config.fromItem, config.fromItem));
            return logicalFamily.SKIP;
          });
        } else {
          configsHash[config.fromItem].push(config);
        }
      }
      for (fromItem in configsHash) {
        if (configsHash.hasOwnProperty(fromItem)) {
          configs = configsHash[fromItem];
          configs.sort(function(a, b) {
            return b.toItems.length - a.toItems.length;
          });
          for (index = 0; index < configs.length; index += 1) {
            config = configs[index];
            addLabelAnnotation(logicalFamily, edges, config.fromItem, config.toItems, function() {
              return new FamilyItem({
                id: config.id,
                isVisible: true,
                isLevelNeutral: true,
                isActive: false,
                itemConfig: config
              });
            });
          }
        }
      }
    }
  }
  function addLabelAnnotation(logicalFamily, edges, fromItem, toItems, onCreate) {
    var edge, isValid = true, commonParentId = null, toItem, index, len, bundleItem, bundleItems = [];
    for (index = 0, len = toItems.length; index < len; index += 1) {
      toItem = toItems[index];
      edge = edges.edge(fromItem, toItem);
      if (edge != null) {
        if (commonParentId == null) {
          commonParentId = edge.getFar(toItem);
        } else {
          if (commonParentId != edge.getFar(toItem)) {
            isValid = false;
            break;
          }
        }
        bundleItems.push(edge.getNear(toItem));
      } else {
        isValid = false;
        break;
      }
    }
    if (isValid) {
      bundleItem = onCreate();
      if (logicalFamily.bundleParents(commonParentId, bundleItems, bundleItem.id, bundleItem)) {
        bundleItem.levelGravity = GroupByType.Children;
        isValid = true;
      } else if (logicalFamily.bundleChildren(commonParentId, bundleItems, bundleItem.id, bundleItem)) {
        bundleItem.levelGravity = GroupByType.Parents;
        isValid = true;
      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {
        bundleItem.levelGravity = GroupByType.Children;
        isValid = true;
      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {
        bundleItem.levelGravity = GroupByType.Parents;
        isValid = true;
      }
      if (isValid) {
        for (index = 0, len = toItems.length; index < len; index += 1) {
          toItem = toItems[index];
          edge = edges.edge(fromItem, toItem);
          edge.setFar(toItem, bundleItem.id);
        }
      }
    }
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/HideGrandParentsConnectorsTask.js
function HideGrandParentsConnectorsTask(hideGrandParentsConnectorsOptionTask, removeLoopsTask) {
  var _data = {
    maximumId: null,
    /* maximum of OrgItem.id */
    logicalFamily: null
  };
  function process(debug) {
    var logicalFamily = removeLoopsTask.getLogicalFamily(), maximumId = removeLoopsTask.getMaximumId();
    var options = hideGrandParentsConnectorsOptionTask.getOptions();
    if (options.hideGrandParentsConnectors == true) {
      logicalFamily = logicalFamily.getFamilyWithoutGrandParentsRelations();
    } else {
      logicalFamily = logicalFamily.clone();
    }
    _data.logicalFamily = logicalFamily;
    _data.maximumId = maximumId;
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/BindFamilyConnectorsTask.js
function BindFamilyConnectorsTask(hideGrandParentsConnectorsTask) {
  var _data = {
    maximumId: null,
    /* maximum of OrgItem.id */
    logicalFamily: null
  };
  function process(debug) {
    var logicalFamily = hideGrandParentsConnectorsTask.getLogicalFamily(), maximumId = hideGrandParentsConnectorsTask.getMaximumId();
    logicalFamily = logicalFamily.clone();
    logicalFamily.optimizeReferences(function() {
      maximumId += 1;
      return new FamilyItem({
        id: maximumId,
        isVisible: false,
        isActive: false,
        itemConfig: { title: "bundle #" + maximumId, description: " This item was created by references optimizer." },
        levelGravity: GroupByType.Children,
        isLevelNeutral: true
      });
    });
    if (debug && !logicalFamily.validate()) {
      throw "References are broken in family structure!";
    }
    if (debug && logicalFamily.hasLoops()) {
      throw "Structure has loops!";
    }
    logicalFamily.eliminateManyToMany(
      function() {
        maximumId += 1;
        return new FamilyItem({
          id: maximumId,
          isVisible: false,
          isActive: false,
          itemConfig: { title: "dummy #" + maximumId, description: "This is item used to eliminate M:M relations." },
          levelGravity: GroupByType.Children,
          hideParentConnection: false,
          hideChildrenConnection: false,
          isLevelNeutral: true
        });
      }
      //ignore jslint
    );
    if (debug && !logicalFamily.validate()) {
      throw "References are broken in family structure!";
    }
    _data.logicalFamily = logicalFamily;
    _data.maximumId = maximumId;
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/BaseTransformer.js
function BaseTransformer(debug) {
  this.debug = debug;
}
BaseTransformer.prototype.validate = function(logicalFamily, strongValidate) {
  if (!logicalFamily.validate()) {
    throw "Family structure failed to pass validation!";
  }
  logicalFamily.loop(this, function(famItemId, famItem) {
    logicalFamily.loopChildren(this, famItemId, function(childid, child, level) {
      if (child.level === null || famItem.level === null || (strongValidate ? child.level != famItem.level + 1 : child.level <= famItem.level)) {
        throw "Family tree is broken. Children/Parents or levels mismatch!";
      }
      return logicalFamily.SKIP;
    });
  });
};

// node_modules/basicprimitives/src/connectors/MatrixConnectorBundle.js
function MatrixConnectorBundle(isChildren, items, matrixNodeId, connectionId, matrixWidth) {
  this.isChildren = isChildren;
  this.items = items;
  this.len = items.length;
  this.matrixNodeId = matrixNodeId;
  this.connectionId = connectionId;
  this.matrixWidth = matrixWidth;
  this.blocksCount = Math.ceil(this.matrixWidth / 2);
  this.rowsCount = Math.ceil(this.len / this.matrixWidth);
}
MatrixConnectorBundle.prototype = new BaseConnectorBundle();
MatrixConnectorBundle.prototype.trace = function(data, params, options) {
  if (this.isChildren) {
    this.traceChildrenLayout(data, params, options);
  } else {
    this.traceParentsLayout(data, params, options);
  }
};
MatrixConnectorBundle.prototype.traceChildrenLayout = function(data, params, options) {
  var actualPosition, forkItems = [];
  for (var blockIndex = 0; blockIndex < this.blocksCount; blockIndex += 1) {
    var prevMedianPoint = null;
    for (var rowIndex = this.rowsCount - 1; rowIndex >= 0; rowIndex -= 1) {
      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, true);
      var leftNodeId = null;
      var leftTreeItemPosition = null;
      if (leftNodeIndex < this.len) {
        leftNodeId = this.items[leftNodeIndex];
        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];
      }
      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, true);
      var rightNodeId = null;
      var rightTreeItemPosition = null;
      if (rightNodeIndex < this.len) {
        rightNodeId = this.items[rightNodeIndex];
        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];
      }
      var medianPoint = null;
      if (medianPoint == null && leftTreeItemPosition != null) {
        medianPoint = new this.ConnectorDestination({
          id: this.getId(data),
          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,
          y: leftTreeItemPosition.horizontalConnectorsShift
        });
      }
      if (medianPoint == null && rightTreeItemPosition != null) {
        medianPoint = new this.ConnectorDestination({
          id: this.getId(data),
          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,
          y: rightTreeItemPosition.horizontalConnectorsShift
        });
      }
      if (leftTreeItemPosition != null) {
        actualPosition = leftTreeItemPosition.actualPosition;
        params.transform.transformPoints(
          actualPosition.right(),
          medianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            leftNodeId = params.nestedLayoutParentConnectorIds[leftNodeId] || leftNodeId;
            data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(
              leftNodeId,
              medianPoint.id,
              polyline,
              null,
              leftNodeId,
              null,
              10,
              null,
              null,
              null,
              true
            ));
          }
        );
      }
      if (rightTreeItemPosition != null) {
        actualPosition = rightTreeItemPosition.actualPosition;
        params.transform.transformPoints(
          actualPosition.left(),
          medianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            rightNodeId = params.nestedLayoutParentConnectorIds[rightNodeId] || rightNodeId;
            data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(
              rightNodeId,
              medianPoint.id,
              polyline,
              null,
              rightNodeId,
              null,
              10,
              null,
              null,
              null,
              true
            ));
          }
        );
      }
      if (prevMedianPoint != null && medianPoint != null) {
        params.transform.transformPoints(
          prevMedianPoint.x,
          prevMedianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(
              prevMedianPoint.id,
              medianPoint.id,
              polyline,
              null,
              null,
              null,
              0
              /* weight */
            ));
          }
        );
      }
      if (medianPoint != null) {
        prevMedianPoint = medianPoint;
      }
    }
    if (prevMedianPoint != null) {
      forkItems.push(new this.ConnectorDestination({
        id: prevMedianPoint.id,
        bundleid: this.getId(data),
        x: prevMedianPoint.x,
        y: prevMedianPoint.y,
        isSquared: true,
        visibility: Visibility.Invisible
      }));
    }
  }
  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];
  actualPosition = parentTreeItemPosition.actualPosition;
  var parentPoint = new this.ConnectorDestination({
    id: this.matrixNodeId,
    x: actualPosition.horizontalCenter(),
    y: actualPosition.top()
  });
  this.traceFork(data, params, options, parentPoint, forkItems, true, false, 0, options.showExtraArrows);
};
MatrixConnectorBundle.prototype.traceParentsLayout = function(data, params, options) {
  var actualPosition, forkItems = [];
  for (var blockIndex = 0; blockIndex <= this.blocksCount; blockIndex += 1) {
    var prevMedianPoint = null;
    for (var rowIndex = 0; rowIndex < this.rowsCount; rowIndex += 1) {
      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, false);
      var leftNodeId = null;
      var leftTreeItemPosition = null;
      if (leftNodeIndex < this.len) {
        leftNodeId = this.items[leftNodeIndex];
        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];
      }
      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, false);
      var rightNodeId = null;
      var rightTreeItemPosition = null;
      if (rightNodeIndex < this.len) {
        rightNodeId = this.items[rightNodeIndex];
        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];
      }
      var medianPoint = null;
      if (medianPoint == null && leftTreeItemPosition != null) {
        medianPoint = new this.ConnectorDestination({
          id: this.getId(data),
          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,
          y: leftTreeItemPosition.horizontalConnectorsShift
        });
      }
      if (medianPoint == null && rightTreeItemPosition != null) {
        medianPoint = new this.ConnectorDestination({
          id: this.getId(data),
          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,
          y: rightTreeItemPosition.horizontalConnectorsShift
        });
      }
      if (leftTreeItemPosition != null) {
        actualPosition = leftTreeItemPosition.actualPosition;
        params.transform.transformPoints(
          actualPosition.right(),
          medianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            leftNodeId = params.nestedLayoutBottomConnectorIds[leftNodeId] || leftNodeId;
            data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(
              leftNodeId,
              medianPoint.id,
              polyline,
              leftNodeId,
              null,
              null,
              10,
              null,
              null,
              null,
              true
            ));
          }
        );
      }
      if (rightTreeItemPosition != null) {
        actualPosition = rightTreeItemPosition.actualPosition;
        params.transform.transformPoints(
          actualPosition.left(),
          medianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            rightNodeId = params.nestedLayoutBottomConnectorIds[rightNodeId] || rightNodeId;
            data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(
              rightNodeId,
              medianPoint.id,
              polyline,
              rightNodeId,
              null,
              null,
              10,
              null,
              null,
              null,
              true
            ));
          }
        );
      }
      if (prevMedianPoint != null && medianPoint != null) {
        params.transform.transformPoints(
          prevMedianPoint.x,
          prevMedianPoint.y,
          medianPoint.x,
          medianPoint.y,
          true,
          this,
          function(fromX, fromY, toX, toY) {
            var polyline = new Polyline();
            polyline.addSegment(new MoveSegment(fromX, fromY));
            polyline.addSegment(new LineSegment(toX, toY));
            data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(
              prevMedianPoint.id,
              medianPoint.id,
              polyline,
              null,
              null,
              null,
              0,
              null,
              null,
              null,
              true
            ));
          }
        );
      }
      if (medianPoint != null) {
        prevMedianPoint = medianPoint;
      }
    }
    if (prevMedianPoint != null) {
      forkItems.push(new this.ConnectorDestination({
        id: prevMedianPoint.id,
        bundleid: this.getId(data),
        x: prevMedianPoint.x,
        y: prevMedianPoint.y,
        isSquared: true,
        visibility: Visibility.Invisible
      }));
    }
  }
  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];
  actualPosition = parentTreeItemPosition.actualPosition;
  var parentPoint = new this.ConnectorDestination({
    id: this.connectionId,
    x: actualPosition.horizontalCenter(),
    y: actualPosition.bottom()
  });
  this.traceFork(data, params, options, parentPoint, forkItems, true, true, 0, options.showExtraArrows);
};
MatrixConnectorBundle.prototype.getNodeIndex = function(blockIndex, row, isLeft, isChild) {
  var result = null, column;
  if (isChild) {
    column = blockIndex * 2 + (isLeft ? 0 : 1);
    if (this.matrixWidth > column) {
      result = row * this.matrixWidth + column;
    }
  } else {
    column = blockIndex * 2 + (isLeft ? -1 : 0);
    if (column >= 0 && column < this.matrixWidth) {
      result = row * this.matrixWidth + column;
    }
  }
  return result;
};

// node_modules/basicprimitives/src/tasks/transformations/layouts/MatrixLayout.js
function MatrixLayout(items, hideParentConnection, hideChildrenConnection) {
  this.items = items;
  this.hideParentConnection = hideParentConnection;
  this.hideChildrenConnection = hideChildrenConnection;
  this.data = {
    columns: [],
    rows: []
  };
}
MatrixLayout.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    for (var index = 0, len = this.items.length; index < len; index += 1) {
      var item = this.items[index];
      onItem.call(thisArg, item, 0);
    }
  }
};
MatrixLayout.prototype.Column = function() {
  this.depth = 0;
  this.offset = 0;
  this.leftPadding = 0;
  this.rightPadding = 0;
  this.layoutDirection = AdviserPlacementType.Left;
};
MatrixLayout.prototype.Row = function() {
  this.depth = 0;
  this.offset = 0;
  this.horizontalConnectorsDepth = 0;
  this.minimalDepth = null;
  this.dotsDepth = null;
};
MatrixLayout.prototype.getMatrixWidth = function(maximumColumnsInMatrix, len) {
  return Math.min(maximumColumnsInMatrix, Math.ceil(Math.sqrt(len)));
};
MatrixLayout.prototype.measure = function(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {
  var data = {
    columns: [],
    rows: []
  };
  this.measureColumns(data, this.items, treeItemsPositions, options);
  this.measureRows(data, this.items, treeItemsPositions, options);
  this.data = data;
  var treeItemPosition = new TreeItemPosition();
  treeItemPosition.actualVisibility = Visibility.Normal;
  treeItemPosition.actualSize = this.getLayoutSize(data);
  return treeItemPosition;
};
MatrixLayout.prototype.measureColumns = function(data, items, treeItemsPositions, options) {
  var column, index, len, maximumColumns = this.getMatrixWidth(options.maximumColumnsInMatrix, items.length);
  for (index = 0, len = items.length; index < len; index += 1) {
    var treeItem = items[index];
    var treeItemId = treeItem.id;
    var treeItemPosition = treeItemsPositions[treeItemId];
    var horizontalPadding = options.intervals[treeItemPosition.actualVisibility] / 2;
    var columnIndex = index % maximumColumns;
    column = data.columns[columnIndex];
    if (column == null) {
      column = new this.Column();
      column.layoutDirection = columnIndex % 2 ? AdviserPlacementType.Right : AdviserPlacementType.Left;
      data.columns[columnIndex] = column;
    }
    var itemWidth = horizontalPadding + treeItemPosition.actualSize.width + horizontalPadding;
    column.depth = Math.max(column.depth, itemWidth);
  }
  var arrowTipLength = options.linesWidth * 8;
  var offset = 0;
  for (index = 0, len = data.columns.length; index < len; index += 1) {
    column = data.columns[index];
    if (index % 2 == 0) {
      switch (options.arrowsDirection) {
        case GroupByType.Parents:
          column.leftPadding = this.hideChildrenConnection ? 0 : arrowTipLength;
          column.rightPadding = 0;
          break;
        case GroupByType.Children:
          column.leftPadding = 0;
          column.rightPadding = this.hideParentConnection ? 0 : arrowTipLength;
          break;
      }
    } else {
      switch (options.arrowsDirection) {
        case GroupByType.Parents:
          column.leftPadding = 0;
          column.rightPadding = this.hideChildrenConnection ? 0 : arrowTipLength;
          break;
        case GroupByType.Children:
          column.leftPadding = this.hideParentConnection ? 0 : arrowTipLength;
          column.rightPadding = 0;
          break;
      }
    }
    column.offset = offset + column.leftPadding + column.depth / 2;
    offset = column.offset + column.depth / 2 + column.rightPadding;
  }
};
MatrixLayout.prototype.measureRows = function(data, items, treeItemsPositions, options) {
  var index, len, row, maximumColumns = this.getMatrixWidth(options.maximumColumnsInMatrix, items.length);
  for (index = 0, len = items.length; index < len; index += 1) {
    var treeItem = items[index];
    var treeItemId = treeItem.id;
    var treeItemPosition = treeItemsPositions[treeItemId];
    var rowIndex = Math.floor(index / maximumColumns);
    var verticalPadding = options.shifts[treeItemPosition.actualVisibility] / 2;
    row = data.rows[rowIndex];
    if (row == null) {
      row = new this.Row();
      data.rows[rowIndex] = row;
    }
    row.depth = Math.max(row.depth, verticalPadding + treeItemPosition.actualSize.height + verticalPadding);
    switch (treeItemPosition.actualVisibility) {
      case Visibility.Dot:
      case Visibility.Line:
      case Visibility.Invisible:
        row.dotsDepth = !row.dotsDepth ? treeItemPosition.actualSize.height : Math.min(row.dotsDepth, treeItemPosition.actualSize.height);
        break;
      default:
        row.minimalDepth = !row.minimalDepth ? treeItemPosition.actualSize.height : Math.min(row.minimalDepth, treeItemPosition.actualSize.height);
        break;
    }
  }
  var offset = 0;
  for (index = 0, len = data.rows.length; index < len; index += 1) {
    row = data.rows[index];
    row.offset = offset + row.depth / 2;
    offset = row.offset + row.depth / 2;
    if (row.minimalDepth == null) {
      row.minimalDepth = row.depth;
    }
    if (row.dotsDepth != null && row.dotsDepth > row.minimalDepth) {
      row.minimalDepth = row.dotsDepth;
    }
    switch (options.verticalAlignment) {
      case VerticalAlignmentType.Top:
        row.horizontalConnectorsDepth = row.minimalDepth / 2;
        break;
      case VerticalAlignmentType.Middle:
        row.horizontalConnectorsDepth = row.depth / 2;
        break;
      case VerticalAlignmentType.Bottom:
        row.horizontalConnectorsDepth = row.depth - row.minimalDepth / 2;
        break;
    }
  }
};
MatrixLayout.prototype.getLayoutSize = function(data) {
  return new Rect(0, 0, Math.round(this.getLayoutWidth(data)), Math.round(this.getLayoutHeight(data)));
};
MatrixLayout.prototype.getLayoutWidth = function(data) {
  var result = 0, length = data.columns.length;
  if (length > 0) {
    var lastColumn = data.columns[length - 1];
    result = lastColumn.offset + lastColumn.depth / 2 + lastColumn.rightPadding;
  }
  return result;
};
MatrixLayout.prototype.getLayoutHeight = function(data) {
  var result = 0, length = data.rows.length;
  if (length > 0) {
    var lastRow = data.rows[length - 1];
    result = lastRow.offset + lastRow.depth / 2;
  }
  return result;
};
MatrixLayout.prototype.arrange = function(thisArg, parentPosition, layoutDirection, treeItemsPositions, options, onItemPositioned) {
  if (onItemPositioned != null) {
    var maximumColumns = this.getMatrixWidth(options.maximumColumnsInMatrix, this.items.length);
    for (var index = 0, len = this.items.length; index < len; index += 1) {
      var treeItem = this.items[index], treeItemId = treeItem.id;
      var columnIndex = index % maximumColumns;
      var column = this.data.columns[columnIndex];
      var rowIndex = Math.floor(index / maximumColumns);
      var row = this.data.rows[rowIndex];
      var treeItemPosition = treeItemsPositions[treeItemId];
      var actualPosition = this.getItemPosition(treeItemPosition.actualVisibility, column, row, treeItemPosition.actualSize, options.verticalAlignment);
      actualPosition.translate(parentPosition.x, parentPosition.y);
      treeItemPosition = __spreadProps(__spreadValues({}, treeItemPosition), {
        actualPosition,
        horizontalConnectorsShift: parentPosition.y + row.offset - row.depth / 2 + row.horizontalConnectorsDepth,
        leftMedianOffset: column.depth / 2 + column.leftPadding,
        rightMedianOffset: column.depth / 2 + column.rightPadding,
        topConnectorShift: row.depth / 2,
        bottomConnectorShift: row.depth / 2
      });
      onItemPositioned.call(thisArg, treeItemId, treeItemPosition, column.layoutDirection);
    }
  }
};
MatrixLayout.prototype.getItemPosition = function(visibility, column, row, size, verticalAlignment) {
  var itemShift = 0;
  switch (visibility) {
    case Visibility.Normal:
      switch (verticalAlignment) {
        case VerticalAlignmentType.Top:
          itemShift = 0;
          break;
        case VerticalAlignmentType.Middle:
          itemShift = (row.depth - size.height) / 2;
          break;
        case VerticalAlignmentType.Bottom:
          itemShift = row.depth - size.height;
          break;
      }
      break;
    case Visibility.Dot:
    case Visibility.Line:
    case Visibility.Invisible:
      itemShift = row.horizontalConnectorsDepth - size.height / 2;
      break;
  }
  return new Rect(column.offset - size.width / 2, row.offset - row.depth / 2 + itemShift, size.width, size.height);
};

// node_modules/basicprimitives/src/tasks/transformations/layouts/HorizontalLayout.js
function HorizontalLayout(items, hideParentConnection, hideChildrenConnection) {
  this.items = items;
  this.hideParentConnection = hideParentConnection;
  this.hideChildrenConnection = hideChildrenConnection;
  this.data = {
    columns: [],
    row: null
  };
}
HorizontalLayout.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    for (var index = 0, len = this.items.length; index < len; index += 1) {
      var item = this.items[index];
      onItem.call(thisArg, item, 0);
    }
  }
};
HorizontalLayout.prototype.Column = function() {
  this.depth = 0;
  this.offset = 0;
  this.parentsPadding = 0;
  this.childrenPadding = 0;
};
HorizontalLayout.prototype.Row = function() {
  this.depth = 0;
  this.offset = 0;
  this.minimalDepth = null;
  this.dotsDepth = null;
};
HorizontalLayout.prototype.measure = function(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {
  var data = {
    columns: [],
    row: null
  };
  this.measureColumns(data, this.items, treeItemsPositions, options);
  this.measureRow(data, this.items, treeItemsPositions, options);
  this.data = data;
  var treeItemPosition = new TreeItemPosition();
  treeItemPosition.actualVisibility = Visibility.Normal;
  treeItemPosition.actualSize = this.getLayoutSize(data);
  return treeItemPosition;
};
HorizontalLayout.prototype.measureColumns = function(data, items, treeItemsPositions, options) {
  var column;
  var offset = 0;
  var arrowTipLength = options.linesWidth * 8;
  for (var index = 0; index < items.length; index += 1) {
    var treeItem = items[index];
    var treeItemId = treeItem.id;
    var treeItemPosition = treeItemsPositions[treeItemId];
    column = data.columns[index];
    if (column == null) {
      column = new this.Column();
      data.columns[index] = column;
    }
    column.depth = treeItemPosition.actualSize.width;
    var padding = options.intervals[treeItemPosition.actualVisibility] / 2;
    if (index != 0) {
      column.parentsPadding = padding;
    }
    if (index != items.length - 1) {
      column.childrenPadding = padding;
    }
    switch (options.arrowsDirection) {
      case GroupByType.Parents:
        if (index != items.length - 1) {
          column.childrenPadding += this.hideChildrenConnection ? 0 : arrowTipLength;
        }
        break;
      case GroupByType.Children:
        if (index != 0) {
          column.parentsPadding += this.hideParentConnection ? 0 : arrowTipLength;
        }
        break;
    }
    column.offset = offset + column.parentsPadding + column.depth / 2;
    offset = column.offset + column.depth / 2 + column.childrenPadding;
  }
};
HorizontalLayout.prototype.measureRow = function(data, items, treeItemsPositions, options) {
  data.row = new this.Row();
  var row = data.row;
  for (var index = 0; index < items.length; index += 1) {
    var treeItem = items[index];
    var treeItemId = treeItem.id;
    var treeItemPosition = treeItemsPositions[treeItemId];
    var verticalPadding = options.shifts[treeItemPosition.actualVisibility] / 2;
    row.depth = Math.max(row.depth, verticalPadding + treeItemPosition.actualSize.height + verticalPadding);
    switch (treeItemPosition.actualVisibility) {
      case Visibility.Dot:
      case Visibility.Line:
      case Visibility.Invisible:
        row.dotsDepth = !row.dotsDepth ? treeItemPosition.actualSize.height : Math.min(row.dotsDepth, treeItemPosition.actualSize.height);
        break;
      default:
        row.minimalDepth = !row.minimalDepth ? treeItemPosition.actualSize.height : Math.min(row.minimalDepth, treeItemPosition.actualSize.height);
        break;
    }
  }
  ;
  row.offset = row.depth / 2;
  if (row.minimalDepth == null) {
    row.minimalDepth = row.depth;
  }
  if (row.dotsDepth != null && row.dotsDepth > row.minimalDepth) {
    row.minimalDepth = row.dotsDepth;
  }
};
HorizontalLayout.prototype.getLayoutSize = function(data) {
  var width = 0, length = data.columns.length;
  if (length > 0) {
    var lastColumn = data.columns[length - 1];
    width = lastColumn.offset + lastColumn.depth / 2 + lastColumn.childrenPadding;
  }
  var height = data.row.offset + data.row.depth / 2;
  return new Rect(0, 0, Math.round(width), Math.round(height));
};
HorizontalLayout.prototype.arrange = function(thisArg, parentPosition, layoutDirection, treeItemsPositions, options, onItemPositioned) {
  if (onItemPositioned != null) {
    for (var index = 0; index < this.items.length; index += 1) {
      var treeItem = this.items[index];
      var treeItemId = treeItem.id;
      var column = this.data.columns[index];
      var row = this.data.row;
      var treeItemPosition = treeItemsPositions[treeItemId];
      var offset = column.offset;
      if (layoutDirection == AdviserPlacementType.Left) {
        offset = parentPosition.width - column.offset;
      }
      var actualPosition = this.getItemPosition(treeItemPosition.actualVisibility, offset, row, treeItemPosition.actualSize, options);
      actualPosition.translate(parentPosition.x, parentPosition.y);
      treeItemPosition = __spreadProps(__spreadValues({}, treeItemPosition), {
        actualPosition,
        horizontalConnectorsShift: parentPosition.y + row.offset - row.depth / 2 + row.offset,
        leftMedianOffset: column.depth / 2 + (layoutDirection == AdviserPlacementType.Left ? column.childrenPadding : column.parentsPadding),
        rightMedianOffset: column.depth / 2 + (layoutDirection == AdviserPlacementType.Left ? column.parentsPadding : column.childrenPadding),
        topConnectorShift: row.depth / 2,
        bottomConnectorShift: row.depth / 2
      });
      onItemPositioned.call(thisArg, treeItemId, treeItemPosition);
    }
    ;
  }
};
HorizontalLayout.prototype.getItemPosition = function(visibility, offset, row, size, options) {
  return new Rect(offset - size.width / 2, row.offset - size.height / 2, size.width, size.height);
};

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyMatrixesExtractor.js
function FamilyMatrixesExtractor(debug) {
  this.parent = BaseTransformer.prototype;
  this.parent.constructor.apply(this, arguments);
}
FamilyMatrixesExtractor.prototype = new BaseTransformer();
FamilyMatrixesExtractor.prototype.extract = function(options, getConfig, logicalFamily, maximumId) {
  var layouts = {}, nestedLayoutParentConnectorIds = {}, nestedLayoutBottomConnectorIds = {}, bundles = [];
  if (logicalFamily.hasNodes() > 0) {
    if (options.enableMatrixLayout) {
      logicalFamily.groupBy(
        this,
        Math.max(2, options.minimumMatrixSize),
        function(parentIds, childIds, groups) {
          var nodes = [];
          for (var groupIndex = 0; groupIndex < groups.length; groupIndex += 1) {
            var group = groups[groupIndex];
            if (group.length == 1) {
              nodes.push(group[0].node);
            } else {
              maximumId += 1;
              var id = maximumId;
              maximumId += 1;
              var id2 = maximumId;
              var horizontalNode = new FamilyItem({
                id,
                isVisible: false,
                isActive: false,
                itemConfig: { title: "dummy #" + id, description: "This is item used as aggregator of horizontally grouped nodes." },
                hideParentConnection: true,
                hideChildrenConnection: true
              });
              nestedLayoutParentConnectorIds[id] = group[0].id;
              nestedLayoutBottomConnectorIds[id] = group[group.length - 1].id;
              for (var index = 0; index < group.length - 1; index += 1) {
                var fromNode = group[index];
                var toNode = group[index + 1];
                bundles.push(new HorizontalConnectorBundle(toNode.id, fromNode.id));
              }
              for (var index = 0; index < group.length; index += 1) {
                var node = group[index];
                logicalFamily.removeNode(node.id);
              }
              var ids = nodes.map((node2) => node2.id);
              if (parentIds.length > 0) {
                logicalFamily.add(parentIds, id, horizontalNode);
                horizontalNode.hideParentConnection = false;
              } else {
                logicalFamily.add(null, id, horizontalNode);
              }
              if (childIds.length > 0) {
                for (var index = 0; index < childIds.length; index += 1) {
                  logicalFamily.adopt([id], childIds[index]);
                }
                horizontalNode.hideChildrenConnection = false;
              }
              layouts[id] = new HorizontalLayout(group.map((item) => item.node), horizontalNode.hideParentConnection, horizontalNode.hideChildrenConnection);
              nodes.push(horizontalNode);
            }
          }
          maximumId += 1;
          var id = maximumId;
          maximumId += 1;
          var id2 = maximumId;
          var matrixNode = new FamilyItem({
            id,
            isVisible: false,
            isActive: false,
            itemConfig: { title: "dummy #" + id, description: "This is item used as aggregator of matrixed nodes." },
            hideParentConnection: true,
            hideChildrenConnection: true
          });
          nestedLayoutBottomConnectorIds[id] = id2;
          for (var index = 0, len = nodes.length; index < len; index += 1) {
            var node = nodes[index];
            logicalFamily.removeNode(node.id);
          }
          var ids = nodes.map((node2) => node2.id);
          if (parentIds.length > 0) {
            logicalFamily.add(parentIds, id, matrixNode);
            matrixNode.hideParentConnection = false;
            bundles.push(new MatrixConnectorBundle(true, ids, id, id, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));
          } else {
            logicalFamily.add(null, id, matrixNode);
          }
          if (childIds.length > 0) {
            for (var index = 0; index < childIds.length; index += 1) {
              logicalFamily.adopt([id], childIds[index]);
            }
            matrixNode.hideChildrenConnection = false;
            bundles.push(new MatrixConnectorBundle(false, ids, id, id2, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));
          }
          layouts[id] = new MatrixLayout(nodes, matrixNode.hideParentConnection, matrixNode.hideChildrenConnection);
        },
        function(items) {
          var result = null;
          var count = 0;
          for (var index = 0; index < items.length; index += 1) {
            var item = items[index];
            var itemConfig = getConfig(item.id);
            if (itemConfig != null) {
              if (count > 0) {
                result = -1;
                break;
              }
              count++;
              if (itemConfig.addToMatrix) {
                result = itemConfig.matrixId;
              } else {
                result = -1;
                break;
              }
            }
          }
          if (count == 0) {
            result = -1;
          }
          return result;
        }
      );
    }
  }
  return { maximumId, nestedLayoutParentConnectorIds, nestedLayoutBottomConnectorIds, layouts, bundles };
};
FamilyMatrixesExtractor.prototype.getMatrixWidth = function(maximumColumnsInMatrix, len) {
  return Math.min(maximumColumnsInMatrix, Math.ceil(Math.sqrt(len)));
};

// node_modules/basicprimitives/src/tasks/transformations/ExtractNestedLayoutsTask.js
function ExtractNestedLayoutsTask(extractNestedLayoutsOptionTask, bindFamilyConnectorsTask) {
  var _data = {
    maximumId: null,
    /* maximum of OrgItem.id */
    logicalFamily: null
  }, _familyMatrixesExtractor = new FamilyMatrixesExtractor(false);
  function process(debug) {
    var logicalFamily = bindFamilyConnectorsTask.getLogicalFamily(), maximumId = bindFamilyConnectorsTask.getMaximumId(), extractNestedLayoutsOptions = extractNestedLayoutsOptionTask.getOptions();
    var options = {
      enableMatrixLayout: extractNestedLayoutsOptions.enableMatrixLayout,
      minimumMatrixSize: extractNestedLayoutsOptions.minimumMatrixSize,
      maximumColumnsInMatrix: extractNestedLayoutsOptions.maximumColumnsInMatrix
    };
    logicalFamily = logicalFamily.clone();
    var { maximumId, layouts, nestedLayoutParentConnectorIds, nestedLayoutBottomConnectorIds, bundles } = _familyMatrixesExtractor.extract(options, extractNestedLayoutsOptionTask.getConfig, logicalFamily, maximumId);
    _data.logicalFamily = logicalFamily;
    _data.maximumId = maximumId;
    _data.layouts = layouts;
    _data.nestedLayoutParentConnectorIds = nestedLayoutParentConnectorIds;
    _data.nestedLayoutBottomConnectorIds = nestedLayoutBottomConnectorIds;
    _data.bundles = bundles;
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getLayouts() {
    return _data.layouts;
  }
  function getNestedLayoutParentConnectorIds() {
    return _data.nestedLayoutParentConnectorIds;
  }
  function getNestedLayoutBottomConnectorIds() {
    return _data.nestedLayoutBottomConnectorIds;
  }
  function getBundles() {
    return _data.bundles;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId,
    getLayouts,
    getNestedLayoutParentConnectorIds,
    getNestedLayoutBottomConnectorIds,
    getBundles
  };
}

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyNormalizer.js
function FamilyNormalizer(debug) {
  this.parent = BaseTransformer.prototype;
  this.parent.constructor.apply(this, arguments);
}
FamilyNormalizer.prototype = new BaseTransformer();
FamilyNormalizer.prototype.normalize = function(options, logicalFamily, maximumId) {
  if (logicalFamily.hasNodes() > 0) {
    var toBeRemoved = [];
    logicalFamily.loop(this, function(itemId2, item) {
      if (item.isLevelNeutral) {
        toBeRemoved.push(itemId2);
      }
    });
    var logicalFamily2 = logicalFamily;
    if (toBeRemoved.length > 0) {
      logicalFamily2 = logicalFamily.clone();
      for (var index = 0; index < toBeRemoved.length; index += 1) {
        var itemId = toBeRemoved[index];
        var parents = [];
        logicalFamily2.loopParents(this, itemId, function(parentId, parent, levelIndex) {
          if (levelIndex == 0) {
            parents.push(parentId);
            return;
          }
          return true;
        });
        var children = [];
        if (parents.length > 0) {
          logicalFamily2.loopChildren(this, itemId, function(childId2, child, levelIndex) {
            if (levelIndex == 0) {
              children.push(childId2);
              return;
            }
            return true;
          });
        }
        logicalFamily2.removeNode(itemId);
        if (children.length > 0) {
          for (var childIndex = 0; childIndex < children.length; childIndex += 1) {
            var childId = children[childIndex];
            logicalFamily2.adopt(parents, childId);
          }
        }
      }
    }
    logicalFamily2.loopLevels(this, options.groupByType == GroupByType.Parents, function(itemId2, item, levelIndex) {
      item.level = levelIndex;
    });
    if (options.alignBylevels) {
      this.resortItemsBylevels(logicalFamily);
    } else {
      logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function(itemid, item, levelIndex) {
        item.level = levelIndex;
      });
    }
    if (this.debug) {
      this.validate(logicalFamily, false);
    }
    this.fillInItems(
      logicalFamily,
      function(famItem) {
        var result;
        maximumId += 1;
        result = new FamilyItem({
          id: maximumId,
          levelGravity: GroupByType.Children,
          isVisible: false,
          isActive: false,
          itemConfig: { title: "extension #" + maximumId, description: "This is item used to fill gaps in levels." }
        });
        return result;
      }
      //ignore jslint
    );
    if (this.debug) {
      this.validate(logicalFamily, true);
    }
  }
  return maximumId;
};
FamilyNormalizer.prototype.resortItemsBylevels = function(logicalFamily) {
  var itemsAtLevels = [], minimumLevel = null, maximumLevel = null, index, itemsAtLevel;
  logicalFamily.loop(this, function(famItemId, famItem) {
    famItem.originalLevel = famItem.level;
    famItem.level = null;
    if (famItem.originalLevel != null) {
      if (!itemsAtLevels[famItem.originalLevel]) {
        itemsAtLevels[famItem.originalLevel] = {};
      }
      itemsAtLevels[famItem.originalLevel][famItemId] = famItem;
      minimumLevel = minimumLevel != null ? Math.min(famItem.originalLevel, minimumLevel) : famItem.originalLevel;
      maximumLevel = maximumLevel != null ? Math.max(famItem.originalLevel, maximumLevel) : famItem.originalLevel;
    }
  });
  for (index = minimumLevel; index <= maximumLevel; index += 1) {
    itemsAtLevel = itemsAtLevels[index];
    this.setLevelsForItems(itemsAtLevel, logicalFamily);
  }
  logicalFamily.loopTopo(this, function(famItemId, famItem, position) {
    var level;
    if (famItem.levelGravity == GroupByType.Parents) {
      level = null;
      logicalFamily.loopParents(this, famItemId, function(childItemId, childFamItem, levelIndex) {
        level = level == null ? childFamItem.level + 1 : Math.max(childFamItem.level + 1, level);
        return logicalFamily.SKIP;
      });
      famItem.level = !level ? famItem.level : level;
    }
  });
};
FamilyNormalizer.prototype.setLevelsForItems = function(items, logicalFamily) {
  var level = 0, key, famItem, nextItems;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      logicalFamily.loopParents(this, key, function(parentid, parent, levelIndex) {
        level = Math.max(parent.level + 1, level);
        return logicalFamily.SKIP;
      });
    }
  }
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      famItem = items[key];
      famItem.level = level;
    }
  }
  while (!isEmptyObject(items)) {
    nextItems = {};
    for (key in items) {
      if (items.hasOwnProperty(key)) {
        famItem = items[key];
        logicalFamily.loopChildren(this, key, function(childid, child, levelIndex) {
          if (child.originalLevel == null || child.isLevelNeutral) {
            child.level = child.level == null ? famItem.level + 1 : Math.max(child.level, famItem.level + 1);
            nextItems[childid] = child;
          }
          return logicalFamily.SKIP;
        });
      }
    }
    items = nextItems;
  }
};
FamilyNormalizer.prototype.fillInItems = function(logicalFamily, createFamItem) {
  var bundleItem;
  logicalFamily.loop(this, function(famItemId, famItem) {
    var extNeeded = true, itemsToBundle;
    while (extNeeded) {
      extNeeded = false;
      itemsToBundle = [];
      logicalFamily.loopParents(this, famItemId, function(parentItemId, parentItem, level) {
        if (famItem.level - 1 > parentItem.level) {
          itemsToBundle.push(parentItemId);
        }
        return logicalFamily.SKIP;
      });
      if (itemsToBundle.length > 1) {
        bundleItem = createFamItem(famItem);
        bundleItem.level = famItem.level - 1;
        bundleItem.hideParentConnection = false;
        bundleItem.hideChildrenConnection = false;
        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);
        extNeeded = true;
        famItemId = bundleItem.id;
        famItem = bundleItem;
      }
    }
  });
  logicalFamily.loop(this, function(famItemId, famItem) {
    var extNeeded = true, itemsToBundle, isSingleExtension = true;
    while (extNeeded) {
      extNeeded = false;
      itemsToBundle = [];
      logicalFamily.loopChildren(this, famItemId, function(childItemId, childItem, level) {
        if (famItem.level + 1 < childItem.level) {
          itemsToBundle.push(childItemId);
        } else {
          isSingleExtension = false;
        }
        return logicalFamily.SKIP;
      });
      if (itemsToBundle.length > 1) {
        bundleItem = createFamItem(famItem);
        bundleItem.level = famItem.level + 1;
        if (isSingleExtension) {
          bundleItem.hideParentConnection = false;
          bundleItem.hideChildrenConnection = false;
        }
        logicalFamily.bundleChildren(famItemId, itemsToBundle, bundleItem.id, bundleItem);
        extNeeded = true;
        famItemId = bundleItem.id;
        famItem = bundleItem;
      }
    }
  });
  logicalFamily.loop(this, function(famItemId, famItem) {
    var extNeeded = true, itemsToBundle;
    while (extNeeded) {
      extNeeded = false;
      itemsToBundle = [];
      logicalFamily.loopParents(this, famItemId, function(parentItemId, parentItem, level) {
        if (famItem.level - 1 > parentItem.level) {
          itemsToBundle.push(parentItemId);
        }
        return logicalFamily.SKIP;
      });
      if (itemsToBundle.length > 0) {
        bundleItem = createFamItem(famItem);
        bundleItem.level = famItem.level - 1;
        bundleItem.hideParentConnection = false;
        bundleItem.hideChildrenConnection = false;
        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);
        extNeeded = true;
        famItemId = bundleItem.id;
        famItem = bundleItem;
      }
    }
  });
};

// node_modules/basicprimitives/src/tasks/transformations/NormalizeLogicalFamilyTask.js
function NormalizeLogicalFamilyTask(normalizeOptionTask, extractNestedLayoutsTask) {
  var _data = {
    maximumId: null,
    /* maximum of OrgItem.id */
    logicalFamily: null
  }, _familyNormalizer = new FamilyNormalizer(false);
  function process(debug) {
    var logicalFamily = extractNestedLayoutsTask.getLogicalFamily(), maximumId = extractNestedLayoutsTask.getMaximumId(), normalizeOptions = normalizeOptionTask.getOptions();
    var options = {
      groupByType: normalizeOptions.groupByType,
      alignBylevels: normalizeOptions.alignBylevels
    };
    logicalFamily = logicalFamily.clone();
    maximumId = _familyNormalizer.normalize(options, logicalFamily, maximumId);
    _data.logicalFamily = logicalFamily;
    _data.maximumId = maximumId;
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyBalanceItem.js
function FamilyBalanceItem(id, familyId, level) {
  this.id = id;
  this.familyId = familyId;
  this.level = level;
  this.childIndex = 0;
}

// node_modules/basicprimitives/src/models/Slot.js
function Slot(itemid) {
  this.itemId = itemid;
  this.position = null;
  this.balance = 0;
  this.left = {};
  this.right = {};
  this.crossings = {};
}
Slot.prototype.clone = function(itemid) {
  var result = new Slot(itemid), level;
  for (level in this.left) {
    if (this.left.hasOwnProperty(level)) {
      result.left[level] = this.left[level];
    }
  }
  for (level in this.right) {
    if (this.right.hasOwnProperty(level)) {
      result.right[level] = this.right[level];
    }
  }
  for (level in this.crossings) {
    if (this.crossings.hasOwnProperty(level)) {
      result.crossings[level] = this.crossings[level];
    }
  }
  result.itemid = itemid;
  return result;
};

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyBalance.js
function FamilyBalance() {
}
FamilyBalance.prototype.balance = function(params) {
  var result = {
    maximumId: null,
    treeLevels: TreeLevels(),
    bundles: [],
    connectorStacks: []
  };
  var data = {
    orgTree: Tree(),
    /*tree OrgItem */
    maximumId: params.maximumId,
    orgPartners: {},
    /* Creates extra partners collection of relations between visual tree items They are used to draw connectors between items in different branches of organizational chart*/
    itemByChildrenKey: {},
    minimumLevel: null,
    maximumLevel: null
  };
  this.createOrgTree(params, data);
  var currentLevelIndex, index = -1;
  data.orgTree.loopLevels(this, function(treeItemId, treeItem, levelIndex) {
    var familyItem = params.logicalFamily.node(treeItemId);
    if (familyItem != null) {
      if (currentLevelIndex !== levelIndex) {
        currentLevelIndex = levelIndex;
        index += 1;
      }
      result.treeLevels.addItem(index, treeItemId, familyItem);
    }
  });
  this.recalcLevelsDepth(result.bundles, result.connectorStacks, result.treeLevels, params.logicalFamily);
  result.maximumId = data.maximumId;
  return result;
};
FamilyBalance.prototype.Family = function(id) {
  this.id = null;
  this.familyPriority = 1;
  this.childFamilies = [];
  this.items = [];
  this.links = [];
  this.backLinks = [];
  if (arguments.length == 1) {
    this.id = id;
  }
};
FamilyBalance.prototype.FamLink = function(fromItem, toItem) {
  this.fromItem = fromItem;
  this.toItem = toItem;
};
FamilyBalance.prototype.createOrgTree = function(params, data) {
  var index, len, index2, len2, familiesGraph, link, links, fromFamily, toFamily, sortedFamilies = [], sortedFamiliesHash, attachedFamilies, familyId, family, familyRootItem, fromItem, toItem, rootItem, rootItems, bestRootItem, bestReference, spanningTree, extraGravities, grandChildren, orgItemRoot, famItemsExtracted, families = [], families2;
  if (params.logicalFamily.hasNodes() > 0) {
    famItemsExtracted = {};
    familyId = 0;
    families2 = [];
    params.logicalFamily.loopRoots(this, function(grandParentId, grandParent) {
      family = new this.Family(familyId);
      this.extractOrgChart(grandParentId, params.logicalFamily, params.primaryParents, data.orgTree, data.orgPartners, data.itemByChildrenKey, famItemsExtracted, family);
      families.push(family);
      families2.push(family);
      familyId += 1;
    });
    families2.sort(function(a, b) {
      var aLevel = a.items[0].level, bLevel = b.items[0].level;
      return aLevel != bLevel ? aLevel - bLevel : b.items.length - a.items.length;
    });
    sortedFamilies = [];
    sortedFamiliesHash = {};
    if (families.length > 0) {
      familiesGraph = Graph();
      for (index = 0, len = families.length; index < len; index += 1) {
        family = families[index];
        for (index2 = 0, len2 = family.links.length; index2 < len2; index2 += 1) {
          link = family.links[index2];
          fromFamily = params.logicalFamily.node(link.fromItem).familyId;
          toFamily = params.logicalFamily.node(link.toItem).familyId;
          if (fromFamily != toFamily) {
            familiesGraph.addEdge(fromFamily, toFamily, { weight: 0 });
            familiesGraph.edge(fromFamily, toFamily).weight += 1;
          }
          families[toFamily].backLinks.push(new this.FamLink(link.toItem, link.fromItem));
        }
      }
      while (sortedFamilies.length < families.length) {
        for (index = 0, len = families2.length; index < len; index += 1) {
          family = families2[index];
          if (!sortedFamiliesHash.hasOwnProperty(family.id)) {
            spanningTree = familiesGraph.getSpanningTree(family.id, function(edge) {
              return -edge.weight;
            });
            if (spanningTree.node(family.id) != null) {
              spanningTree.loopPostOrder(this, function(nodeid, node, parentid, parent) {
                var family2 = families[nodeid], parentFamily = families[parentid], children = [];
                if (parentid != null) {
                  parentFamily.familyPriority = parentFamily.familyPriority + family2.familyPriority;
                }
                children = [];
                spanningTree.loopChildren(this, nodeid, function(childid, child, index3) {
                  children.push(childid);
                });
                children.sort(function(a, b) {
                  return families[a].familyPriority - families[b].familyPriority;
                });
                spanningTree.arrangeChildren(nodeid, children);
              });
              spanningTree.loopPreOrder(this, function(familyid, node) {
                sortedFamilies.push(familyid);
                sortedFamiliesHash[familyid] = true;
              });
            } else {
              sortedFamilies.push(family.id);
              sortedFamiliesHash[family.id] = true;
            }
          }
        }
      }
    }
    data.maximumId += 1;
    orgItemRoot = new FamilyBalanceItem(data.maximumId, null, data.minimumLevel - 1);
    data.orgTree.add(null, orgItemRoot.id, orgItemRoot);
    attachedFamilies = {};
    for (index = 0, len = sortedFamilies.length; index < len; index += 1) {
      family = families[sortedFamilies[index]];
      rootItems = {};
      bestRootItem = orgItemRoot;
      bestReference = 0;
      links = family.links.concat(family.backLinks);
      for (index2 = 0; index2 < links.length; index2 += 1) {
        link = links[index2];
        toItem = data.orgTree.node(link.toItem);
        fromItem = data.orgTree.node(link.fromItem);
        if (attachedFamilies[toItem.familyId] === true) {
          familyRootItem = family.items[0];
          rootItem = toItem;
          if (rootItem.level >= familyRootItem.level) {
            data.orgTree.loopParents(this, rootItem.id, function(nodeid, node) {
              rootItem = node;
              if (node.level < familyRootItem.level) {
                return true;
              }
            });
          }
          if (rootItems.hasOwnProperty(rootItem.id)) {
            rootItems[rootItem.id] += 1;
          } else {
            rootItems[rootItem.id] = 1;
          }
          if (bestReference < rootItems[rootItem.id]) {
            bestRootItem = rootItem;
            bestReference = rootItems[rootItem.id];
          }
        }
      }
      this.attachFamilyToOrgChart(data, bestRootItem, family);
      attachedFamilies[family.id] = true;
    }
    extraGravities = this.getExtraGravity(data);
    grandChildren = this.getGrandChildren(data);
    this.balanceOrgTree(data.orgTree, extraGravities, grandChildren, params.itemsPositions, params.itemsGroups);
  }
};
FamilyBalance.prototype.getGrandChildren = function(data) {
  var result = {};
  data.orgTree.loopPostOrder(this, function(itemId, orgItem, parentId, parent) {
    var level;
    data.minimumLevel = data.minimumLevel != null ? Math.min(data.minimumLevel, orgItem.level) : orgItem.level;
    data.maximumLevel = data.maximumLevel != null ? Math.max(data.maximumLevel, orgItem.level) : orgItem.level;
    if (parentId != null) {
      if (!result[parentId]) {
        result[parentId] = {};
      }
      level = orgItem.level - 1;
      if (!result[parentId][level]) {
        result[parentId][level] = 1;
      } else {
        result[parentId][level] += 1;
      }
      if (result[itemId] != null) {
        for (level in result[itemId]) {
          if (result[itemId].hasOwnProperty(level)) {
            if (!result[parentId][level]) {
              result[parentId][level] = result[itemId][level];
            } else {
              result[parentId][level] += result[itemId][level];
            }
          }
        }
      }
    }
  });
  return result;
};
FamilyBalance.prototype.balanceOrgTree = function(orgTree, extraGravities, grandChildren, itemsPositions, itemsGroups) {
  var index2, len2, index3, len3, extraGravity, childExtraGravities, sortedChildren, subChildren, subOrgItem, leftId = "__left__", rightId = "__right__", levelExtraGravities, sequence;
  orgTree.loopLevels(this, function(parentOrgItemId, parentOrgItem, levelid) {
    var graph = Graph(), graphGravities = {}, firstOrgItem = null, toItemId;
    sortedChildren = [];
    orgTree.loopChildren(this, parentOrgItem.id, function(childOrgItemId, childOrgItem, index) {
      var levelKey;
      if (firstOrgItem == null) {
        firstOrgItem = childOrgItem;
      }
      graphGravities[childOrgItem.id] = {};
      if (extraGravities.hasOwnProperty(childOrgItem.id)) {
        childExtraGravities = extraGravities[childOrgItem.id];
        for (levelKey in childExtraGravities) {
          if (childExtraGravities.hasOwnProperty(levelKey)) {
            levelExtraGravities = childExtraGravities[levelKey];
            graphGravities[childOrgItem.id][levelKey] = {};
            for (index2 = 0, len2 = levelExtraGravities.length; index2 < len2; index2 += 1) {
              extraGravity = levelExtraGravities[index2];
              if (extraGravity.commonParent == parentOrgItem.id) {
                toItemId = extraGravity.toParent;
              } else {
                if (orgTree.node(extraGravity.fromParent).childIndex < orgTree.node(extraGravity.toParent).childIndex) {
                  toItemId = rightId;
                } else {
                  toItemId = leftId;
                }
              }
              if (childOrgItem.id != toItemId) {
                graph.addEdge(childOrgItem.id, toItemId, { weight: 0 });
                graph.edge(childOrgItem.id, toItemId).weight += 1;
                if (graphGravities[childOrgItem.id][levelKey][toItemId] == null) {
                  graphGravities[childOrgItem.id][levelKey][toItemId] = 0;
                }
                graphGravities[childOrgItem.id][levelKey][toItemId] += 1;
              }
            }
          }
        }
      }
      if (index > 0) {
        graph.addEdge(childOrgItem.id, firstOrgItem.id, { weight: 0 });
      }
    });
    if (firstOrgItem != null) {
      sequence = [];
      graph.getTotalWeightGrowthSequence(
        this,
        function(a) {
          return a.weight;
        },
        function(a) {
          sequence.push(a);
        }
      );
      if (sequence.length === 0) {
        sequence = [firstOrgItem.id];
      }
      subChildren = this.balanceItems(sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups);
      for (index3 = 0, len3 = subChildren.length; index3 < len3; index3 += 1) {
        subOrgItem = orgTree.node(subChildren[index3]);
        subOrgItem.childIndex = index3;
        sortedChildren.push(subOrgItem.id);
      }
    }
    orgTree.arrangeChildren(parentOrgItem.id, sortedChildren);
  });
};
FamilyBalance.prototype.balanceItems = function(sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups) {
  var result = [], index, slots = LinkedHashItems(), counter = 0, positions = {}, startSlotKey, endSlotKey, key, slot, items = {}, itemid, itemsToAdd, bestSlotKey, bestSlot, bestSlotValue, bestSlotDistance, bestSlotBalance, bestSlotCrossings, slotValue, slotDistance, slotBalance, slotCrossings, itemGrandChildren, itemSlot, itemSlotKey, level, levelGravities, toItemId, toItemSlot, userItemPosition, position, itemGroup, groupPositions, toItemSlotKey;
  itemsToAdd = [leftId, null, rightId];
  for (index = 0; index < itemsToAdd.length; index += 1) {
    itemid = itemsToAdd[index];
    key = counter++;
    slot = new Slot(itemid);
    slot.position = index;
    slots.add(key, slot);
    if (itemid !== null) {
      items[itemid] = key;
    }
  }
  for (index = 0; index < sequence.length; index += 1) {
    itemid = sequence[index];
    if (itemid != leftId && itemid != rightId) {
      bestSlotKey = null;
      bestSlot = null;
      bestSlotValue = null;
      bestSlotDistance = null;
      bestSlotBalance = null;
      bestSlotCrossings = null;
      startSlotKey = null;
      endSlotKey = null;
      if (itemsGroups.hasOwnProperty(itemid)) {
        itemGroup = itemsGroups[itemid];
        if (positions.hasOwnProperty(itemGroup)) {
          userItemPosition = itemsPositions[itemid];
          groupPositions = positions[itemGroup];
          startSlotKey = groupPositions.previousContext(userItemPosition);
          endSlotKey = groupPositions.nextContext(userItemPosition);
        }
      }
      slots.iterate(function(slot2, slotKey) {
        var level2, toItemId2, levelGravities2, toItemSlot2;
        if (slot2.itemId == null) {
          itemGrandChildren = grandChildren[itemid];
          slotValue = 0;
          slotDistance = 0;
          slotBalance = 0;
          slotCrossings = 0;
          for (level2 in slot2.crossings) {
            if (slot2.crossings.hasOwnProperty(level2)) {
              if (itemGrandChildren && itemGrandChildren[level2] != null) {
                slotValue += slot2.crossings[level2] * itemGrandChildren[level2];
              }
              slotCrossings += slot2.crossings[level2];
            }
          }
          for (level2 in graphGravities[itemid]) {
            if (graphGravities[itemid].hasOwnProperty(level2)) {
              levelGravities2 = graphGravities[itemid][level2];
              for (toItemId2 in levelGravities2) {
                if (levelGravities2.hasOwnProperty(toItemId2)) {
                  if (items.hasOwnProperty(toItemId2)) {
                    toItemSlot2 = slots.item(items[toItemId2]);
                    if (toItemSlot2 != null) {
                      if (toItemSlot2.position < slot2.position) {
                        slotValue += (slot2.left[level2] || 0) - (toItemSlot2.left[level2] || 0);
                        slotBalance += Math.abs(toItemSlot2.balance + 1);
                      } else {
                        slotValue += (slot2.right[level2] || 0) - (toItemSlot2.right[level2] || 0);
                        slotBalance += Math.abs(toItemSlot2.balance - 1);
                      }
                      slotDistance += Math.abs(toItemSlot2.position - slot2.position);
                    }
                  }
                }
              }
            }
          }
          if (bestSlotValue == null || bestSlotValue > slotValue || bestSlotValue == slotValue && (bestSlotDistance > slotDistance || bestSlotDistance == slotDistance && (bestSlotBalance > slotBalance || bestSlotBalance == slotBalance && bestSlotCrossings > slotCrossings))) {
            bestSlotKey = slotKey;
            bestSlotValue = slotValue;
            bestSlot = slot2;
            bestSlotDistance = slotDistance;
            bestSlotBalance = slotBalance;
            bestSlotCrossings = slotCrossings;
          }
        }
      }, startSlotKey, endSlotKey);
      slots.insertBefore(bestSlotKey, counter++, bestSlot.clone(null));
      items[itemid] = counter;
      itemSlotKey = counter;
      itemSlot = bestSlot.clone(itemid);
      if (itemsPositions.hasOwnProperty(itemid)) {
        itemGroup = itemsGroups[itemid];
        if (!positions.hasOwnProperty(itemGroup)) {
          positions[itemGroup] = SortedList();
        }
        groupPositions = positions[itemGroup];
        groupPositions.add(itemsPositions[itemid], counter);
      }
      slots.insertBefore(bestSlotKey, counter++, itemSlot);
      itemSlot.position = 0;
      position = 0;
      slots.iterate(function(slot2, slotKey) {
        var level2, itemGrandChildren2;
        if (slotKey != itemSlotKey) {
          itemGrandChildren2 = grandChildren[itemid];
          for (level2 in itemGrandChildren2) {
            if (itemGrandChildren2.hasOwnProperty(level2)) {
              if (!slot2.left[level2]) {
                slot2.left[level2] = itemGrandChildren2[level2];
              } else {
                slot2.left[level2] += itemGrandChildren2[level2];
              }
            }
          }
          position += 1;
          slot2.position = position;
        }
      }, itemSlotKey);
      position = 0;
      slots.iterateBack(function(slot2, slotKey) {
        var level2, itemGrandChildren2;
        if (slotKey != itemSlotKey) {
          itemGrandChildren2 = grandChildren[itemid];
          for (level2 in grandChildren[itemid]) {
            if (grandChildren[itemid].hasOwnProperty(level2)) {
              if (!slot2.right[level2]) {
                slot2.right[level2] = itemGrandChildren2[level2];
              } else {
                slot2.right[level2] += itemGrandChildren2[level2];
              }
            }
          }
          position -= 1;
          slot2.position = position;
        }
      }, itemSlotKey);
      for (level in graphGravities[itemid]) {
        if (graphGravities[itemid].hasOwnProperty(level)) {
          levelGravities = graphGravities[itemid][level];
          for (toItemId in levelGravities) {
            if (levelGravities.hasOwnProperty(toItemId)) {
              if (items.hasOwnProperty(toItemId)) {
                toItemSlotKey = items[toItemId];
                toItemSlot = slots.item(toItemSlotKey);
                if (toItemSlot != null) {
                  if (toItemSlot.position < 0) {
                    toItemSlot.balance += 1;
                    itemSlot.balance -= 1;
                    slots.iterateBack(function(slot2, slotKey) {
                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {
                        if (!slot2.crossings[level]) {
                          slot2.crossings[level] = levelGravities[toItemId];
                        } else {
                          slot2.crossings[level] += levelGravities[toItemId];
                        }
                      }
                    }, itemSlotKey, toItemSlotKey);
                  } else {
                    toItemSlot.balance -= 1;
                    itemSlot.balance += 1;
                    slots.iterate(function(slot2, slotKey) {
                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {
                        if (!slot2.crossings[level]) {
                          slot2.crossings[level] = levelGravities[toItemId];
                        } else {
                          slot2.crossings[level] += levelGravities[toItemId];
                        }
                      }
                    }, itemSlotKey, toItemSlotKey);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  slots.iterate(function(slot2) {
    var itemId = slot2.itemId;
    if (itemId != null && itemId != leftId && itemId != rightId) {
      result.push(itemId);
    }
  });
  return result;
};
FamilyBalance.prototype.ExtraGravity = function(level) {
  this.commonParent = null;
  this.fromParent = null;
  this.toParent = null;
  this.level = level;
};
FamilyBalance.prototype.getExtraGravity = function(data) {
  var orgItemId, orgItem, result = {}, index, len, extraPartners, extraPartner;
  for (orgItemId in data.orgPartners) {
    if (data.orgPartners.hasOwnProperty(orgItemId)) {
      orgItem = data.orgTree.node(orgItemId);
      extraPartners = data.orgPartners[orgItemId];
      for (index = 0, len = extraPartners.length; index < len; index += 1) {
        extraPartner = data.orgTree.node(extraPartners[index]);
        this.addExtraGravitiesForConnection(data.orgTree, result, extraPartner, orgItem);
      }
    }
  }
  return result;
};
FamilyBalance.prototype.addExtraGravitiesForConnection = function(orgTree, extraGravities, fromItem, toItem) {
  var extraGravityFrom = new this.ExtraGravity(fromItem.level), extraGravityTo = new this.ExtraGravity(toItem.level);
  orgTree.zipUp(this, fromItem.id, toItem.id, function(fromItemId, parentFromItemId, toItemId, parentToItemId) {
    this.addExtraGravityForItem(extraGravities, fromItemId, extraGravityFrom);
    this.addExtraGravityForItem(extraGravities, toItemId, extraGravityTo);
    if (parentFromItemId == parentToItemId) {
      extraGravityFrom.commonParent = parentFromItemId;
      extraGravityFrom.fromParent = fromItemId;
      extraGravityFrom.toParent = toItemId;
      extraGravityTo.commonParent = parentFromItemId;
      extraGravityTo.fromParent = toItemId;
      extraGravityTo.toParent = fromItemId;
      return true;
    }
  });
};
FamilyBalance.prototype.addExtraGravityForItem = function(extraGravities, id, extraGravity) {
  if (!extraGravities.hasOwnProperty(id)) {
    extraGravities[id] = {};
  }
  if (extraGravities[id][extraGravity.level] == null) {
    extraGravities[id][extraGravity.level] = [];
  }
  extraGravities[id][extraGravity.level].push(extraGravity);
};
FamilyBalance.prototype.attachFamilyToOrgChart = function(data, parent, family) {
  var levelIndex, familyRoot = family.items[0], newOrgItem = null, rootItem = parent;
  for (levelIndex = parent.level + 1; levelIndex < familyRoot.level; levelIndex += 1) {
    data.maximumId += 1;
    newOrgItem = new FamilyBalanceItem(data.maximumId, null, levelIndex);
    data.orgTree.add(rootItem.id, newOrgItem.id, newOrgItem);
    family.items.push(newOrgItem);
    rootItem = newOrgItem;
  }
  familyRoot.hideParentConnection = true;
  data.orgTree.adopt(rootItem.id, familyRoot.id, familyRoot);
};
FamilyBalance.prototype.extractOrgChart = function(grandParentId, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {
  var index, len, children = [], tempChildren, childItem, rootItem = null, newOrgItem, grandParent = logicalFamily.node(grandParentId);
  newOrgItem = new FamilyBalanceItem(grandParent.id, family.id, grandParent.level);
  orgTree.add(rootItem, newOrgItem.id, newOrgItem);
  family.items.push(newOrgItem);
  famItemsExtracted[grandParent.id] = grandParent;
  grandParent.familyId = family.id;
  children = this.extractChildren(grandParent, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family);
  while (children.length > 0) {
    tempChildren = [];
    for (index = 0, len = children.length; index < len; index += 1) {
      childItem = children[index];
      tempChildren = tempChildren.concat(this.extractChildren(childItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family));
    }
    children = tempChildren;
  }
};
FamilyBalance.prototype.extractChildren = function(parentItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {
  var result = [], firstChild = null, partnerItem = null, newOrgItem;
  if (logicalFamily.countChildren(parentItem.id) == 1) {
    firstChild = logicalFamily.firstChild(parentItem.id);
  }
  if (itemByChildrenKey[firstChild] != null) {
    partnerItem = itemByChildrenKey[firstChild];
    if (orgPartners[partnerItem.id] == null) {
      orgPartners[partnerItem.id] = [];
    }
    orgPartners[partnerItem.id].push(parentItem.id);
    family.links.push(new this.FamLink(parentItem.id, firstChild));
  } else {
    if (firstChild != null) {
      if (primaryParentsPath.hasOwnProperty(firstChild)) {
        var realParent = primaryParentsPath[firstChild];
        if (realParent != parentItem.id) {
          if (orgPartners[realParent] == null) {
            orgPartners[realParent] = [];
          }
          orgPartners[realParent].push(parentItem.id);
          family.links.push(new this.FamLink(parentItem.id, firstChild));
          return result;
        }
      }
      itemByChildrenKey[firstChild] = parentItem;
    }
    logicalFamily.loopChildren(this, parentItem.id, function(childid, childItem, levelIndex) {
      if (famItemsExtracted[childItem.id]) {
        throw "Many to many relations should not exist at this stage";
      }
      result.push(childItem);
      newOrgItem = new FamilyBalanceItem(childItem.id, family.id, childItem.level);
      orgTree.add(parentItem.id, newOrgItem.id, newOrgItem);
      family.items.push(newOrgItem);
      famItemsExtracted[childItem.id] = true;
      childItem.familyId = family.id;
      return logicalFamily.SKIP;
    });
  }
  return result;
};
FamilyBalance.prototype.recalcLevelsDepth = function(bundles, connectorStacks, treeLevels, logicalFamily) {
  var index2, len2, index3, len3, itemPosition, bundle, bundlesToStack, processed = {}, startIndex, endIndex, stackSegments;
  treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
    var stacksSizes = new TreeLevelConnectorStackSize();
    connectorStacks[levelIndex] = stacksSizes;
    bundlesToStack = [];
    treeLevels.loopLevelItems(this, levelIndex, function(itemid, familyItem, position) {
      var fromItems = [], toItems = [], dotId = null;
      if (!processed.hasOwnProperty(itemid)) {
        processed[itemid] = true;
        if (!familyItem.hideChildrenConnection) {
          fromItems.push(itemid);
        } else {
          dotId = itemid;
        }
        logicalFamily.loopChildren(this, itemid, function(childid, child, index) {
          logicalFamily.loopParents(this, childid, function(parentid, parentItem) {
            if (!processed.hasOwnProperty(parentid)) {
              processed[parentid] = true;
              if (!parentItem.hideChildrenConnection) {
                fromItems.push(parentid);
              } else {
                dotId = parentid;
              }
            }
            return logicalFamily.SKIP;
          });
          if (!child.hideParentConnection) {
            toItems.push(childid);
          } else {
            dotId = childid;
          }
          return logicalFamily.SKIP;
        });
        if (fromItems.length > 1 || toItems.length > 0) {
          bundle = new VerticalConnectorBundle(fromItems, toItems, dotId);
          bundles.push(bundle);
          if (fromItems.length > 1) {
            bundlesToStack.push(bundle);
          }
        }
      }
    });
    if (bundlesToStack.length > 0) {
      stackSegments = Pile();
      for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {
        bundle = bundlesToStack[index2];
        startIndex = null;
        endIndex = null;
        for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {
          itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);
          startIndex = startIndex != null ? Math.min(startIndex, itemPosition) : itemPosition;
          endIndex = endIndex != null ? Math.max(endIndex, itemPosition) : itemPosition;
        }
        stackSegments.add(startIndex, endIndex, bundle);
      }
      stacksSizes.parentsStackSize = stackSegments.resolve(this, function(from, to, bundle2, offset, stackSize) {
        bundle2.fromOffset = offset + 1;
        bundle2.fromStackSize = stackSize;
      });
    }
  });
};

// node_modules/basicprimitives/src/tasks/transformations/familyTransformations/UserDefinedPrimaryParents.js
function UserDefinedPrimaryParents() {
}
UserDefinedPrimaryParents.prototype.getUserDefinedPrimaryParents = function(items, family) {
  var result = {}, index, len;
  var primaryParents = {};
  for (index = 0, len = items.length; index < len; index += 1) {
    var item = items[index];
    if (item.primaryParent != null) {
      primaryParents[item.id] = item.primaryParent;
    }
  }
  for (var nodeid in primaryParents) {
    var primaryParent = primaryParents[nodeid];
    var trace = {};
    var nodes = [nodeid];
    while (nodes.length > 0) {
      var tempNodes = [];
      for (index = 0, len = nodes.length; index < len; index += 1) {
        nodeid = nodes[index];
        family.loopParents(this, nodeid, function(parentid, parent) {
          trace[parentid] = nodeid;
          if (parentid == primaryParent) {
            while (trace[parentid] != null) {
              result[trace[parentid]] = parentid;
              parentid = trace[parentid];
            }
            tempNodes = [];
            return family.BREAK;
          }
          if (parent.isVisible == false) {
            tempNodes.push(parentid);
          }
          return family.SKIP;
        });
      }
      nodes = tempNodes;
    }
  }
  return result;
};

// node_modules/basicprimitives/src/tasks/transformations/OrderFamilyNodesTask.js
function OrderFamilyNodesTask(orderFamilyNodesOptionTask, userDefinedNodesOrderTask, normalizeLogicalFamilyTask) {
  var _data = {
    maximumId: null,
    /* maximum of OrgItem.id */
    logicalFamily: null,
    treeLevels: null,
    /* TreeLevels */
    bundles: null,
    /* array of BaseConnectorBundle objects */
    connectorStacks: null
    /* array of TreeLevelConnectorStackSize objects, it keeps total number of horizontal connectors lines between parents and children stack on top of each other */
  }, _familyBalance = new FamilyBalance(), _userDefinedPrimaryParents = new UserDefinedPrimaryParents(), _nullTreeLevelConnectorStackSize = new TreeLevelConnectorStackSize();
  function process(debug) {
    var logicalFamily = normalizeLogicalFamilyTask.getLogicalFamily(), maximumId = normalizeLogicalFamilyTask.getMaximumId(), orderFamilyNodesOptions = orderFamilyNodesOptionTask.getOptions();
    var balanceParams = {
      logicalFamily,
      maximumId,
      itemsPositions: userDefinedNodesOrderTask.getPositions(),
      itemsGroups: userDefinedNodesOrderTask.getGroups(),
      primaryParents: _userDefinedPrimaryParents.getUserDefinedPrimaryParents(orderFamilyNodesOptions.items, logicalFamily)
    };
    var { maximumId, treeLevels, bundles, connectorStacks } = _familyBalance.balance(balanceParams);
    _data.maximumId = maximumId;
    _data.treeLevels = treeLevels;
    _data.bundles = bundles;
    _data.connectorStacks = connectorStacks;
    _data.logicalFamily = logicalFamily;
    return true;
  }
  function getLogicalFamily() {
    return _data.logicalFamily;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  function getTreeLevels() {
    return _data.treeLevels;
  }
  function getBundles() {
    return _data.bundles;
  }
  function getConnectorsStacksSizes(levelid) {
    return _data.connectorStacks[levelid] || _nullTreeLevelConnectorStackSize;
  }
  return {
    process,
    getLogicalFamily,
    getMaximumId,
    getTreeLevels,
    getBundles,
    getConnectorsStacksSizes
  };
}

// node_modules/basicprimitives/src/tasks/templates/LabelAnnotationTemplateParamsTask.js
function LabelAnnotationTemplateParamsTask(itemsSizesOptionTask, labelAnnotationTemplateOptionTask, readTemplatesTask) {
  var _data = {
    items: {}
    // TemplateParams
  };
  function process() {
    var itemsSizesOptions = itemsSizesOptionTask.getOptions(), items = labelAnnotationTemplateOptionTask.getAnnotations(), index, len;
    _data.items = {};
    for (index = 0, len = items.length; index < len; index += 1) {
      var annotation = items[index], templateParams = new TemplateParams(), template = readTemplatesTask.getTemplate(annotation.templateName, itemsSizesOptions.defaultLabelAnnotationTemplate, readTemplatesTask.DefaultWidgetLabelAnnotationTemplateName);
      templateParams.template = template;
      _data.items[annotation.id] = templateParams;
    }
    return true;
  }
  function getTemplateParams(itemId) {
    return _data.items[itemId];
  }
  return {
    process,
    getTemplateParams
  };
}

// node_modules/basicprimitives/src/tasks/templates/CombinedTemplateParamsTask.js
function CombinedTemplateParamsTask(itemTemplateParamsTask, labelAnnotationTemplateParamsTask) {
  function process() {
    return true;
  }
  function getTemplateParams(itemId) {
    return itemTemplateParamsTask.getTemplateParams(itemId) || labelAnnotationTemplateParamsTask.getTemplateParams(itemId);
  }
  return {
    process,
    getTemplateParams
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/FamCursorNeighboursTask.js
function FamCursorNeighboursTask(cursorItemTask, neighboursSelectionModeOptionTask, navigationFamilyTask, activeItemsTask) {
  var _data = {
    items: []
  }, _hash = {};
  var _dataTemplate = new ArrayReader(
    new ValueReader(["string", "number"], true),
    true
  );
  function process() {
    var context = {
      isChanged: false,
      hash: _hash
    }, cursorTreeItemId = cursorItemTask.getCursorTreeItem(), navigationFamily = navigationFamilyTask.getLogicalFamily(), neighboursSelectionMode = neighboursSelectionModeOptionTask.getNeighboursSelectionMode(), activeItems = activeItemsTask.getActiveItems();
    _data.items = _dataTemplate.read(_data.items, getCursorNeighbours(cursorTreeItemId, neighboursSelectionMode, navigationFamily, activeItems), "items", context);
    return context.isChanged;
  }
  function getCursorNeighbours(cursorTreeItemId, neighboursSelectionMode, navigationFamily, activeItems) {
    var result = [], processed = {};
    if (cursorTreeItemId !== null) {
      switch (neighboursSelectionMode) {
        case NeighboursSelectionMode.ParentsAndChildren:
          navigationFamily.loopParents(this, cursorTreeItemId, function(itemid, item) {
            if (item.isVisible && !processed.hasOwnProperty(itemid)) {
              processed[itemid] = true;
              result.push(itemid);
            }
            if (activeItems.hasOwnProperty(itemid)) {
              return navigationFamily.SKIP;
            }
          });
          navigationFamily.loopChildren(this, cursorTreeItemId, function(itemid, item) {
            if (item.isVisible && !processed.hasOwnProperty(itemid)) {
              processed[itemid] = true;
              result.push(itemid);
            }
            if (activeItems.hasOwnProperty(itemid)) {
              return navigationFamily.SKIP;
            }
          });
          break;
        case NeighboursSelectionMode.ParentsChildrenSiblingsAndSpouses:
          navigationFamily.loopNeighbours(this, cursorTreeItemId, function(itemid, item) {
            if (item.isVisible && !processed.hasOwnProperty(itemid)) {
              processed[itemid] = true;
              result.push(itemid);
            }
            if (activeItems.hasOwnProperty(itemid)) {
              return true;
            }
          });
          break;
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/selection/FamSelectionPathItemsTask.js
function FamSelectionPathItemsTask(navigationFamilyTask, cursorItemTask, selectedItemsTask, cursorSelectionPathModeOptionTask) {
  var _data = {
    items: []
  };
  function process() {
    var selectionPathMode = cursorSelectionPathModeOptionTask.getSelectionPathMode(), navigationFamily = navigationFamilyTask.getLogicalFamily(), cursorTreeItemId = cursorItemTask.getCursorTreeItem(), selectedItems = selectedItemsTask.getItems().slice(0);
    selectedItems.push(cursorTreeItemId);
    _data.items = getSelectionPathItems(selectedItems, navigationFamily, selectionPathMode);
    return true;
  }
  function getSelectionPathItems(selectedItems, navigationFamily, selectionPathMode) {
    var result = [], processed = {}, selectedItem, index, len;
    for (index = 0, len = selectedItems.length; index < len; index += 1) {
      selectedItem = selectedItems[index];
      switch (selectionPathMode) {
        case SelectionPathMode.None:
          break;
        case SelectionPathMode.FullStack:
          navigationFamily.loopParents(this, selectedItem, function(parentItemId, parentItem) {
            if (processed[parentItemId] != null) {
              return navigationFamily.SKIP;
            }
            if (parentItem.isVisible) {
              result.push(parentItemId);
            }
            processed[parentItemId] = true;
          });
          break;
      }
    }
    return result;
  }
  function getItems() {
    return _data.items;
  }
  return {
    process,
    getItems
  };
}

// node_modules/basicprimitives/src/tasks/transformations/layouts/FamilyLayout.js
function ChildLayoutPosition2(offset, leftPadding, rightPadding) {
  this.offset = offset;
  this.leftPadding = leftPadding;
  this.rightPadding = rightPadding;
}
function FamilyLayout(logicalFamily, treeLevels, getConnectorsStacksSizes) {
  this.logicalFamily = logicalFamily;
  this.treeLevels = treeLevels;
  this.getConnectorsStacksSizes = getConnectorsStacksSizes;
  this.treeLevelsPositions = [];
  this.childLayoutsPositions = {};
}
FamilyLayout.prototype.loop = function(thisArg, onItem) {
  if (onItem != null) {
    var zeroBasedLevelIndex = 0;
    this.treeLevels.loopLevels(this, function(levelIndex) {
      this.treeLevels.loopLevelItems(this, levelIndex, function(treeItemId, treeItem) {
        onItem.call(thisArg, treeItem, zeroBasedLevelIndex);
      });
      zeroBasedLevelIndex += 1;
    });
  }
};
FamilyLayout.prototype.measure = function(levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {
  this.treeLevelsPositions = [];
  this.treeLevels.loopLevels(this, function(index, levelContext) {
    var treeLevelPosition = new TreeLevelPosition();
    this.treeLevelsPositions.push(treeLevelPosition);
  });
  this.setOffsets(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, this.logicalFamily, options.intervals, options.padding);
  this.setLevelsDepth(this.treeLevels, treeItemsPositions, this.treeLevelsPositions, options.verticalAlignment);
  this.shiftLevels(this.treeLevelsPositions, options.padding.top, options.shifts, options.arrowsDirection, options.linesWidth, this.getConnectorsStacksSizes);
  var treeItemPosition = new TreeItemPosition();
  treeItemPosition.actualVisibility = Visibility.Normal;
  treeItemPosition.actualSize = this.getLayoutSize(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, options.padding);
  return treeItemPosition;
};
FamilyLayout.prototype.getLayoutSize = function(treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, padding) {
  return new Rect(0, 0, Math.round(this.getLayoutWidth(treeLevels, treeItemsPositions, childLayoutsPositions, padding)), Math.round(this.getLayoutHeight(treeLevelsPositions, padding)));
};
FamilyLayout.prototype.getLayoutWidth = function(treeLevels, treeItemsPositions, childLayoutsPositions, padding) {
  var result = 0;
  treeLevels.loopLevels(this, function(levelIndex, level) {
    var levelLength = treeLevels.getLevelLength(levelIndex);
    if (levelLength > 0) {
      var itemId = treeLevels.getItemAtPosition(levelIndex, levelLength - 1), treeItemPosition = treeItemsPositions[itemId], childLayoutPosition = childLayoutsPositions[itemId];
      result = Math.max(result, childLayoutPosition.offset + treeItemPosition.actualSize.width + padding.right);
    }
  });
  return result;
};
FamilyLayout.prototype.getLayoutHeight = function(treeLevelsPositions, padding) {
  var len = treeLevelsPositions.length, treeLevel = treeLevelsPositions[len - 1];
  return treeLevel.getNodesBottom() + padding.bottom;
};
FamilyLayout.prototype.setLevelsDepth = function(treeLevels, treeItemsPositions, treeLevelsPositions, verticalAlignment) {
  var minimalDepth, dotsDepth;
  treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
    var treeLevelPosition = treeLevelsPositions[levelIndex];
    treeLevelPosition.shift = 0;
    treeLevelPosition.depth = 0;
    treeLevelPosition.actualVisibility = Visibility.Invisible;
    minimalDepth = null;
    dotsDepth = null;
    treeLevels.loopLevelItems(this, levelIndex, function(itemid, treeItem, position) {
      var treeItemPosition = treeItemsPositions[itemid];
      treeLevelPosition.depth = Math.max(treeLevelPosition.depth, treeItemPosition.actualSize.height);
      switch (treeItemPosition.actualVisibility) {
        case Visibility.Dot:
        case Visibility.Line:
        case Visibility.Invisible:
          dotsDepth = !dotsDepth ? treeItemPosition.actualSize.height : Math.min(dotsDepth, treeItemPosition.actualSize.height);
          break;
        default:
          minimalDepth = !minimalDepth ? treeItemPosition.actualSize.height : Math.min(minimalDepth, treeItemPosition.actualSize.height);
          break;
      }
      treeLevelPosition.actualVisibility = Math.min(treeLevelPosition.actualVisibility, treeItemPosition.actualVisibility);
    });
    if (minimalDepth == null) {
      minimalDepth = treeLevelPosition.depth;
    }
    if (dotsDepth != null && dotsDepth > minimalDepth) {
      minimalDepth = dotsDepth;
    }
    switch (verticalAlignment) {
      case VerticalAlignmentType.Top:
        treeLevelPosition.horizontalConnectorsDepth = minimalDepth / 2;
        break;
      case VerticalAlignmentType.Middle:
        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth / 2;
        break;
      case VerticalAlignmentType.Bottom:
        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth - minimalDepth / 2;
        break;
    }
  });
};
FamilyLayout.prototype.shiftLevels = function(treeLevelsPositions, shift, shifts, arrowsDirection, linesWidth, getConnectorsStacksSizes) {
  var index, len, treeLevelPosition, parentsStackSize, childrenSpace = 0, parentsSpace = 0, arrowTipLength = linesWidth * 8;
  switch (arrowsDirection) {
    case GroupByType.Parents:
      childrenSpace = arrowTipLength;
      parentsSpace = 0;
      break;
    case GroupByType.Children:
      childrenSpace = 0;
      parentsSpace = arrowTipLength;
      break;
  }
  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {
    treeLevelPosition = treeLevelsPositions[index];
    parentsStackSize = getConnectorsStacksSizes(index).parentsStackSize;
    shift += treeLevelPosition.setShift(shift, shifts[treeLevelPosition.actualVisibility], parentsSpace, childrenSpace, parentsStackSize);
  }
};
FamilyLayout.prototype.setOffsets = function(treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, logicalFamily, intervals, padding) {
  var index, len;
  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {
    treeLevelsPositions[index].currentOffset = 0;
  }
  var family = logicalFamily.getPlanarFamily(treeLevels);
  var familyAlignment = new FamilyAlignment(this, family, treeLevels, function(nodeId, node) {
    var treeItemPosition = treeItemsPositions[nodeId];
    var treeItemPadding = intervals[treeItemPosition.actualVisibility] / 2;
    childLayoutsPositions[nodeId] = new ChildLayoutPosition2(0, treeItemPadding, treeItemPadding);
    return treeItemPadding + treeItemPosition.actualSize.width + treeItemPadding;
  });
  var leftMargin = null;
  treeLevels.loopLevels(this, function(levelIndex, level) {
    var nodeId = treeLevels.getItemAtPosition(levelIndex, 0);
    if (nodeId != null) {
      var treeItemPosition = treeItemsPositions[nodeId];
      var nodeOffset = familyAlignment.getOffset(nodeId) - treeItemPosition.actualSize.width / 2;
      leftMargin = leftMargin === null ? nodeOffset : Math.min(leftMargin, nodeOffset);
    }
  });
  treeLevels.loopLevels(this, function(levelIndex, level) {
    treeLevels.loopLevelItems(this, levelIndex, function(nodeId, node, position) {
      var treeItemPosition = treeItemsPositions[nodeId];
      var nodeOffset = familyAlignment.getOffset(nodeId);
      childLayoutsPositions[nodeId].offset = nodeOffset - treeItemPosition.actualSize.width / 2 - leftMargin + padding.left;
    });
  });
};
FamilyLayout.prototype.arrange = function(thisArg, position, layoutDirection, treeItemsPositions, options, onItemPositioned) {
  var prevLevelPosition = null;
  if (onItemPositioned != null) {
    this.treeLevels.loopLevels(this, function(levelIndex, treeLevel) {
      var treeLevelPosition = this.treeLevelsPositions[levelIndex];
      this.treeLevels.loopLevelItems(this, levelIndex, function(itemId, treeItem, position2) {
        var treeItemPosition = treeItemsPositions[itemId];
        var childLayoutPosition = this.childLayoutsPositions[itemId];
        var result = this.getItemPosition(treeItemPosition.actualVisibility, childLayoutPosition.offset, treeItemPosition.actualSize, prevLevelPosition, treeLevelPosition, options.verticalAlignment);
        onItemPositioned.call(thisArg, itemId, __spreadValues(__spreadValues({}, treeItemPosition), result));
      });
      prevLevelPosition = treeLevelPosition;
    });
  }
};
FamilyLayout.prototype.getItemPosition = function(visibility, offset, size, prevLevel, level, verticalAlignment) {
  var itemShift = 0;
  switch (visibility) {
    case Visibility.Normal:
      switch (verticalAlignment) {
        case VerticalAlignmentType.Top:
          itemShift = 0;
          break;
        case VerticalAlignmentType.Middle:
          itemShift = (level.depth - size.height) / 2;
          break;
        case VerticalAlignmentType.Bottom:
          itemShift = level.depth - size.height;
          break;
      }
      break;
    case Visibility.Dot:
    case Visibility.Line:
    case Visibility.Invisible:
      itemShift = level.horizontalConnectorsDepth - size.height / 2;
      break;
  }
  return {
    actualPosition: new Rect(offset, level.shift + itemShift, size.width, size.height),
    horizontalConnectorsShift: level.shift + level.horizontalConnectorsDepth,
    topConnectorShift: prevLevel != null ? prevLevel.shift + prevLevel.connectorShift : null,
    topConnectorInterval: prevLevel != null ? prevLevel.levelSpace / 2 : null,
    bottomConnectorShift: level.shift + level.connectorShift,
    bottomConnectorInterval: level.levelSpace / 2
  };
};

// node_modules/basicprimitives/src/tasks/transformations/FamCreateLayoutsTreeTask.js
function FamCreateLayoutsTreeTask(orderFamilyNodesTask, extractNestedLayoutsTask) {
  var _data = {
    layoutsTree: {},
    maximumId: null
  };
  function process() {
    var logicalFamily = orderFamilyNodesTask.getLogicalFamily();
    var treeLevels = orderFamilyNodesTask.getTreeLevels();
    var maximumId = orderFamilyNodesTask.getMaximumId();
    var getConnectorsStacksSizes = orderFamilyNodesTask.getConnectorsStacksSizes;
    var layouts = extractNestedLayoutsTask.getLayouts();
    var rootLayout = new FamilyLayout(logicalFamily, treeLevels, getConnectorsStacksSizes);
    var layoutsTree = Tree();
    maximumId++;
    layoutsTree.add(null, maximumId, rootLayout);
    var levelLayouts = [{ id: maximumId, levelLayout: rootLayout }];
    while (levelLayouts.length > 0) {
      var nextLevelLayouts = [];
      for (var index = 0; index < levelLayouts.length; index += 1) {
        var { id, levelLayout } = levelLayouts[index];
        levelLayout.loop(this, function(treeItem) {
          var treeItemId = treeItem.id;
          var itemLayout = layouts[treeItemId];
          if (!itemLayout) {
            itemLayout = new ItemLayout(treeItem.isVisible ? Visibility.Auto : Visibility.Invisible);
          } else {
            nextLevelLayouts.push({ id: treeItemId, levelLayout: itemLayout });
          }
          layoutsTree.add(id, treeItemId, itemLayout);
        });
      }
      levelLayouts = nextLevelLayouts;
    }
    _data.layoutsTree = layoutsTree;
    _data.maximumId = maximumId;
    return true;
  }
  function getLayoutsTree() {
    return _data.layoutsTree;
  }
  function getMaximumId() {
    return _data.maximumId;
  }
  return {
    process,
    getLayoutsTree,
    getMaximumId
  };
}

// node_modules/basicprimitives/src/FamTaskManagerFactory.js
function FamTaskManagerFactory(getOptions, getGraphics, getLayout, setLayout, templates) {
  var tasks = new TaskManager();
  tasks.addDependency("options", getOptions);
  tasks.addDependency("graphics", getGraphics);
  tasks.addDependency("getLayout", getLayout);
  tasks.addDependency("setLayout", setLayout);
  tasks.addDependency("templates", templates);
  tasks.addDependency("defaultConfig", new FamConfig());
  tasks.addDependency("defaultItemConfig", new FamItemConfig());
  tasks.addDependency("defaultTemplateConfig", new TemplateConfig());
  tasks.addDependency("defaultPaletteItemConfig", new PaletteItemConfig());
  tasks.addDependency("defaultBackgroundAnnotationConfig", new BackgroundAnnotationConfig());
  tasks.addDependency("defaultConnectorAnnotationConfig", new ConnectorAnnotationConfig());
  tasks.addDependency("defaultHighlightPathAnnotationConfig", new HighlightPathAnnotationConfig());
  tasks.addDependency("defaultShapeAnnotationConfig", new ShapeAnnotationConfig());
  tasks.addDependency("defaultLabelAnnotationConfig", new LabelAnnotationConfig());
  tasks.addDependency("defaultLevelAnnotationConfig", new LevelAnnotationConfig());
  tasks.addDependency("showElbowDots", true);
  tasks.addDependency("null", null);
  tasks.addDependency("foreground", ZOrderType.Foreground);
  tasks.addDependency("background", ZOrderType.Background);
  tasks.addTask("OptionsTask", ["options"], OptionsTask, Colors.Black);
  tasks.addTask("CalloutOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], CalloutOptionTask, Colors.Navy);
  tasks.addTask("ConnectorsOptionTask", ["OptionsTask", "defaultConfig"], ConnectorsOptionTask, Colors.Navy);
  tasks.addTask("ItemsOptionTask", ["OptionsTask", "defaultItemConfig"], FamItemsOptionTask, Colors.Navy);
  tasks.addTask("ItemsContentOptionTask", ["OptionsTask", "defaultItemConfig"], ItemsContentOptionTask, Colors.Navy);
  tasks.addTask("ItemsSizesOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], ItemsSizesOptionTask, Colors.Navy);
  tasks.addTask("MinimumVisibleLevelsOptionTask", ["OptionsTask", "defaultConfig"], MinimumVisibleLevelsOptionTask, Colors.Navy);
  tasks.addTask("LabelsOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], LabelsOptionTask, Colors.Navy);
  tasks.addTask("TemplatesOptionTask", ["OptionsTask", "defaultConfig", "defaultTemplateConfig"], TemplatesOptionTask, Colors.Navy);
  tasks.addTask("OrientationOptionTask", ["OptionsTask", "defaultConfig"], OrientationOptionTask, Colors.Navy);
  tasks.addTask("VisualTreeOptionTask", ["OptionsTask", "defaultConfig"], FamVisualTreeOptionTask, Colors.Navy);
  tasks.addTask("MinimizedItemsOptionTask", ["OptionsTask"], MinimizedItemsOptionTask, Colors.Navy);
  tasks.addTask("HideGrandParentsConnectorsOptionTask", ["OptionsTask", "defaultConfig"], HideGrandParentsConnectorsOptionTask, Colors.Navy);
  tasks.addTask("NormalizeOptionTask", ["OptionsTask", "defaultConfig"], NormalizeOptionTask, Colors.Navy);
  tasks.addTask("ExtractNestedLayoutsOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], ExtractNestedLayoutsOptionTask, Colors.Navy);
  tasks.addTask("OrderFamilyNodesOptionTask", ["OptionsTask", "defaultConfig", "defaultItemConfig"], OrderFamilyNodesOptionTask, Colors.Navy);
  tasks.addTask("LinePaletteOptionTask", ["OptionsTask", "defaultPaletteItemConfig"], LinePaletteOptionTask, Colors.Navy);
  tasks.addTask("CursorItemOptionTask", ["OptionsTask", "defaultConfig"], CursorItemOptionTask, Colors.Navy);
  tasks.addTask("HighlightItemOptionTask", ["OptionsTask", "defaultConfig"], HighlightItemOptionTask, Colors.Navy);
  tasks.addTask("SelectedItemsOptionTask", ["OptionsTask"], SelectedItemsOptionTask, Colors.Navy);
  tasks.addTask("CursorSelectionPathModeOptionTask", ["OptionsTask", "defaultConfig"], CursorSelectionPathModeOptionTask, Colors.Navy);
  tasks.addTask("NeighboursSelectionModeOptionTask", ["OptionsTask", "defaultConfig"], NeighboursSelectionModeOptionTask, Colors.Navy);
  tasks.addTask("SplitAnnotationsOptionTask", ["OptionsTask"], SplitAnnotationsOptionTask, Colors.Cyan);
  tasks.addTask("ForegroundShapeAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultShapeAnnotationConfig", "foreground"], ShapeAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundShapeAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultShapeAnnotationConfig", "background"], ShapeAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ForegroundHighlightPathAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultHighlightPathAnnotationConfig", "foreground"], HighlightPathAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundHighlightPathAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultHighlightPathAnnotationConfig", "background"], HighlightPathAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ForegroundConnectorAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultConnectorAnnotationConfig", "foreground"], ConnectorAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundConnectorAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultConnectorAnnotationConfig", "background"], ConnectorAnnotationOptionTask, Colors.Navy);
  tasks.addTask("BackgroundAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultBackgroundAnnotationConfig"], BackgroundAnnotationOptionTask, Colors.Navy);
  tasks.addTask("LevelAnnotationOptionTask", ["SplitAnnotationsOptionTask", "defaultLevelAnnotationConfig"], LevelAnnotationOptionTask, Colors.Navy);
  tasks.addTask("ScaleOptionTask", ["OptionsTask", "defaultConfig"], ScaleOptionTask, Colors.Navy);
  tasks.addTask("FrameOptionTask", ["OptionsTask", "defaultConfig"], FrameOptionTask, Colors.Navy);
  tasks.addTask("LevelTitlePlacementOptionTask", ["OptionsTask", "defaultConfig"], LevelTitlePlacementOptionTask, Colors.Navy);
  tasks.addTask("LevelTitleTemplateOptionTask", ["OptionsTask", "defaultConfig"], LevelTitleTemplateOptionTask, Colors.Navy);
  tasks.addTask("UserDefinedNodesOrderTask", ["OrderFamilyNodesOptionTask", "defaultItemConfig"], UserDefinedNodesOrderTask, Colors.Red);
  tasks.addTask("LogicalFamilyTask", ["ItemsOptionTask"], LogicalFamilyTask, Colors.Cyan);
  tasks.addTask("LabelAnnotationOptionTask", ["SplitAnnotationsOptionTask", "LogicalFamilyTask", "defaultLabelAnnotationConfig"], LabelAnnotationOptionTask, Colors.Navy);
  tasks.addTask("LabelAnnotationTemplateOptionTask", ["LabelAnnotationOptionTask", "defaultLabelAnnotationConfig"], LabelAnnotationTemplateOptionTask, Colors.Navy);
  tasks.addTask("LabelAnnotationPlacementOptionTask", ["LabelAnnotationOptionTask", "defaultLabelAnnotationConfig"], LabelAnnotationPlacementOptionTask, Colors.Navy);
  tasks.addTask("CombinedContextsTask", ["ItemsContentOptionTask", "LabelAnnotationOptionTask"], CombinedContextsTask, Colors.Cyan);
  tasks.addTask("AddLabelAnnotationsTask", ["LabelAnnotationPlacementOptionTask", "LogicalFamilyTask"], AddLabelAnnotationsTask, Colors.Red);
  tasks.addTask("RemoveLoopsTask", ["AddLabelAnnotationsTask"], RemoveLoopsTask, Colors.Red);
  tasks.addTask("HideGrandParentsConnectorsTask", ["HideGrandParentsConnectorsOptionTask", "RemoveLoopsTask"], HideGrandParentsConnectorsTask, Colors.Red);
  tasks.addTask("BindFamilyConnectorsTask", ["HideGrandParentsConnectorsTask"], BindFamilyConnectorsTask, Colors.Red);
  tasks.addTask("ExtractNestedLayoutsTask", ["ExtractNestedLayoutsOptionTask", "BindFamilyConnectorsTask"], ExtractNestedLayoutsTask, Colors.Red);
  tasks.addTask("NormalizeLogicalFamilyTask", ["NormalizeOptionTask", "ExtractNestedLayoutsTask"], NormalizeLogicalFamilyTask, Colors.Red);
  tasks.addTask("OrderFamilyNodesTask", ["OrderFamilyNodesOptionTask", "UserDefinedNodesOrderTask", "NormalizeLogicalFamilyTask"], OrderFamilyNodesTask, Colors.Red);
  tasks.addTask("FamCreateLayoutsTreeTask", ["OrderFamilyNodesTask", "ExtractNestedLayoutsTask"], FamCreateLayoutsTreeTask, Colors.Red);
  tasks.addTask("ReadTemplatesTask", ["TemplatesOptionTask", "templates"], ReadTemplatesTask, Colors.Cyan);
  tasks.addTask("ActiveItemsTask", ["ItemsSizesOptionTask", "ReadTemplatesTask"], ActiveItemsTask, Colors.Cyan);
  tasks.addTask("ItemTemplateParamsTask", ["ItemsSizesOptionTask", "CursorItemOptionTask", "ReadTemplatesTask"], ItemTemplateParamsTask, Colors.Cyan);
  tasks.addTask("LabelAnnotationTemplateParamsTask", ["ItemsSizesOptionTask", "LabelAnnotationTemplateOptionTask", "ReadTemplatesTask"], LabelAnnotationTemplateParamsTask, Colors.Cyan);
  tasks.addTask("CombinedTemplateParamsTask", ["ItemTemplateParamsTask", "LabelAnnotationTemplateParamsTask"], CombinedTemplateParamsTask, Colors.Cyan);
  tasks.addTask("GroupTitleTemplateTask", ["TemplatesOptionTask", "templates"], GroupTitleTemplateTask, Colors.Cyan);
  tasks.addTask("CheckBoxTemplateTask", ["ItemsSizesOptionTask", "templates"], CheckBoxTemplateTask, Colors.Cyan);
  tasks.addTask("ButtonsTemplateTask", ["ItemsSizesOptionTask", "templates"], ButtonsTemplateTask, Colors.Cyan);
  tasks.addTask("AnnotationLabelTemplateTask", ["ItemsOptionTask", "templates"], AnnotationLabelTemplateTask, Colors.Cyan);
  tasks.addTask("LevelAnnotationTemplateTask", ["OrientationOptionTask", "LevelTitleTemplateOptionTask", "templates"], LevelAnnotationTemplateTask, Colors.Cyan);
  tasks.addTask("ConnectionsGraphTask", ["graphics", "CreateTransformTask", "ConnectorsOptionTask", "OrderFamilyNodesTask", "ExtractNestedLayoutsTask", "AlignDiagramTask", "RemoveLoopsTask"], ConnectionsGraphTask, Colors.Cyan);
  tasks.addTask("HighlightItemTask", ["HighlightItemOptionTask", "ActiveItemsTask"], HighlightItemTask, Colors.Cyan);
  tasks.addTask("CursorItemTask", ["CursorItemOptionTask", "ActiveItemsTask"], CursorItemTask, Colors.Cyan);
  tasks.addTask("CursorNeighboursTask", ["CursorItemTask", "NeighboursSelectionModeOptionTask", "AddLabelAnnotationsTask", "ActiveItemsTask"], FamCursorNeighboursTask, Colors.Cyan);
  tasks.addTask("SelectedItemsTask", ["SelectedItemsOptionTask", "ItemsOptionTask"], SelectedItemsTask, Colors.Cyan);
  tasks.addTask("SelectionPathItemsTask", ["RemoveLoopsTask", "CursorItemTask", "SelectedItemsTask", "CursorSelectionPathModeOptionTask"], FamSelectionPathItemsTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundShapeAnnotationTask", ["ForegroundShapeAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundShapeAnnotationTask", ["BackgroundShapeAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundAnnotationTask", ["BackgroundAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundHighlightPathAnnotationTask", ["ForegroundHighlightPathAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundHighlightPathAnnotationTask", ["BackgroundHighlightPathAnnotationOptionTask"], NormalVisibilityItemsByAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByForegroundConnectorAnnotationTask", ["ForegroundConnectorAnnotationOptionTask"], NormalVisibilityItemsByConnectorAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByBackgroundConnectorAnnotationTask", ["BackgroundConnectorAnnotationOptionTask"], NormalVisibilityItemsByConnectorAnnotationTask, Colors.Cyan);
  tasks.addTask("NormalVisibilityItemsByMinimumVisibleLevelsTask", ["MinimumVisibleLevelsOptionTask", "OrderFamilyNodesTask"], FamNormalVisibilityItemsByMinimumVisibleLevelsTask, Colors.Cyan);
  tasks.addTask("CombinedNormalVisibilityItemsTask", [
    "ItemsSizesOptionTask",
    "CursorItemTask",
    "CursorNeighboursTask",
    "SelectedItemsTask",
    "SelectionPathItemsTask",
    "NormalVisibilityItemsByForegroundShapeAnnotationTask",
    "NormalVisibilityItemsByBackgroundShapeAnnotationTask",
    "NormalVisibilityItemsByBackgroundAnnotationTask",
    "NormalVisibilityItemsByForegroundHighlightPathAnnotationTask",
    "NormalVisibilityItemsByBackgroundHighlightPathAnnotationTask",
    "NormalVisibilityItemsByForegroundConnectorAnnotationTask",
    "NormalVisibilityItemsByBackgroundConnectorAnnotationTask",
    "NormalVisibilityItemsByMinimumVisibleLevelsTask"
  ], CombinedNormalVisibilityItemsTask, Colors.Cyan);
  tasks.addTask("FrameSizeTask", ["FrameOptionTask", "ReadTemplatesTask", "ScaleOptionTask"], FrameSizeTask, Colors.Navy);
  tasks.addTask("LevelTitleSizeTask", ["LevelTitlePlacementOptionTask", "LevelAnnotationOptionTask", "OrientationOptionTask", "ScaleOptionTask"], LevelTitleSizeTask, Colors.Navy);
  tasks.addTask("LayoutOptionsTask", ["getLayout", "OptionsTask"], LayoutOptionsTask, Colors.Black);
  tasks.addTask("CurrentControlSizeTask", ["LayoutOptionsTask", "ItemsSizesOptionTask", "FrameSizeTask", "LevelTitleSizeTask"], CurrentControlSizeTask, Colors.Black);
  tasks.addTask("CurrentScrollPositionTask", ["LayoutOptionsTask"], CurrentScrollPositionTask, Colors.Black);
  tasks.addTask("ItemsPositionsTask", [
    "CurrentControlSizeTask",
    "ScaleOptionTask",
    "OrientationOptionTask",
    "ItemsSizesOptionTask",
    "ConnectorsOptionTask",
    "OrderFamilyNodesOptionTask",
    "FamCreateLayoutsTreeTask",
    "CombinedTemplateParamsTask",
    "CursorItemTask",
    "CombinedNormalVisibilityItemsTask"
  ], ItemsPositionsTask, Colors.Red);
  tasks.addTask("AlignDiagramTask", ["OrientationOptionTask", "ItemsSizesOptionTask", "VisualTreeOptionTask", "ScaleOptionTask", "CurrentControlSizeTask", "ActiveItemsTask", "ItemsPositionsTask"], AlignDiagramTask, Colors.Red);
  tasks.addTask("CreateTransformTask", ["OrientationOptionTask", "ScaleOptionTask", "AlignDiagramTask"], CreateTransformTask, Colors.Cyan);
  tasks.addTask("PaletteManagerTask", ["ConnectorsOptionTask", "LinePaletteOptionTask"], PaletteManagerTask, Colors.Cyan);
  tasks.addTask("ApplyLayoutChangesTask", ["graphics", "setLayout", "ItemsSizesOptionTask", "CurrentControlSizeTask", "ScaleOptionTask", "AlignDiagramTask", "FrameSizeTask", "LevelTitleSizeTask"], ApplyLayoutChangesTask, Colors.Cyan);
  tasks.addTask("CenterOnCursorTask", ["LayoutOptionsTask", "ApplyLayoutChangesTask", "CurrentScrollPositionTask", "CursorItemTask", "AlignDiagramTask", "CreateTransformTask", "ScaleOptionTask"], CenterOnCursorTask, Colors.Cyan);
  tasks.addTask("ProjectItemsToFrameTask", [
    "CreateTransformTask",
    "FrameSizeTask",
    "ApplyLayoutChangesTask",
    "ScaleOptionTask",
    "AlignDiagramTask",
    "CenterOnCursorTask",
    "ItemTemplateParamsTask",
    "SelectedItemsTask"
  ], ProjectItemsToFrameTask, Colors.Cyan);
  tasks.addTask("ViewPortPlacementTask", ["ScaleOptionTask", "CenterOnCursorTask", "CreateTransformTask", "ApplyLayoutChangesTask"], ViewPortPlacementTask, Colors.Green);
  tasks.addTask("VerticalOffsetTask", ["ViewPortPlacementTask"], VerticalOffsetTask, Colors.Green);
  tasks.addTask("LogicalLevelsPlacementTask", ["OrderFamilyNodesTask", "AlignDiagramTask"], FamLogicalLevelsPlacementTask, Colors.Green);
  tasks.addTask("MergeLevelIntervalsTask", ["LevelAnnotationOptionTask", "LogicalLevelsPlacementTask"], MergeLevelIntervalsTask, Colors.Green);
  tasks.addTask("DrawBackgroundHighlightPathAnnotationTask", ["graphics", "ConnectorsOptionTask", "ForegroundHighlightPathAnnotationOptionTask", "ConnectionsGraphTask", "foreground"], DrawHighlightPathAnnotationTask, Colors.Cyan);
  tasks.addTask("DrawForegroundHighlightPathAnnotationTask", ["graphics", "ConnectorsOptionTask", "BackgroundHighlightPathAnnotationOptionTask", "ConnectionsGraphTask", "background"], DrawHighlightPathAnnotationTask, Colors.Cyan);
  tasks.addTask("DrawBackgroundAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "BackgroundAnnotationOptionTask", "LogicalFamilyTask", "AlignDiagramTask"], DrawBackgroundAnnotationTask, Colors.Green);
  tasks.addTask("DrawForegroundConnectorAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "ForegroundConnectorAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "foreground"], DrawConnectorAnnotationTask, Colors.Green);
  tasks.addTask("DrawBackgroundConnectorAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "BackgroundConnectorAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "background"], DrawConnectorAnnotationTask, Colors.Green);
  tasks.addTask("DrawForegroundShapeAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "ForegroundShapeAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "foreground"], DrawShapeAnnotationTask, Colors.Green);
  tasks.addTask("DrawBackgroundShapeAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "OrientationOptionTask", "BackgroundShapeAnnotationOptionTask", "AlignDiagramTask", "AnnotationLabelTemplateTask", "background"], DrawShapeAnnotationTask, Colors.Green);
  tasks.addTask("DrawCursorTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "CombinedContextsTask", "AlignDiagramTask", "CombinedTemplateParamsTask", "CursorItemTask", "SelectedItemsTask"], DrawCursorTask, Colors.Green);
  tasks.addTask("DrawHighlightTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "CombinedContextsTask", "AlignDiagramTask", "CombinedTemplateParamsTask", "HighlightItemTask", "CursorItemTask", "SelectedItemsTask"], DrawHighlightTask, Colors.Green);
  tasks.addTask("DrawHighlightAnnotationTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "ScaleOptionTask", "CombinedContextsTask", "CalloutOptionTask", "ReadTemplatesTask", "AlignDiagramTask", "CenterOnCursorTask", "HighlightItemTask", "CursorItemTask", "SelectedItemsTask", "FrameSizeTask"], DrawHighlightAnnotationTask, Colors.Green);
  tasks.addTask("DrawTreeItemsTask", [
    "graphics",
    "CreateTransformTask",
    "ApplyLayoutChangesTask",
    "ScaleOptionTask",
    "ItemsSizesOptionTask",
    "CombinedContextsTask",
    "AlignDiagramTask",
    "CenterOnCursorTask",
    "CombinedTemplateParamsTask",
    "CursorItemTask",
    "SelectedItemsTask",
    "GroupTitleTemplateTask",
    "CheckBoxTemplateTask",
    "ButtonsTemplateTask"
  ], DrawTreeItemsTask, Colors.Green);
  tasks.addTask("DrawMinimizedItemsTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "MinimizedItemsOptionTask", "CombinedTemplateParamsTask", "AlignDiagramTask"], DrawMinimizedItemsTask, Colors.Green);
  tasks.addTask("DrawConnectorsTask", ["graphics", "ConnectionsGraphTask", "ConnectorsOptionTask", "showElbowDots", "PaletteManagerTask"], DrawConnectorsTask, Colors.Green);
  tasks.addTask("DrawItemLabelsTask", ["graphics", "CreateTransformTask", "ApplyLayoutChangesTask", "LabelsOptionTask", "AlignDiagramTask"], DrawItemLabelsTask, Colors.Green);
  tasks.addTask("DrawFrameItemsTask", ["graphics", "ApplyLayoutChangesTask", "ProjectItemsToFrameTask", "ItemTemplateParamsTask", "MinimizedItemsOptionTask"], DrawFrameItemsTask, Colors.Green);
  tasks.addTask("DrawFrameHighlightTask", ["graphics", "ProjectItemsToFrameTask", "CombinedContextsTask", "ItemTemplateParamsTask", "HighlightItemTask", "CursorItemTask"], DrawFrameHighlightTask, Colors.Green);
  tasks.addTask("DrawLevelAnnotationBackgroundTask", ["graphics", "VerticalOffsetTask", "CreateTransformTask", "ApplyLayoutChangesTask", "LevelAnnotationOptionTask", "MergeLevelIntervalsTask", "LevelAnnotationTemplateTask"], DrawLevelAnnotationBackgroundTask, Colors.Green);
  tasks.addTask("DrawLevelAnnotationTitlesTask", ["graphics", "VerticalOffsetTask", "CreateTransformTask", "ApplyLayoutChangesTask", "LevelAnnotationOptionTask", "MergeLevelIntervalsTask", "LevelAnnotationTemplateTask", "LevelTitlePlacementOptionTask"], DrawLevelAnnotationTitlesTask, Colors.Green);
  return tasks;
}

// node_modules/basicprimitives/src/graphics/PdfGraphics.js
function PdfGraphics(doc) {
  this._doc = doc, this._context = this._doc;
  this.m_placeholders = {};
  this.m_activePlaceholder = null;
  this.saveCounter = 0;
}
PdfGraphics.prototype.clean = function() {
  while (this.saveCounter) {
    this.saveCounter--;
    this._doc.restore();
  }
};
PdfGraphics.prototype.resize = function(name2, width, height) {
  var placeholder = this.m_placeholders[name2];
  if (!placeholder) {
    placeholder = new Placeholder(name2);
    ;
    placeholder.size = new Size(0, 0);
    placeholder.rect = new Rect(0, 0, 0, 0);
    this.m_placeholders[name2] = placeholder;
  }
  placeholder.size = new Size(width, height);
  placeholder.rect = new Rect(placeholder.rect.x, placeholder.rect.y, width, height);
};
PdfGraphics.prototype.position = function(name2, left, top, width, height) {
  this.resize(name2, width, height);
  var placeholder = this.m_placeholders[name2];
  placeholder.rect.x = left;
  placeholder.rect.y = top;
};
PdfGraphics.prototype.begin = function() {
};
PdfGraphics.prototype.end = function() {
};
PdfGraphics.prototype.reset = function(arg0, arg1) {
};
PdfGraphics.prototype.activate = function(name2, layer) {
  if (!this.m_placeholders[name2]) {
    this.resize(name2, 0, 0);
  }
  this.m_activePlaceholder = this.m_placeholders[name2];
  var { x, y } = this.m_activePlaceholder.rect;
  while (this.saveCounter) {
    this.saveCounter--;
    this._doc.restore();
  }
  this._doc.save();
  this.saveCounter++;
  this._doc.translate(x, y);
  return this.m_activePlaceholder;
};
PdfGraphics.prototype.text = function(x, y, width, height, label, orientation, horizontalAlignment, verticalAlignment, attr) {
};
PdfGraphics.prototype.polylinesBuffer = function(buffer) {
  buffer.loop(this, function(polyline) {
    if (polyline.length() > 0) {
      this.polyline(polyline);
    }
  });
};
PdfGraphics.prototype.polyline = function(polylineData) {
  var placeholder = this.m_activePlaceholder, attr = polylineData.paletteItem.toAttr(), step, cornerRadius, doc = this._doc;
  doc.save();
  polylineData.loop(this, function(segment) {
    switch (segment.segmentType) {
      case SegmentType.Move:
        doc.moveTo(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5);
        break;
      case SegmentType.Line:
        doc.lineTo(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5);
        break;
      case SegmentType.Dot:
        if (segment.width == segment.height && segment.width / 2 <= segment.cornerRadius) {
          doc.roundedRect(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5, segment.width, segment.height, Math.min(segment.width, segment.height) / 2);
        } else if (segment.cornerRadius === 0) {
          doc.moveTo(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5);
          doc.lineTo(Math.round(segment.x + segment.width) + 0.5, Math.round(segment.y) + 0.5);
          doc.lineTo(Math.round(segment.x + segment.width) + 0.5, Math.round(segment.y + segment.height) + 0.5);
          doc.lineTo(Math.round(segment.x) + 0.5, Math.round(segment.y + segment.height) + 0.5);
          doc.lineTo(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5);
        } else {
          cornerRadius = Math.min(segment.cornerRadius, Math.min(segment.width / 2, segment.height / 2));
          doc.roundedRect(Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5, segment.width, segment.height, cornerRadius);
        }
        break;
      case SegmentType.QuadraticArc:
        doc.quadraticCurveTo(Math.round(segment.cpX) + 0.5, Math.round(segment.cpY) + 0.5, Math.round(segment.x) + 0.5, Math.round(segment.y) + 0.5);
        break;
      case SegmentType.CubicArc:
        doc.bezierCurveTo(
          Math.round(segment.cpX1) + 0.5,
          Math.round(segment.cpY1) + 0.5,
          Math.round(segment.cpX2) + 0.5,
          Math.round(segment.cpY2) + 0.5,
          Math.round(segment.x) + 0.5,
          Math.round(segment.y) + 0.5
        );
        break;
    }
  });
  doc.lineJoin("round");
  if (attr.lineType != null) {
    step = Math.round(attr.lineWidth) || 1;
    switch (attr.lineType) {
      case LineType.Solid:
        break;
      case LineType.Dotted:
        doc.dash(step, step * 2);
        break;
      case LineType.Dashed:
        doc.dash(step * 5, step * 3);
        break;
    }
  }
  if (attr.lineWidth !== void 0 && attr.fillColor !== void 0) {
    doc.lineWidth(attr.lineWidth).fillColor(attr.fillColor, attr.opacity).strokeColor(attr.borderColor).fillAndStroke();
  } else if (attr.lineWidth !== void 0) {
    doc.lineWidth(attr.lineWidth).stroke(attr.borderColor);
  } else if (attr.fillColor !== void 0) {
    doc.fillColor(attr.fillColor, attr.opacity);
  }
  doc.restore();
};
PdfGraphics.prototype.rightAngleLine = function(fromX, fromY, toX, toY, attr) {
};
PdfGraphics.prototype.template = function(x, y, width, height, contentx, contenty, contentWidth, contentHeight, template, hashCode, onRenderTemplate, uiHash, attr) {
  var gap = 0;
  if (attr !== null) {
    if (attr.borderWidth !== void 0) {
      gap = this.getPxSize(attr.borderWidth);
    }
  }
  var position = new Rect(x + contentx, y + contenty, contentWidth - gap, contentHeight - gap);
  if (uiHash == null) {
    uiHash = new RenderEventArgs();
  }
  if (onRenderTemplate !== null) {
    onRenderTemplate(this._doc, position, uiHash);
  }
};
PdfGraphics.prototype.getPxSize = function(value, base) {
  var result = value;
  if (typeof value === "string") {
    if (value.indexOf("pt") > 0) {
      result = parseInt(value, 10) * 96 / 72;
    } else if (value.indexOf("%") > 0) {
      result = parseFloat(value) / 100 * base;
    } else {
      result = parseInt(value, 10);
    }
  }
  return result;
};

// node_modules/ngx-basic-primitives/fesm2020/ngx-basic-primitives.mjs
var _c0 = ["*"];
function RotatedText_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
}
function RotatedText_ng_template_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function RotatedText_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table", 4)(1, "tbody")(2, "tr")(3, "td", 4);
    ɵɵtemplate(4, RotatedText_ng_template_1_ng_container_4_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const content_r2 = ɵɵreference(6);
    ɵɵproperty("ngStyle", ctx_r0.tableStyle);
    ɵɵadvance(3);
    ɵɵproperty("ngStyle", ctx_r0.tdStyle);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r2);
  }
}
function RotatedText_ng_template_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function RotatedText_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, RotatedText_ng_template_3_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const content_r2 = ɵɵreference(6);
    ɵɵproperty("ngStyle", ctx_r0.divStyle);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r2);
  }
}
function RotatedText_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c1 = (a0) => ({
  backgroundColor: a0
});
var _c2 = (a0) => ({
  color: a0
});
var _c3 = (a0, a1, a2) => ({
  width: a0,
  height: a1,
  borderWidth: a2
});
var _c4 = (a0) => ({
  borderWidth: a0
});
var _c5 = ["frameMousePanelRef"];
var _c6 = ["framePlaceholderRef"];
var _c7 = ["titlesMousePanelRef"];
var _c8 = ["titlesPlaceholderRef"];
var _c9 = ["scrollPanelRef"];
var _c10 = ["mousePanelRef"];
var _c11 = ["placeholderRef"];
var _c12 = ["calloutPlaceholderRef"];
var _c13 = ["controlPanelRef"];
var _c14 = (a0) => ({
  $implicit: a0
});
var _c15 = (a0, a1) => ({
  width: a0,
  height: a1
});
function BaseDiagramComponent_div_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BaseDiagramComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18, 5);
    ɵɵlistener("click", function BaseDiagramComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    })("mousemove", function BaseDiagramComponent_div_2_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    });
    ɵɵelementStart(2, "div", 19, 6);
    ɵɵtemplate(4, BaseDiagramComponent_div_2_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.frameMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.framePlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.framePlaceholder));
  }
}
function BaseDiagramComponent_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BaseDiagramComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20, 7);
    ɵɵlistener("mousemove", function BaseDiagramComponent_div_3_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    })("click", function BaseDiagramComponent_div_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    });
    ɵɵelementStart(2, "div", 21, 8);
    ɵɵtemplate(4, BaseDiagramComponent_div_3_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.titlesMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.titlesPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.titlesPlaceholder));
  }
}
function BaseDiagramComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BaseDiagramComponent_div_11_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BaseDiagramComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22, 9);
    ɵɵtemplate(2, BaseDiagramComponent_div_11_ng_container_2_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.calloutPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c14, ctx_r2.calloutPlaceholder));
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 29)(1, "rotated-text", 30);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const label_r6 = ctx.$implicit;
    ɵɵproperty("ngStyle", label_r6.style);
    ɵɵadvance();
    ɵɵproperty("width", label_r6.width)("height", label_r6.height)("orientation", label_r6.orientation)("horizontalAlignment", label_r6.horizontalAlignment)("verticalAlignment", label_r6.verticalAlignment);
    ɵɵadvance();
    ɵɵtextInterpolate(label_r6.label);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 33);
  }
  if (rf & 2) {
    const path_r7 = ctx.$implicit;
    ɵɵproperty("ngStyle", path_r7.style);
    ɵɵattribute("d", path_r7.data);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 31);
    ɵɵtemplate(1, BaseDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template, 1, 2, "path", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext(2).$implicit;
    const placeholder_r9 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", ɵɵpureFunction2(4, _c15, placeholder_r9.size.width + "px", placeholder_r9.size.height + "px"));
    ɵɵattribute("height.px", placeholder_r9.size.height)("width.px", placeholder_r9.size.width);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.polylines);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-item", 38);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("itemConfig", item_r10.context.context)("itemTitleFirstFontColor", item_r10.context.itemTitleFirstFontColor)("itemTitleSecondFontColor", item_r10.context.itemTitleSecondFontColor);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-checkbox", 39);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("id", item_r10.context.id)("isSelected", item_r10.context.isSelected)("label", item_r10.context.selectCheckBoxLabel);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-group-title", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("itemConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-cursor", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-dot-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-title", 42);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("annotationConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-background", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("annotationConfig", item_r10.context.context);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.title);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.label);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template, 1, 0, "ng-container", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", item_r10.templateRef)("ngTemplateOutletContext", item_r10.context);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵelementContainerStart(1, 35);
    ɵɵtemplate(2, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template, 2, 3, "ng-container", 36)(3, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template, 2, 3, "ng-container", 36)(4, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template, 2, 4, "ng-container", 36)(5, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template, 2, 1, "ng-container", 36)(6, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template, 2, 1, "ng-container", 36)(7, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template, 2, 1, "ng-container", 36)(8, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template, 2, 4, "ng-container", 36)(9, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template, 2, 1, "ng-container", 36)(10, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template, 3, 1, "ng-container", 36)(11, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template, 3, 1, "ng-container", 36)(12, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template, 2, 2, "ng-container", 37);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    ɵɵproperty("ngStyle", item_r10.style);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", item_r10.templateType);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "itemTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "checkboxTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "groupTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cursorTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "highlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dotHighlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelBackgroundTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "labelAnnotationTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "annotationLabelTemplate");
  }
}
function BaseDiagramComponent_ng_template_12_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template, 3, 7, "div", 26)(2, BaseDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template, 2, 7, "svg", 27)(3, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template, 13, 12, "div", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.labels);
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8.polylines.length > 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.items);
  }
}
function BaseDiagramComponent_ng_template_12_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, BaseDiagramComponent_ng_template_12_div_0_ng_container_1_Template, 4, 3, "ng-container", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8);
  }
}
function BaseDiagramComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, BaseDiagramComponent_ng_template_12_div_0_Template, 2, 1, "div", 23);
  }
  if (rf & 2) {
    const placeholder_r9 = ctx.$implicit;
    ɵɵproperty("ngForOf", placeholder_r9.layers);
  }
}
function OrgDiagramComponent_div_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OrgDiagramComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18, 5);
    ɵɵlistener("click", function OrgDiagramComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    })("mousemove", function OrgDiagramComponent_div_2_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    });
    ɵɵelementStart(2, "div", 19, 6);
    ɵɵtemplate(4, OrgDiagramComponent_div_2_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.frameMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.framePlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.framePlaceholder));
  }
}
function OrgDiagramComponent_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OrgDiagramComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20, 7);
    ɵɵlistener("mousemove", function OrgDiagramComponent_div_3_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    })("click", function OrgDiagramComponent_div_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    });
    ɵɵelementStart(2, "div", 21, 8);
    ɵɵtemplate(4, OrgDiagramComponent_div_3_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.titlesMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.titlesPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.titlesPlaceholder));
  }
}
function OrgDiagramComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OrgDiagramComponent_div_11_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OrgDiagramComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22, 9);
    ɵɵtemplate(2, OrgDiagramComponent_div_11_ng_container_2_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.calloutPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c14, ctx_r2.calloutPlaceholder));
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 29)(1, "rotated-text", 30);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const label_r6 = ctx.$implicit;
    ɵɵproperty("ngStyle", label_r6.style);
    ɵɵadvance();
    ɵɵproperty("width", label_r6.width)("height", label_r6.height)("orientation", label_r6.orientation)("horizontalAlignment", label_r6.horizontalAlignment)("verticalAlignment", label_r6.verticalAlignment);
    ɵɵadvance();
    ɵɵtextInterpolate(label_r6.label);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 33);
  }
  if (rf & 2) {
    const path_r7 = ctx.$implicit;
    ɵɵproperty("ngStyle", path_r7.style);
    ɵɵattribute("d", path_r7.data);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 31);
    ɵɵtemplate(1, OrgDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template, 1, 2, "path", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext(2).$implicit;
    const placeholder_r9 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", ɵɵpureFunction2(4, _c15, placeholder_r9.size.width + "px", placeholder_r9.size.height + "px"));
    ɵɵattribute("height.px", placeholder_r9.size.height)("width.px", placeholder_r9.size.width);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.polylines);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-item", 38);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("itemConfig", item_r10.context.context)("itemTitleFirstFontColor", item_r10.context.itemTitleFirstFontColor)("itemTitleSecondFontColor", item_r10.context.itemTitleSecondFontColor);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-checkbox", 39);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("id", item_r10.context.id)("isSelected", item_r10.context.isSelected)("label", item_r10.context.selectCheckBoxLabel);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-group-title", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("itemConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-cursor", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-dot-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-title", 42);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("annotationConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-background", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("annotationConfig", item_r10.context.context);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.title);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.label);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template, 1, 0, "ng-container", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", item_r10.templateRef)("ngTemplateOutletContext", item_r10.context);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵelementContainerStart(1, 35);
    ɵɵtemplate(2, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template, 2, 3, "ng-container", 36)(3, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template, 2, 3, "ng-container", 36)(4, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template, 2, 4, "ng-container", 36)(5, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template, 2, 1, "ng-container", 36)(6, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template, 2, 1, "ng-container", 36)(7, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template, 2, 1, "ng-container", 36)(8, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template, 2, 4, "ng-container", 36)(9, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template, 2, 1, "ng-container", 36)(10, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template, 3, 1, "ng-container", 36)(11, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template, 3, 1, "ng-container", 36)(12, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template, 2, 2, "ng-container", 37);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    ɵɵproperty("ngStyle", item_r10.style);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", item_r10.templateType);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "itemTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "checkboxTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "groupTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cursorTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "highlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dotHighlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelBackgroundTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "labelAnnotationTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "annotationLabelTemplate");
  }
}
function OrgDiagramComponent_ng_template_12_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template, 3, 7, "div", 26)(2, OrgDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template, 2, 7, "svg", 27)(3, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template, 13, 12, "div", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.labels);
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8.polylines.length > 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.items);
  }
}
function OrgDiagramComponent_ng_template_12_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, OrgDiagramComponent_ng_template_12_div_0_ng_container_1_Template, 4, 3, "ng-container", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8);
  }
}
function OrgDiagramComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, OrgDiagramComponent_ng_template_12_div_0_Template, 2, 1, "div", 23);
  }
  if (rf & 2) {
    const placeholder_r9 = ctx.$implicit;
    ɵɵproperty("ngForOf", placeholder_r9.layers);
  }
}
var _c16 = ".control-panel[_ngcontent-%COMP%]{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.frame-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel[_ngcontent-%COMP%], .titles-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.scroll-panel[_ngcontent-%COMP%]{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:visible}.layer[_ngcontent-%COMP%]{position:absolute;overflow:visible;left:0px;top:0px}.label[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}";
function FamDiagramComponent_div_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function FamDiagramComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18, 5);
    ɵɵlistener("click", function FamDiagramComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    })("mousemove", function FamDiagramComponent_div_2_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    });
    ɵɵelementStart(2, "div", 19, 6);
    ɵɵtemplate(4, FamDiagramComponent_div_2_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.frameMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.framePlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.framePlaceholder));
  }
}
function FamDiagramComponent_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function FamDiagramComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20, 7);
    ɵɵlistener("mousemove", function FamDiagramComponent_div_3_Template_div_mousemove_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameMouseMove($event));
    })("click", function FamDiagramComponent_div_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFrameClick($event));
    });
    ɵɵelementStart(2, "div", 21, 8);
    ɵɵtemplate(4, FamDiagramComponent_div_3_ng_container_4_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.titlesMousePanelStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngStyle", ctx_r2.titlesPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r2.titlesPlaceholder));
  }
}
function FamDiagramComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function FamDiagramComponent_div_11_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function FamDiagramComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22, 9);
    ɵɵtemplate(2, FamDiagramComponent_div_11_ng_container_2_Template, 1, 0, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const layerTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngStyle", ctx_r2.calloutPlaceholderStyle);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c14, ctx_r2.calloutPlaceholder));
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 29)(1, "rotated-text", 30);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const label_r6 = ctx.$implicit;
    ɵɵproperty("ngStyle", label_r6.style);
    ɵɵadvance();
    ɵɵproperty("width", label_r6.width)("height", label_r6.height)("orientation", label_r6.orientation)("horizontalAlignment", label_r6.horizontalAlignment)("verticalAlignment", label_r6.verticalAlignment);
    ɵɵadvance();
    ɵɵtextInterpolate(label_r6.label);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 33);
  }
  if (rf & 2) {
    const path_r7 = ctx.$implicit;
    ɵɵproperty("ngStyle", path_r7.style);
    ɵɵattribute("d", path_r7.data);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 31);
    ɵɵtemplate(1, FamDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2__svg_path_1_Template, 1, 2, "path", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext(2).$implicit;
    const placeholder_r9 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", ɵɵpureFunction2(4, _c15, placeholder_r9.size.width + "px", placeholder_r9.size.height + "px"));
    ɵɵattribute("height.px", placeholder_r9.size.height)("width.px", placeholder_r9.size.width);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.polylines);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-item", 38);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("itemConfig", item_r10.context.context)("itemTitleFirstFontColor", item_r10.context.itemTitleFirstFontColor)("itemTitleSecondFontColor", item_r10.context.itemTitleSecondFontColor);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-checkbox", 39);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("id", item_r10.context.id)("isSelected", item_r10.context.isSelected)("label", item_r10.context.selectCheckBoxLabel);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-group-title", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("itemConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-cursor", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-dot-highlight", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateConfig", item_r10.context.templateConfig);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-title", 42);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("options", item_r10.context)("annotationConfig", item_r10.context.context)("width", item_r10.context.width)("height", item_r10.context.height);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "bp-level-background", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("annotationConfig", item_r10.context.context);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.title);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 44);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r10.context.context.label);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_ng_container_1_Template, 1, 0, "ng-container", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", item_r10.templateRef)("ngTemplateOutletContext", item_r10.context);
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵelementContainerStart(1, 35);
    ɵɵtemplate(2, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_2_Template, 2, 3, "ng-container", 36)(3, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_3_Template, 2, 3, "ng-container", 36)(4, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_4_Template, 2, 4, "ng-container", 36)(5, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_5_Template, 2, 1, "ng-container", 36)(6, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_6_Template, 2, 1, "ng-container", 36)(7, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_7_Template, 2, 1, "ng-container", 36)(8, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_8_Template, 2, 4, "ng-container", 36)(9, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_9_Template, 2, 1, "ng-container", 36)(10, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_10_Template, 3, 1, "ng-container", 36)(11, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_11_Template, 3, 1, "ng-container", 36)(12, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_ng_container_12_Template, 2, 2, "ng-container", 37);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    ɵɵproperty("ngStyle", item_r10.style);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", item_r10.templateType);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "itemTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "checkboxTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "groupTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cursorTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "highlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dotHighlightTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelTitleTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "levelBackgroundTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "labelAnnotationTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "annotationLabelTemplate");
  }
}
function FamDiagramComponent_ng_template_12_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_1_Template, 3, 7, "div", 26)(2, FamDiagramComponent_ng_template_12_div_0_ng_container_1__svg_svg_2_Template, 2, 7, "svg", 27)(3, FamDiagramComponent_ng_template_12_div_0_ng_container_1_div_3_Template, 13, 12, "div", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const layer_r8 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.labels);
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8.polylines.length > 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", layer_r8.items);
  }
}
function FamDiagramComponent_ng_template_12_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, FamDiagramComponent_ng_template_12_div_0_ng_container_1_Template, 4, 3, "ng-container", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const layer_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", layer_r8);
  }
}
function FamDiagramComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FamDiagramComponent_ng_template_12_div_0_Template, 2, 1, "div", 23);
  }
  if (rf & 2) {
    const placeholder_r9 = ctx.$implicit;
    ɵɵproperty("ngForOf", placeholder_r9.layers);
  }
}
var AdviserPlacementType2;
(function(AdviserPlacementType3) {
  AdviserPlacementType3[AdviserPlacementType3["Auto"] = 0] = "Auto";
  AdviserPlacementType3[AdviserPlacementType3["Left"] = 2] = "Left";
  AdviserPlacementType3[AdviserPlacementType3["Right"] = 3] = "Right";
})(AdviserPlacementType2 || (AdviserPlacementType2 = {}));
var AnnotationType2;
(function(AnnotationType3) {
  AnnotationType3[AnnotationType3["Connector"] = 0] = "Connector";
  AnnotationType3[AnnotationType3["Shape"] = 1] = "Shape";
  AnnotationType3[AnnotationType3["HighlightPath"] = 2] = "HighlightPath";
  AnnotationType3[AnnotationType3["Label"] = 3] = "Label";
  AnnotationType3[AnnotationType3["Background"] = 4] = "Background";
  AnnotationType3[AnnotationType3["Level"] = 5] = "Level";
})(AnnotationType2 || (AnnotationType2 = {}));
var ChildrenPlacementType2;
(function(ChildrenPlacementType3) {
  ChildrenPlacementType3[ChildrenPlacementType3["Auto"] = 0] = "Auto";
  ChildrenPlacementType3[ChildrenPlacementType3["Vertical"] = 1] = "Vertical";
  ChildrenPlacementType3[ChildrenPlacementType3["Horizontal"] = 2] = "Horizontal";
  ChildrenPlacementType3[ChildrenPlacementType3["Matrix"] = 3] = "Matrix";
})(ChildrenPlacementType2 || (ChildrenPlacementType2 = {}));
var Colors2;
(function(Colors3) {
  Colors3["AliceBlue"] = "#f0f8ff";
  Colors3["AntiqueWhite"] = "#faebd7";
  Colors3["Aqua"] = "#00ffff";
  Colors3["Aquamarine"] = "#7fffd4";
  Colors3["Azure"] = "#f0ffff";
  Colors3["Beige"] = "#f5f5dc";
  Colors3["Bisque"] = "#ffe4c4";
  Colors3["Black"] = "#000000";
  Colors3["BlanchedAlmond"] = "#ffebcd";
  Colors3["Blue"] = "#0000ff";
  Colors3["BlueViolet"] = "#8a2be2";
  Colors3["Brown"] = "#a52a2a";
  Colors3["BurlyWood"] = "#deb887";
  Colors3["Bronze"] = "#cd7f32";
  Colors3["CadetBlue"] = "#5f9ea0";
  Colors3["ChartReuse"] = "#7fff00";
  Colors3["Chocolate"] = "#d2691e";
  Colors3["Coral"] = "#ff7f50";
  Colors3["CornflowerBlue"] = "#6495ed";
  Colors3["Cornsilk"] = "#fff8dc";
  Colors3["Crimson"] = "#dc143c";
  Colors3["Cyan"] = "#00ffff";
  Colors3["DarkBlue"] = "#00008b";
  Colors3["DarkCyan"] = "#008b8b";
  Colors3["DarkGoldenrod"] = "#b8860b";
  Colors3["DarkGray"] = "#a9a9a9";
  Colors3["DarkGreen"] = "#006400";
  Colors3["DarkKhaki"] = "#bdb76b";
  Colors3["DarkMagenta"] = "#8b008b";
  Colors3["DarkOliveGreen"] = "#556b2f";
  Colors3["Darkorange"] = "#ff8c00";
  Colors3["DarkOrchid"] = "#9932cc";
  Colors3["DarkRed"] = "#8b0000";
  Colors3["DarkSalmon"] = "#e9967a";
  Colors3["DarkSeaGreen"] = "#8fbc8f";
  Colors3["DarkSlateBlue"] = "#483d8b";
  Colors3["DarkSlateGray"] = "#2f4f4f";
  Colors3["DarkTurquoise"] = "#00ced1";
  Colors3["DarkViolet"] = "#9400d3";
  Colors3["DeepPink"] = "#ff1493";
  Colors3["DeepSkyBlue"] = "#00bfff";
  Colors3["DimGray"] = "#696969";
  Colors3["DodgerBlue"] = "#1e90ff";
  Colors3["FireBrick"] = "#b22222";
  Colors3["FloralWhite"] = "#fffaf0";
  Colors3["ForestGreen"] = "#228b22";
  Colors3["Fuchsia"] = "#ff00ff";
  Colors3["Gainsboro"] = "#dcdcdc";
  Colors3["GhostWhite"] = "#f8f8ff";
  Colors3["Gold"] = "#ffd700";
  Colors3["Goldenrod"] = "#daa520";
  Colors3["Gray"] = "#808080";
  Colors3["Green"] = "#008000";
  Colors3["GreenYellow"] = "#adff2f";
  Colors3["Honeydew"] = "#f0fff0";
  Colors3["Hotpink"] = "#ff69b4";
  Colors3["IndianRed"] = "#cd5c5c";
  Colors3["Indigo"] = "#4b0082";
  Colors3["Ivory"] = "#fffff0";
  Colors3["Khaki"] = "#f0e68c";
  Colors3["Lavender"] = "#e6e6fa";
  Colors3["LavenderBlush"] = "#fff0f5";
  Colors3["Lawngreen"] = "#7cfc00";
  Colors3["Lemonchiffon"] = "#fffacd";
  Colors3["LightBlue"] = "#add8e6";
  Colors3["LightCoral"] = "#f08080";
  Colors3["LightCyan"] = "#e0ffff";
  Colors3["LightGoldenrodYellow"] = "#fafad2";
  Colors3["LightGray"] = "#d3d3d3";
  Colors3["LightGreen"] = "#90ee90";
  Colors3["LightPink"] = "#ffb6c1";
  Colors3["LightSalmon"] = "#ffa07a";
  Colors3["LightSeaGreen"] = "#20b2aa";
  Colors3["LightSkyBlue"] = "#87cefa";
  Colors3["LightSlateGray"] = "#778899";
  Colors3["LightSteelBlue"] = "#b0c4de";
  Colors3["LightYellow"] = "#ffffe0";
  Colors3["Lime"] = "#00ff00";
  Colors3["Limegreen"] = "#32cd32";
  Colors3["Linen"] = "#faf0e6";
  Colors3["Magenta"] = "#ff00ff";
  Colors3["Maroon"] = "#800000";
  Colors3["MediumAquamarine"] = "#66cdaa";
  Colors3["MediumBlue"] = "#0000cd";
  Colors3["MediumOrchid"] = "#ba55d3";
  Colors3["MediumPurple"] = "#9370d8";
  Colors3["MediumSeaGreen"] = "#3cb371";
  Colors3["MediumSlateBlue"] = "#7b68ee";
  Colors3["MediumSpringGreen"] = "#00fa9a";
  Colors3["MediumTurquoise"] = "#48d1cc";
  Colors3["MediumVioletRed"] = "#c71585";
  Colors3["MidnightBlue"] = "#191970";
  Colors3["MintCream"] = "#f5fffa";
  Colors3["MistyRose"] = "#ffe4e1";
  Colors3["Moccasin"] = "#ffe4b5";
  Colors3["NavajoWhite"] = "#ffdead";
  Colors3["Navy"] = "#000080";
  Colors3["Oldlace"] = "#fdf5e6";
  Colors3["Olive"] = "#808000";
  Colors3["Olivedrab"] = "#6b8e23";
  Colors3["Orange"] = "#ffa500";
  Colors3["OrangeRed"] = "#ff4500";
  Colors3["Orchid"] = "#da70d6";
  Colors3["PaleGoldenRod"] = "#eee8aa";
  Colors3["PaleGreen"] = "#98fb98";
  Colors3["PaleTurquoise"] = "#afeeee";
  Colors3["PaleVioletRed"] = "#d87093";
  Colors3["Papayawhip"] = "#ffefd5";
  Colors3["Peachpuff"] = "#ffdab9";
  Colors3["Peru"] = "#cd853f";
  Colors3["Pink"] = "#ffc0cb";
  Colors3["Plum"] = "#dda0dd";
  Colors3["PowderBlue"] = "#b0e0e6";
  Colors3["Purple"] = "#800080";
  Colors3["Red"] = "#ff0000";
  Colors3["RosyBrown"] = "#bc8f8f";
  Colors3["RoyalBlue"] = "#4169e1";
  Colors3["SaddleBrown"] = "#8b4513";
  Colors3["Salmon"] = "#fa8072";
  Colors3["SandyBrown"] = "#f4a460";
  Colors3["SeaGreen"] = "#2e8b57";
  Colors3["Seashell"] = "#fff5ee";
  Colors3["Sienna"] = "#a0522d";
  Colors3["Silver"] = "#c0c0c0";
  Colors3["SkyBlue"] = "#87ceeb";
  Colors3["SlateBlue"] = "#6a5acd";
  Colors3["SlateGray"] = "#708090";
  Colors3["Snow"] = "#fffafa";
  Colors3["SpringGreen"] = "#00ff7f";
  Colors3["SteelBlue"] = "#4682b4";
  Colors3["Tan"] = "#d2b48c";
  Colors3["Teal"] = "#008080";
  Colors3["Thistle"] = "#d8bfd8";
  Colors3["Tomato"] = "#ff6347";
  Colors3["Turquoise"] = "#40e0d0";
  Colors3["Violet"] = "#ee82ee";
  Colors3["Wheat"] = "#f5deb3";
  Colors3["White"] = "#ffffff";
  Colors3["WhiteSmoke"] = "#f5f5f5";
  Colors3["Yellow"] = "#ffff00";
  Colors3["YellowGreen"] = "#9acd32";
})(Colors2 || (Colors2 = {}));
var ConnectorLabelPlacementType2;
(function(ConnectorLabelPlacementType3) {
  ConnectorLabelPlacementType3[ConnectorLabelPlacementType3["From"] = 0] = "From";
  ConnectorLabelPlacementType3[ConnectorLabelPlacementType3["Between"] = 1] = "Between";
  ConnectorLabelPlacementType3[ConnectorLabelPlacementType3["To"] = 2] = "To";
})(ConnectorLabelPlacementType2 || (ConnectorLabelPlacementType2 = {}));
var ConnectorPlacementType2;
(function(ConnectorPlacementType3) {
  ConnectorPlacementType3[ConnectorPlacementType3["Offbeat"] = 0] = "Offbeat";
  ConnectorPlacementType3[ConnectorPlacementType3["Straight"] = 1] = "Straight";
})(ConnectorPlacementType2 || (ConnectorPlacementType2 = {}));
var ConnectorShapeType2;
(function(ConnectorShapeType3) {
  ConnectorShapeType3[ConnectorShapeType3["OneWay"] = 0] = "OneWay";
  ConnectorShapeType3[ConnectorShapeType3["TwoWay"] = 1] = "TwoWay";
  ConnectorShapeType3[ConnectorShapeType3["BothWay"] = 2] = "BothWay";
})(ConnectorShapeType2 || (ConnectorShapeType2 = {}));
var ConnectorStyleType2;
(function(ConnectorStyleType3) {
  ConnectorStyleType3[ConnectorStyleType3["Extra"] = 0] = "Extra";
  ConnectorStyleType3[ConnectorStyleType3["Regular"] = 1] = "Regular";
  ConnectorStyleType3[ConnectorStyleType3["Highlight"] = 2] = "Highlight";
})(ConnectorStyleType2 || (ConnectorStyleType2 = {}));
var ConnectorType2;
(function(ConnectorType3) {
  ConnectorType3[ConnectorType3["Squared"] = 0] = "Squared";
  ConnectorType3[ConnectorType3["Angular"] = 1] = "Angular";
  ConnectorType3[ConnectorType3["Curved"] = 2] = "Curved";
})(ConnectorType2 || (ConnectorType2 = {}));
var ElbowType2;
(function(ElbowType3) {
  ElbowType3[ElbowType3["None"] = 0] = "None";
  ElbowType3[ElbowType3["Dot"] = 1] = "Dot";
  ElbowType3[ElbowType3["Bevel"] = 2] = "Bevel";
  ElbowType3[ElbowType3["Round"] = 3] = "Round";
})(ElbowType2 || (ElbowType2 = {}));
var Enabled2;
(function(Enabled3) {
  Enabled3[Enabled3["Auto"] = 0] = "Auto";
  Enabled3[Enabled3["True"] = 1] = "True";
  Enabled3[Enabled3["False"] = 2] = "False";
})(Enabled2 || (Enabled2 = {}));
var GroupByType2;
(function(GroupByType3) {
  GroupByType3[GroupByType3["None"] = 0] = "None";
  GroupByType3[GroupByType3["Parents"] = 1] = "Parents";
  GroupByType3[GroupByType3["Children"] = 2] = "Children";
})(GroupByType2 || (GroupByType2 = {}));
var HorizontalAlignmentType2;
(function(HorizontalAlignmentType3) {
  HorizontalAlignmentType3[HorizontalAlignmentType3["Center"] = 0] = "Center";
  HorizontalAlignmentType3[HorizontalAlignmentType3["Left"] = 1] = "Left";
  HorizontalAlignmentType3[HorizontalAlignmentType3["Right"] = 2] = "Right";
})(HorizontalAlignmentType2 || (HorizontalAlignmentType2 = {}));
var ItemType2;
(function(ItemType3) {
  ItemType3[ItemType3["Regular"] = 0] = "Regular";
  ItemType3[ItemType3["Assistant"] = 1] = "Assistant";
  ItemType3[ItemType3["SubAssistant"] = 4] = "SubAssistant";
  ItemType3[ItemType3["Adviser"] = 2] = "Adviser";
  ItemType3[ItemType3["SubAdviser"] = 5] = "SubAdviser";
  ItemType3[ItemType3["GeneralPartner"] = 6] = "GeneralPartner";
  ItemType3[ItemType3["LimitedPartner"] = 7] = "LimitedPartner";
  ItemType3[ItemType3["AdviserPartner"] = 8] = "AdviserPartner";
})(ItemType2 || (ItemType2 = {}));
var LabelType2;
(function(LabelType3) {
  LabelType3[LabelType3["Regular"] = 0] = "Regular";
  LabelType3[LabelType3["Dummy"] = 1] = "Dummy";
  LabelType3[LabelType3["Fixed"] = 2] = "Fixed";
  LabelType3[LabelType3["None"] = 3] = "None";
})(LabelType2 || (LabelType2 = {}));
var Layers2;
(function(Layers3) {
  Layers3[Layers3["LevelAnnotation"] = 1] = "LevelAnnotation";
  Layers3[Layers3["BackgroundAnnotation"] = 2] = "BackgroundAnnotation";
  Layers3[Layers3["BackgroundAnnotations"] = 3] = "BackgroundAnnotations";
  Layers3[Layers3["BackgroundConnectorAnnotation"] = 4] = "BackgroundConnectorAnnotation";
  Layers3[Layers3["BackgroundHighlightPathAnnotations"] = 5] = "BackgroundHighlightPathAnnotations";
  Layers3[Layers3["Connector"] = 6] = "Connector";
  Layers3[Layers3["ForegroundHighlightPathAnnotations"] = 7] = "ForegroundHighlightPathAnnotations";
  Layers3[Layers3["Highlight"] = 8] = "Highlight";
  Layers3[Layers3["Marker"] = 9] = "Marker";
  Layers3[Layers3["Label"] = 10] = "Label";
  Layers3[Layers3["Cursor"] = 11] = "Cursor";
  Layers3[Layers3["Item"] = 12] = "Item";
  Layers3[Layers3["ForegroundAnnotations"] = 13] = "ForegroundAnnotations";
  Layers3[Layers3["ForegroundConnectorAnnotation"] = 14] = "ForegroundConnectorAnnotation";
  Layers3[Layers3["Annotation"] = 15] = "Annotation";
  Layers3[Layers3["Controls"] = 16] = "Controls";
})(Layers2 || (Layers2 = {}));
var LineType2;
(function(LineType3) {
  LineType3[LineType3["Solid"] = 0] = "Solid";
  LineType3[LineType3["Dotted"] = 1] = "Dotted";
  LineType3[LineType3["Dashed"] = 2] = "Dashed";
})(LineType2 || (LineType2 = {}));
var NavigationMode2;
(function(NavigationMode3) {
  NavigationMode3[NavigationMode3["Default"] = 0] = "Default";
  NavigationMode3[NavigationMode3["CursorOnly"] = 1] = "CursorOnly";
  NavigationMode3[NavigationMode3["HighlightOnly"] = 3] = "HighlightOnly";
  NavigationMode3[NavigationMode3["Inactive"] = 2] = "Inactive";
})(NavigationMode2 || (NavigationMode2 = {}));
var NeighboursSelectionMode2;
(function(NeighboursSelectionMode3) {
  NeighboursSelectionMode3[NeighboursSelectionMode3["ParentsAndChildren"] = 0] = "ParentsAndChildren";
  NeighboursSelectionMode3[NeighboursSelectionMode3["ParentsChildrenSiblingsAndSpouses"] = 1] = "ParentsChildrenSiblingsAndSpouses";
})(NeighboursSelectionMode2 || (NeighboursSelectionMode2 = {}));
var OrientationType2;
(function(OrientationType3) {
  OrientationType3[OrientationType3["Top"] = 0] = "Top";
  OrientationType3[OrientationType3["Bottom"] = 1] = "Bottom";
  OrientationType3[OrientationType3["Left"] = 2] = "Left";
  OrientationType3[OrientationType3["Right"] = 3] = "Right";
  OrientationType3[OrientationType3["None"] = 4] = "None";
})(OrientationType2 || (OrientationType2 = {}));
var PageFitMode2;
(function(PageFitMode3) {
  PageFitMode3[PageFitMode3["None"] = 0] = "None";
  PageFitMode3[PageFitMode3["PageWidth"] = 1] = "PageWidth";
  PageFitMode3[PageFitMode3["PageHeight"] = 2] = "PageHeight";
  PageFitMode3[PageFitMode3["FitToPage"] = 3] = "FitToPage";
  PageFitMode3[PageFitMode3["AutoSize"] = 5] = "AutoSize";
  PageFitMode3[PageFitMode3["SelectionOnly"] = 6] = "SelectionOnly";
})(PageFitMode2 || (PageFitMode2 = {}));
var PlacementType2;
(function(PlacementType3) {
  PlacementType3[PlacementType3["Auto"] = 0] = "Auto";
  PlacementType3[PlacementType3["TopLeft"] = 8] = "TopLeft";
  PlacementType3[PlacementType3["Top"] = 1] = "Top";
  PlacementType3[PlacementType3["TopRight"] = 2] = "TopRight";
  PlacementType3[PlacementType3["RightTop"] = 11] = "RightTop";
  PlacementType3[PlacementType3["Right"] = 3] = "Right";
  PlacementType3[PlacementType3["RightBottom"] = 12] = "RightBottom";
  PlacementType3[PlacementType3["BottomRight"] = 4] = "BottomRight";
  PlacementType3[PlacementType3["Bottom"] = 5] = "Bottom";
  PlacementType3[PlacementType3["BottomLeft"] = 6] = "BottomLeft";
  PlacementType3[PlacementType3["LeftBottom"] = 10] = "LeftBottom";
  PlacementType3[PlacementType3["Left"] = 7] = "Left";
  PlacementType3[PlacementType3["LeftTop"] = 9] = "LeftTop";
})(PlacementType2 || (PlacementType2 = {}));
var RenderingMode2;
(function(RenderingMode3) {
  RenderingMode3[RenderingMode3["Create"] = 0] = "Create";
  RenderingMode3[RenderingMode3["Update"] = 1] = "Update";
})(RenderingMode2 || (RenderingMode2 = {}));
var SegmentType2;
(function(SegmentType3) {
  SegmentType3[SegmentType3["Line"] = 0] = "Line";
  SegmentType3[SegmentType3["Move"] = 1] = "Move";
  SegmentType3[SegmentType3["QuadraticArc"] = 2] = "QuadraticArc";
  SegmentType3[SegmentType3["CubicArc"] = 3] = "CubicArc";
  SegmentType3[SegmentType3["Dot"] = 4] = "Dot";
})(SegmentType2 || (SegmentType2 = {}));
var SelectionPathMode2;
(function(SelectionPathMode3) {
  SelectionPathMode3[SelectionPathMode3["None"] = 0] = "None";
  SelectionPathMode3[SelectionPathMode3["FullStack"] = 1] = "FullStack";
})(SelectionPathMode2 || (SelectionPathMode2 = {}));
var ShapeType2;
(function(ShapeType3) {
  ShapeType3[ShapeType3["Rectangle"] = 0] = "Rectangle";
  ShapeType3[ShapeType3["Oval"] = 1] = "Oval";
  ShapeType3[ShapeType3["Triangle"] = 2] = "Triangle";
  ShapeType3[ShapeType3["CrossOut"] = 3] = "CrossOut";
  ShapeType3[ShapeType3["Circle"] = 4] = "Circle";
  ShapeType3[ShapeType3["Rhombus"] = 5] = "Rhombus";
  ShapeType3[ShapeType3["Wedge"] = 7] = "Wedge";
  ShapeType3[ShapeType3["FramedOval"] = 8] = "FramedOval";
  ShapeType3[ShapeType3["FramedTriangle"] = 9] = "FramedTriangle";
  ShapeType3[ShapeType3["FramedWedge"] = 10] = "FramedWedge";
  ShapeType3[ShapeType3["FramedRhombus"] = 11] = "FramedRhombus";
  ShapeType3[ShapeType3["None"] = 6] = "None";
})(ShapeType2 || (ShapeType2 = {}));
var SideFlag2;
(function(SideFlag3) {
  SideFlag3[SideFlag3["Top"] = 1] = "Top";
  SideFlag3[SideFlag3["Right"] = 2] = "Right";
  SideFlag3[SideFlag3["Bottom"] = 4] = "Bottom";
  SideFlag3[SideFlag3["Left"] = 8] = "Left";
})(SideFlag2 || (SideFlag2 = {}));
var TextOrientationType2;
(function(TextOrientationType3) {
  TextOrientationType3[TextOrientationType3["Horizontal"] = 0] = "Horizontal";
  TextOrientationType3[TextOrientationType3["RotateLeft"] = 1] = "RotateLeft";
  TextOrientationType3[TextOrientationType3["RotateRight"] = 2] = "RotateRight";
  TextOrientationType3[TextOrientationType3["Auto"] = 3] = "Auto";
})(TextOrientationType2 || (TextOrientationType2 = {}));
var UpdateMode2;
(function(UpdateMode3) {
  UpdateMode3[UpdateMode3["Recreate"] = 0] = "Recreate";
  UpdateMode3[UpdateMode3["Refresh"] = 1] = "Refresh";
  UpdateMode3[UpdateMode3["PositonHighlight"] = 2] = "PositonHighlight";
})(UpdateMode2 || (UpdateMode2 = {}));
var VectorRelationType2;
(function(VectorRelationType3) {
  VectorRelationType3[VectorRelationType3["None"] = 0] = "None";
  VectorRelationType3[VectorRelationType3["Null"] = 1] = "Null";
  VectorRelationType3[VectorRelationType3["Collinear"] = 2] = "Collinear";
  VectorRelationType3[VectorRelationType3["Opposite"] = 3] = "Opposite";
})(VectorRelationType2 || (VectorRelationType2 = {}));
var VerticalAlignmentType2;
(function(VerticalAlignmentType3) {
  VerticalAlignmentType3[VerticalAlignmentType3["Top"] = 0] = "Top";
  VerticalAlignmentType3[VerticalAlignmentType3["Middle"] = 1] = "Middle";
  VerticalAlignmentType3[VerticalAlignmentType3["Bottom"] = 2] = "Bottom";
})(VerticalAlignmentType2 || (VerticalAlignmentType2 = {}));
var Visibility2;
(function(Visibility3) {
  Visibility3[Visibility3["Auto"] = 0] = "Auto";
  Visibility3[Visibility3["Normal"] = 1] = "Normal";
  Visibility3[Visibility3["Dot"] = 2] = "Dot";
  Visibility3[Visibility3["Line"] = 3] = "Line";
  Visibility3[Visibility3["Invisible"] = 4] = "Invisible";
})(Visibility2 || (Visibility2 = {}));
var ZOrderType2;
(function(ZOrderType3) {
  ZOrderType3[ZOrderType3["Auto"] = 0] = "Auto";
  ZOrderType3[ZOrderType3["Background"] = 1] = "Background";
  ZOrderType3[ZOrderType3["Foreground"] = 2] = "Foreground";
})(ZOrderType2 || (ZOrderType2 = {}));
var Rect2 = class {
  constructor(x = 0, y = 0, width = 0, height = 0, context = null) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  translate(x, y) {
    this.x = this.x + x;
    this.y = this.y + y;
    return this;
  }
  getCSS(units = "px") {
    var result = {
      left: this.x + units,
      top: this.y + units,
      width: this.width + units,
      height: this.height + units
    };
    return result;
  }
};
var Size2 = class {
  constructor(width = 0, height = 0) {
    this.width = 0;
    this.height = 0;
    this.width = width;
    this.height = height;
  }
  getCSS(units = "px") {
    var result = {
      width: this.width + units,
      height: this.height + units
    };
    return result;
  }
  space() {
    return this.width * this.height;
  }
};
var Thickness2 = class {
  constructor(left, top, right, bottom) {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
};
var Point2 = class {
  constructor(x = 0, y = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  getCSS(units = "px") {
    var result = {
      left: this.x + units,
      top: this.y + units
    };
    return result;
  }
};
var Path = class {
  constructor(data, style) {
    this.data = data;
    this.style = style;
  }
};
var Label2 = class {
  constructor(label, width, height, orientation, horizontalAlignment, verticalAlignment, style) {
    this.label = label;
    this.width = width;
    this.height = height;
    this.orientation = orientation;
    this.horizontalAlignment = horizontalAlignment;
    this.verticalAlignment = verticalAlignment;
    this.style = style;
  }
};
var Template2 = class {
  constructor(templateType, name2, templateRef, context, style) {
    this.templateType = templateType;
    this.name = name2;
    this.templateRef = templateRef;
    this.context = context;
    this.style = style;
  }
};
var Placeholder2 = class {
  constructor(name2) {
    this.layers = [];
    this.activeLayer = null;
    this.size = new Size2();
    this.rect = new Rect2();
    this.hasGraphics = true;
    this.isVisible = true;
    this.name = name2;
    this.layers = [];
    this.activeLayer = null;
  }
};
var Layer2 = class {
  constructor(name2) {
    this.items = [];
    this.polylines = [];
    this.labels = [];
    this.name = name2;
  }
  reset() {
    this.items = [];
    this.polylines = [];
    this.labels = [];
  }
};
var Graphics2 = class {
  constructor(size) {
    this.placeholders = {};
    this.activePlaceholder = null;
    this.hasGraphics = true;
    this.names = [];
    this.size = size;
    this.names = [];
    for (var layer in Layers2) {
      let value = parseInt(Layers2[layer]);
      this.names[value] = layer;
    }
    ;
  }
  clean() {
    this.placeholders = {};
    this.activePlaceholder = null;
  }
  resize(name2, width, height) {
    this.activatePlaceholder(name2);
    this.resizePlaceholder(this.activePlaceholder, 0, 0, width, height);
  }
  position(name2, left, top, width, height) {
    this.activatePlaceholder(name2);
    this.resizePlaceholder(this.activePlaceholder, left, top, width, height);
  }
  show(name2) {
    var placeholder = this.placeholders[name2];
    if (placeholder != null) {
      placeholder.isVisible = true;
    }
  }
  hide(name2) {
    var placeholder = this.placeholders[name2];
    if (placeholder != null) {
      placeholder.isVisible = false;
    }
  }
  resizePlaceholder(placeholder, left, top, width, height) {
    placeholder.size = new Size2(width, height);
    placeholder.rect = new Rect2(left, top, width, height);
  }
  reset(placeholderName, layerKey) {
    const placeholder = this.placeholders[placeholderName];
    if (placeholder != null) {
      const layer = placeholder.layers[layerKey];
      if (layer != null) {
        layer.reset();
      }
    }
  }
  activate(placeholderName, layerKey) {
    this.activatePlaceholder(placeholderName);
    this.activateLayer(layerKey);
    return this.activePlaceholder;
  }
  activatePlaceholder(name2) {
    let placeholder = this.placeholders[name2];
    if (placeholder === void 0) {
      placeholder = new Placeholder2(name2);
      placeholder.size = this.size;
      placeholder.rect = new Rect2(0, 0, placeholder.size.width, placeholder.size.height);
      this.placeholders[name2] = placeholder;
    }
    this.activePlaceholder = placeholder;
  }
  activateLayer(layerKey) {
    const name2 = this.names[layerKey];
    if (!this.activePlaceholder) {
      throw "No active placeholder";
    }
    let layer = this.activePlaceholder.layers[layerKey];
    if (layer === void 0) {
      layer = new Layer2(name2);
      this.activePlaceholder.layers[layerKey] = layer;
    }
    this.activePlaceholder.activeLayer = layer;
  }
  getPlaceholders() {
    return this.placeholders;
  }
  text(x, y, width, height, label, orientation, horizontalAlignment, verticalAlignment, attr) {
    if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
      throw "No active placeholder or layer";
    }
    this.activePlaceholder.activeLayer.labels.push(new Label2(label, width, height, orientation, horizontalAlignment, verticalAlignment, __spreadProps(__spreadValues({}, attr), {
      top: y + "px",
      left: x + "px"
    })));
  }
  polyline(polylineData) {
    if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
      throw "No active placeholder or layer";
    }
    var attr = polylineData.paletteItem.toAttr(), step, radius, cornerRadius, style = {};
    if (attr.fillColor !== void 0) {
      style.fill = attr.fillColor;
      style.fillOpacity = attr.opacity;
    } else {
      style.fillOpacity = 0;
    }
    if (attr.lineWidth !== void 0 && attr.borderColor !== void 0) {
      style.stroke = attr.borderColor;
      style.strokeWidth = attr.lineWidth;
      if (attr.opacity !== void 0) {
        style.strokeOpacity = attr.opacity;
      } else {
        style.strokeOpacity = 1;
      }
    } else {
      style.stroke = "transparent";
      style.strokeWidth = 0;
    }
    if (attr.lineType != null) {
      step = Math.round(attr.lineWidth) || 1;
      switch (attr.lineType) {
        case LineType2.Dotted:
          style.strokeDasharray = step + "," + step;
          break;
        case LineType2.Dashed:
          style.strokeDasharray = step * 5 + "," + step * 3;
          break;
        case LineType2.Solid:
        default:
          style.strokeDasharray = "";
          break;
      }
    }
    let data = "";
    polylineData.loop(this, function(segment) {
      switch (segment.segmentType) {
        case SegmentType2.Move:
          data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          break;
        case SegmentType2.Line:
          data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          break;
        case SegmentType2.QuadraticArc:
          data += "Q" + (Math.round(segment.cpX) + 0.5) + " " + (Math.round(segment.cpY) + 0.5) + " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          break;
        case SegmentType2.Dot:
          if (segment.width === segment.height && segment.width / 2 <= segment.cornerRadius) {
            radius = segment.width / 2;
            data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
            data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
            data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2 + 0.5);
          } else if (segment.cornerRadius === 0) {
            data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
            data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + 0.5);
            data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
            data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
            data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          } else {
            cornerRadius = Math.min(segment.cornerRadius, Math.min(segment.width / 2, segment.height / 2));
            data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
            data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
            data += "L" + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
            data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
            data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
            data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
            data += "L" + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
            data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
            data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
          }
          break;
        case SegmentType2.CubicArc:
          data += "C" + (Math.round(segment.cpX1) + 0.5) + " " + (Math.round(segment.cpY1) + 0.5) + " " + (Math.round(segment.cpX2) + 0.5) + " " + (Math.round(segment.cpY2) + 0.5) + " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
          break;
        default:
          break;
      }
    });
    this.activePlaceholder.activeLayer.polylines.push(new Path(data, style));
  }
  polylinesBuffer(buffer) {
    var thisArg = this;
    buffer.loop(this, function(item) {
      if (item.length() > 0) {
        thisArg.polyline(item);
      }
    });
  }
  template(x, y, width, height, contentX, contentY, contentWidth, contentHeight, options, _hashCode, onRenderTemplate, uiHash, attr) {
    if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
      throw "No active placeholder or layer";
    }
    const left = x + contentX, top = y + contentY, templateWidth = contentWidth, templateHeight = contentHeight;
    let style = __spreadValues({
      "width": templateWidth + "px",
      "height": templateHeight + "px",
      "top": top + "px",
      "left": left + "px"
    }, attr);
    var context = __spreadProps(__spreadValues(__spreadValues({}, uiHash), options), {
      x: left,
      y: top,
      width: templateWidth,
      height: templateHeight
    });
    var templateRef = null;
    if (onRenderTemplate !== null) {
      templateRef = onRenderTemplate(context);
    }
    ;
    this.activePlaceholder.activeLayer.items.push(new Template2(options.templateType, options.templateName, templateRef, context, style));
  }
  getPxSize(value, base) {
    var result = value;
    if (typeof value === "string") {
      if (value.indexOf("pt") > 0) {
        result = parseInt(value, 10) * 96 / 72;
      } else if (value.indexOf("%") > 0) {
        result = parseFloat(value) / 100 * base;
      } else {
        result = parseInt(value, 10);
      }
    }
    return result;
  }
};
var AbstractTemplate = class {
  constructor(templateType, options) {
    this.options = __spreadProps(__spreadValues({}, options), {
      templateType
    });
  }
  template() {
    return this.options;
  }
  getHashCode() {
    return "";
  }
  render(data) {
    return null;
  }
};
var AnnotationLabelTemplate3 = class extends AbstractTemplate {
  constructor() {
    super("annotationLabelTemplate", {});
  }
};
var ButtonsTemplate2 = class extends AbstractTemplate {
  constructor() {
    super("dummyTemplate", {});
  }
  render(data) {
    const {
      onButtonsRender
    } = data;
    return onButtonsRender();
  }
};
var CheckBoxTemplate3 = class extends AbstractTemplate {
  constructor(selectCheckBoxLabel) {
    super("checkboxTemplate", {
      selectCheckBoxLabel
    });
  }
};
var CursorTemplate3 = class extends AbstractTemplate {
  constructor(options, templateConfig) {
    super("cursorTemplate", __spreadProps(__spreadValues({}, options), {
      templateConfig
    }));
  }
};
var CustomRenderTemplate3 = class extends AbstractTemplate {
  constructor(options, onRender) {
    super("dummyTemplate", options);
    this.render = onRender;
  }
};
var DotHighlightTemplate2 = class extends AbstractTemplate {
  constructor(options, templateConfig) {
    super("dotHighlightTemplate", __spreadProps(__spreadValues({}, options), {
      templateConfig
    }));
  }
};
var GroupTitleTemplate3 = class extends AbstractTemplate {
  constructor(options) {
    super("groupTitleTemplate", options);
  }
};
var HighlightTemplate3 = class extends AbstractTemplate {
  constructor(options, templateConfig) {
    super("highlightTemplate", __spreadProps(__spreadValues({}, options), {
      templateConfig
    }));
  }
};
var ItemTemplate3 = class extends AbstractTemplate {
  constructor(options, templateConfig) {
    super("itemTemplate", __spreadProps(__spreadValues({}, options), {
      templateConfig
    }));
  }
};
var LabelAnnotationTemplate3 = class extends AbstractTemplate {
  constructor() {
    super("labelAnnotationTemplate", {});
  }
};
var LevelBackgroundTemplate3 = class extends AbstractTemplate {
  constructor(options) {
    super("levelBackgroundTemplate", options);
  }
};
var LevelTitleTemplate3 = class extends AbstractTemplate {
  constructor(options, orientation) {
    var levelTitleOrientation = options.levelTitleOrientation;
    if (options.levelTitleOrientation == TextOrientationType2.Auto) {
      switch (orientation) {
        case OrientationType2.Top:
          levelTitleOrientation = TextOrientationType2.RotateRight;
          break;
        case OrientationType2.Bottom:
          levelTitleOrientation = TextOrientationType2.RotateRight;
          break;
        default:
          break;
      }
    }
    super("levelTitleTemplate", __spreadProps(__spreadValues({}, options), {
      orientation,
      levelTitleOrientation
    }));
  }
};
var UserTemplate3 = class extends AbstractTemplate {
  constructor(options, itemTemplate, onRender) {
    super("dummyTemplate", __spreadProps(__spreadValues({}, options), {
      itemTemplate
    }));
    this.render = onRender;
  }
};
var TaskManagerFactory2 = class {
  constructor(factory) {
    this.factory = factory;
  }
};
var RotatedText = class {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.orientation = TextOrientationType2.RotateRight;
    this.horizontalAlignment = HorizontalAlignmentType2.Center;
    this.verticalAlignment = VerticalAlignmentType2.Middle;
    this.hasVerticalAlignment = false;
    this.tableStyle = {};
    this.tdStyle = {};
    this.divStyle = {};
  }
  ngOnChanges() {
    const transform = this.getTransform(this.orientation);
    let size = {};
    if (this.orientation === TextOrientationType2.Horizontal) {
      size = {
        width: this.width + "px",
        height: this.height + "px",
        maxWidth: this.width + "px",
        maxHeight: this.height + "px"
      };
    } else {
      size = {
        width: this.height + "px",
        height: this.width + "px",
        maxWidth: this.height + "px",
        maxHeight: this.width + "px",
        left: Math.round(this.width / 2 - this.height / 2) + "px",
        top: Math.round(this.height / 2 - this.width / 2) + "px"
      };
    }
    var style = __spreadValues({
      position: "absolute",
      padding: 0,
      margin: 0,
      lineHeight: 1,
      textAlign: this.getHorizontalAlignment(this.horizontalAlignment),
      WebkitTransformOrigin: "center center",
      MozTransformOrigin: "center center",
      OTransformOrigin: "center center",
      msTransformOrigin: "center center",
      WebkitTransform: transform,
      MozTransform: transform,
      OTransform: transform,
      msTransform: transform,
      transform,
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
      tableLayout: "fixed"
    }, size);
    this.hasVerticalAlignment = this.verticalAlignment !== VerticalAlignmentType2.Top;
    this.tdStyle = {
      "verticalAlign": this.getVerticalAlignment(this.verticalAlignment),
      "padding": 0,
      "textOverflow": "ellipsis",
      "whiteSpace": "nowrap",
      "overflow": "hidden"
    };
    this.tableStyle = __spreadProps(__spreadValues({}, style), {
      borderCollapse: "collapse"
    });
    this.divStyle = style;
  }
  getTransform(orientation) {
    let result = "";
    switch (orientation) {
      case TextOrientationType2.RotateLeft:
        result = "rotate(-90deg)";
        break;
      case TextOrientationType2.RotateRight:
        result = "rotate(90deg)";
        break;
      default:
        break;
    }
    return result;
  }
  getHorizontalAlignment(horizontalAlignment) {
    let result = "";
    switch (horizontalAlignment) {
      case HorizontalAlignmentType2.Center:
        result = "center";
        break;
      case HorizontalAlignmentType2.Left:
        result = "left";
        break;
      case HorizontalAlignmentType2.Right:
        result = "right";
        break;
    }
    return result;
  }
  getVerticalAlignment(verticalAlignment) {
    let result = "";
    switch (verticalAlignment) {
      case VerticalAlignmentType2.Bottom:
        result = "bottom";
        break;
      case VerticalAlignmentType2.Middle:
        result = "middle";
        break;
      case VerticalAlignmentType2.Top:
        result = "top";
        break;
    }
    return result;
  }
};
RotatedText.ɵfac = function RotatedText_Factory(t) {
  return new (t || RotatedText)();
};
RotatedText.ɵcmp = ɵɵdefineComponent({
  type: RotatedText,
  selectors: [["rotated-text"]],
  inputs: {
    width: "width",
    height: "height",
    orientation: "orientation",
    horizontalAlignment: "horizontalAlignment",
    verticalAlignment: "verticalAlignment"
  },
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c0,
  decls: 7,
  vars: 3,
  consts: [["tableTemplate", ""], ["divTemplate", ""], ["content", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "ngStyle"], [4, "ngTemplateOutlet"]],
  template: function RotatedText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, RotatedText_div_0_Template, 1, 0, "div", 3)(1, RotatedText_ng_template_1_Template, 5, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, RotatedText_ng_template_3_Template, 2, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, RotatedText_ng_template_5_Template, 1, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const tableTemplate_r3 = ɵɵreference(2);
      const divTemplate_r4 = ɵɵreference(4);
      ɵɵproperty("ngIf", ctx.hasVerticalAlignment)("ngIfThen", tableTemplate_r3)("ngIfElse", divTemplate_r4);
    }
  },
  dependencies: [NgIf, NgStyle, NgTemplateOutlet]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RotatedText, [{
    type: Component,
    args: [{
      selector: "rotated-text",
      template: '<div *ngIf="hasVerticalAlignment; then tableTemplate; else divTemplate"></div>\r\n<ng-template #tableTemplate>\r\n  <table [ngStyle]="tableStyle">\r\n    <tbody>\r\n      <tr>\r\n        <td [ngStyle]="tdStyle">\r\n          <ng-container *ngTemplateOutlet="content"></ng-container>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</ng-template>\r\n<ng-template #divTemplate>\r\n  <div [ngStyle]="divStyle">\r\n    <ng-container *ngTemplateOutlet="content"></ng-container>\r\n  </div>\r\n</ng-template>\r\n<ng-template #content><ng-content></ng-content></ng-template>',
      styles: [""]
    }]
  }], null, {
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    horizontalAlignment: [{
      type: Input
    }],
    verticalAlignment: [{
      type: Input
    }]
  });
})();
var OrgItemConfig2 = class {
  constructor(config = {}) {
    this.id = null;
    this.parent = null;
    this.title = null;
    this.description = null;
    this.image = null;
    this.context = null;
    this.itemTitleColor = "#4169e1";
    this.minimizedItemShapeType = null;
    this.groupTitle = null;
    this.groupTitleColor = "#4169e1";
    this.isVisible = true;
    this.isActive = true;
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.hasButtons = Enabled2.Auto;
    this.itemType = ItemType2.Regular;
    this.adviserPlacementType = AdviserPlacementType2.Auto;
    this.childrenPlacementType = ChildrenPlacementType2.Auto;
    this.levelOffset = null;
    this.placeAssistantsAboveChildren = Enabled2.Auto;
    this.placeAdvisersAboveChildren = Enabled2.Auto;
    this.templateName = null;
    this.showCallout = Enabled2.Auto;
    this.calloutTemplateName = null;
    this.label = null;
    this.showLabel = Enabled2.Auto;
    this.labelSize = null;
    this.labelOrientation = TextOrientationType2.Auto;
    Object.assign(this, config);
  }
};
var ItemComponent = class {
  constructor() {
    this.royalBlue = "#000080";
    this.itemTitleFirstFontColor = "#ffffff";
    this.itemTitleSecondFontColor = "#000080";
    this.itemConfig = new OrgItemConfig2();
    this.backgroundColor = "#4169e1";
    this.color = "#ffffff";
  }
  ngOnChanges(changes) {
    this.backgroundColor = this.itemConfig.itemTitleColor || this.royalBlue;
    this.color = highestContrast(this.backgroundColor, this.itemTitleSecondFontColor, this.itemTitleFirstFontColor);
  }
};
ItemComponent.ɵfac = function ItemComponent_Factory(t) {
  return new (t || ItemComponent)();
};
ItemComponent.ɵcmp = ɵɵdefineComponent({
  type: ItemComponent,
  selectors: [["bp-item"]],
  inputs: {
    itemTitleFirstFontColor: "itemTitleFirstFontColor",
    itemTitleSecondFontColor: "itemTitleSecondFontColor",
    itemConfig: "itemConfig"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 8,
  vars: 10,
  consts: [[1, "item", "corner-all", "item-frame", "default-template"], [1, "title-background", "item", "corner-all", "item-frame", 3, "ngStyle"], [1, "item", "item-title", 3, "ngStyle"], [1, "photo-frame", "item"], [1, "photo", 3, "src", "alt"], [1, "item", "description"]],
  template: function ItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
      ɵɵtext(3);
      ɵɵelementEnd()();
      ɵɵelementStart(4, "div", 3);
      ɵɵelement(5, "img", 4);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5);
      ɵɵtext(7);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngStyle", ɵɵpureFunction1(6, _c1, ctx.backgroundColor));
      ɵɵadvance();
      ɵɵproperty("ngStyle", ɵɵpureFunction1(8, _c2, ctx.color));
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.itemConfig.title);
      ɵɵadvance(2);
      ɵɵproperty("src", ctx.itemConfig.image, ɵɵsanitizeUrl)("alt", ctx.itemConfig.title);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.itemConfig.description);
    }
  },
  dependencies: [NgStyle],
  styles: [".item[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.corner-all[_ngcontent-%COMP%]{border-radius:4px}.item-frame[_ngcontent-%COMP%]{border:1px solid #dddddd;background:#eeeeee;color:#333}.default-template[_ngcontent-%COMP%]{width:100%;height:100%;left:-1px;top:-1px}.item-title[_ngcontent-%COMP%]{text-overflow:ellipsis;-o-text-overflow:ellipsis;white-space:nowrap;text-align:left;font-size:14px;line-height:16px;color:#fff;padding:0;top:2px;left:2px;right:2px;height:16px}.title-background[_ngcontent-%COMP%]{top:2px;left:2px;right:2px;height:20px}.photo-frame[_ngcontent-%COMP%]{border:1px solid #cccccc;background:#f6f6f6;color:#1c94c4;top:26px;left:2px;width:50px;height:60px}.photo[_ngcontent-%COMP%]{height:60px;width:50px}.description[_ngcontent-%COMP%]{overflow:hidden;text-align:left;top:26px;left:56px;right:2px;bottom:2px;font-size:12px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemComponent, [{
    type: Component,
    args: [{
      selector: "bp-item",
      template: '<div class="item corner-all item-frame default-template">\r\n  <div class="title-background item corner-all item-frame" [ngStyle]="{backgroundColor}">\r\n    <div class="item item-title" [ngStyle]="{color}">{{itemConfig.title}}</div>\r\n  </div>\r\n  <div class="photo-frame item">\r\n    <img class="photo" [src]="itemConfig.image" [alt]="itemConfig.title" />\r\n  </div>\r\n  <div class="item description">{{itemConfig.description}}</div>\r\n</div>',
      styles: [".item{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.corner-all{border-radius:4px}.item-frame{border:1px solid #dddddd;background:#eeeeee;color:#333}.default-template{width:100%;height:100%;left:-1px;top:-1px}.item-title{text-overflow:ellipsis;-o-text-overflow:ellipsis;white-space:nowrap;text-align:left;font-size:14px;line-height:16px;color:#fff;padding:0;top:2px;left:2px;right:2px;height:16px}.title-background{top:2px;left:2px;right:2px;height:20px}.photo-frame{border:1px solid #cccccc;background:#f6f6f6;color:#1c94c4;top:26px;left:2px;width:50px;height:60px}.photo{height:60px;width:50px}.description{overflow:hidden;text-align:left;top:26px;left:56px;right:2px;bottom:2px;font-size:12px}\n"]
    }]
  }], null, {
    itemTitleFirstFontColor: [{
      type: Input
    }],
    itemTitleSecondFontColor: [{
      type: Input
    }],
    itemConfig: [{
      type: Input
    }]
  });
})();
var CheckboxComponent = class {
  constructor() {
    this.id = null;
    this.label = "Selected";
    this.isSelected = false;
    this.onChange = () => null;
    this.borderWidth = "1px";
  }
};
CheckboxComponent.ɵfac = function CheckboxComponent_Factory(t) {
  return new (t || CheckboxComponent)();
};
CheckboxComponent.ɵcmp = ɵɵdefineComponent({
  type: CheckboxComponent,
  selectors: [["bp-checkbox"]],
  inputs: {
    id: "id",
    label: "label",
    isSelected: "isSelected"
  },
  decls: 4,
  vars: 4,
  consts: [[1, "checkbox-div"], ["type", "checkbox", "name", "checkbox", 1, "checkbox-input", 3, "change", "checked"], ["name", "selectiontext", 1, "checkbox-span"]],
  template: function CheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "input", 1);
      ɵɵlistener("change", function CheckboxComponent_Template_input_change_1_listener() {
        return ctx.onChange;
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("checked", ctx.isSelected);
      ɵɵattribute("data-id", ctx.id);
      ɵɵadvance();
      ɵɵattribute("data-id", ctx.id);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.label, " ");
    }
  },
  styles: [".checkbox-div[_ngcontent-%COMP%]{text-align:left}.checkbox-input[_ngcontent-%COMP%]{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0}.checkbox-span[_ngcontent-%COMP%]{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0 0 0 2px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxComponent, [{
    type: Component,
    args: [{
      selector: "bp-checkbox",
      template: `<div class="checkbox-div">
    <input type="checkbox" name="checkbox" class="checkbox-input" [checked]="isSelected" (change)="onChange" [attr.data-id]="id" />
      <span name="selectiontext" class="checkbox-span" [attr.data-id]="id" >
        {{label}}
      </span>
    </div>`,
      styles: [".checkbox-div{text-align:left}.checkbox-input{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0}.checkbox-span{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0 0 0 2px}\n"]
    }]
  }], null, {
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }]
  });
})();
var GroupTitleOptions = class {
  constructor(config = {}) {
    this.groupTitleFontSize = "12px";
    this.groupTitleFontFamily = "Arial";
    this.groupTitleFontWeight = "normal";
    this.groupTitleFontStyle = "normal";
    this.itemTitleSecondFontColor = "#000080";
    this.itemTitleFirstFontColor = "#ffffff";
    this.groupTitleOrientation = TextOrientationType2.RotateRight;
    this.groupTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.groupTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.groupTitleColor = "#4169e1";
    Object.assign(this, config);
  }
};
var GroupTitleComponent = class {
  constructor() {
    this.options = new GroupTitleOptions();
    this.itemConfig = new OrgItemConfig2();
    this.width = 0;
    this.height = 0;
    this.divStyle = null;
    this.label = "";
  }
  ngOnChanges(changes) {
    const backgroundColor = this.itemConfig.groupTitleColor || this.options.groupTitleColor;
    const color = highestContrast(backgroundColor, this.options.itemTitleSecondFontColor, this.options.itemTitleFirstFontColor);
    this.divStyle = {
      backgroundColor,
      color,
      fontSize: this.options.groupTitleFontSize,
      fontFamily: this.options.groupTitleFontFamily,
      fontWeight: this.options.groupTitleFontWeight,
      fontStyle: this.options.groupTitleFontStyle
    };
    this.label = (this.itemConfig.groupTitle || "").replace("\n", "<br/>");
  }
};
GroupTitleComponent.ɵfac = function GroupTitleComponent_Factory(t) {
  return new (t || GroupTitleComponent)();
};
GroupTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: GroupTitleComponent,
  selectors: [["bp-group-title"]],
  inputs: {
    options: "options",
    itemConfig: "itemConfig",
    width: "width",
    height: "height"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 3,
  vars: 7,
  consts: [[1, "group-title", 3, "ngStyle"], [3, "width", "height", "orientation", "horizontalAlignment", "verticalAlignment"]],
  template: function GroupTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "rotated-text", 1);
      ɵɵtext(2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ctx.divStyle);
      ɵɵadvance();
      ɵɵproperty("width", ctx.width)("height", ctx.height)("orientation", ctx.options.groupTitleOrientation)("horizontalAlignment", ctx.options.groupTitleHorizontalAlignment)("verticalAlignment", ctx.options.groupTitleVerticalAlignment);
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.label);
    }
  },
  dependencies: [RotatedText, NgStyle],
  styles: [".group-title[_ngcontent-%COMP%]{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupTitleComponent, [{
    type: Component,
    args: [{
      selector: "bp-group-title",
      template: '<div class="group-title" [ngStyle]="divStyle">\r\n  <rotated-text\r\n    [width]="width"\r\n    [height]="height"\r\n    [orientation]="options.groupTitleOrientation"\r\n    [horizontalAlignment]="options.groupTitleHorizontalAlignment"\r\n    [verticalAlignment]="options.groupTitleVerticalAlignment"\r\n  >{{label}}</rotated-text>\r\n</div>\r\n',
      styles: [".group-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"]
    }]
  }], null, {
    options: [{
      type: Input
    }],
    itemConfig: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }]
  });
})();
var TemplateConfig2 = class {
  constructor(config = {}) {
    this.name = null;
    this.isActive = true;
    this.itemSize = new Size2(120, 100);
    this.itemBorderWidth = 1;
    this.itemTemplate = null;
    this.minimizedItemShapeType = null;
    this.minimizedItemSize = new Size2(4, 4);
    this.minimizedItemCornerRadius = null;
    this.minimizedItemLineWidth = 1;
    this.minimizedItemBorderColor = null;
    this.minimizedItemLineType = LineType2.Solid;
    this.minimizedItemFillColor = null;
    this.minimizedItemOpacity = 1;
    this.highlightPadding = new Thickness2(2, 2, 2, 2);
    this.highlightBorderWidth = 1;
    this.highlightTemplate = null;
    this.cursorPadding = new Thickness2(3, 3, 3, 3);
    this.cursorBorderWidth = 2;
    this.cursorTemplate = null;
    this.buttonsTemplate = null;
    Object.assign(this, config);
  }
};
var CursorComponent = class {
  constructor() {
    this.templateConfig = new TemplateConfig2();
    this.borderWidth = "1px";
    this.width = "0px";
    this.height = "0px";
  }
  ngOnChanges(changes) {
    const {
      cursorPadding,
      itemSize,
      cursorBorderWidth
    } = this.templateConfig;
    this.width = itemSize.width + cursorPadding.left + cursorPadding.right + "px", this.height = itemSize.height + cursorPadding.top + cursorPadding.bottom + "px", this.borderWidth = cursorBorderWidth + "px";
  }
};
CursorComponent.ɵfac = function CursorComponent_Factory(t) {
  return new (t || CursorComponent)();
};
CursorComponent.ɵcmp = ɵɵdefineComponent({
  type: CursorComponent,
  selectors: [["bp-cursor"]],
  inputs: {
    templateConfig: "templateConfig"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 5,
  consts: [[1, "cursor", 3, "ngStyle"]],
  template: function CursorComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ɵɵpureFunction3(1, _c3, ctx.width, ctx.height, ctx.borderWidth));
    }
  },
  dependencies: [NgStyle],
  styles: [".cursor[_ngcontent-%COMP%]{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:2px solid #fbd850;color:#eb8f00;width:100%;height:100%;left:-2px;top:-2px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CursorComponent, [{
    type: Component,
    args: [{
      selector: "bp-cursor",
      template: '<div class="cursor" [ngStyle]="{width, height, borderWidth}"></div>',
      styles: [".cursor{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:2px solid #fbd850;color:#eb8f00;width:100%;height:100%;left:-2px;top:-2px}\n"]
    }]
  }], null, {
    templateConfig: [{
      type: Input
    }]
  });
})();
var HighlightComponent = class {
  constructor() {
    this.templateConfig = new TemplateConfig2();
    this.borderWidth = "1px";
  }
  ngOnChanges(changes) {
    const {
      highlightBorderWidth
    } = this.templateConfig;
    this.borderWidth = highlightBorderWidth + "px";
  }
};
HighlightComponent.ɵfac = function HighlightComponent_Factory(t) {
  return new (t || HighlightComponent)();
};
HighlightComponent.ɵcmp = ɵɵdefineComponent({
  type: HighlightComponent,
  selectors: [["bp-highlight"]],
  inputs: {
    templateConfig: "templateConfig"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 3,
  consts: [[1, "highlight", 3, "ngStyle"]],
  template: function HighlightComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ɵɵpureFunction1(1, _c4, ctx.borderWidth));
    }
  },
  dependencies: [NgStyle],
  styles: [".highlight[_ngcontent-%COMP%]{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:-1px;top:-1px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighlightComponent, [{
    type: Component,
    args: [{
      selector: "bp-highlight",
      template: '<div class="highlight" [ngStyle]="{borderWidth}"></div>',
      styles: [".highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:-1px;top:-1px}\n"]
    }]
  }], null, {
    templateConfig: [{
      type: Input
    }]
  });
})();
var DotHighlightComponent = class {
  constructor() {
    this.templateConfig = new TemplateConfig2();
    this.divStyle = {};
  }
  ngOnChanges(changes) {
    const {
      minimizedItemCornerRadius,
      highlightPadding,
      highlightBorderWidth,
      minimizedItemSize
    } = this.templateConfig;
    let radius = 0;
    if (minimizedItemCornerRadius === null) {
      radius = Math.max(minimizedItemSize.width / 2, minimizedItemSize.height / 2) + highlightPadding.left;
    } else {
      radius = minimizedItemCornerRadius + highlightPadding.left;
    }
    this.divStyle = {
      borderWidth: highlightBorderWidth + "px",
      left: -highlightBorderWidth + "px",
      top: -highlightBorderWidth + "px",
      "-moz-border-radius": radius + "px",
      "-webkit-border-radius": radius + "px",
      "-khtml-border-radius": radius + "px",
      "border-radius": radius + "px"
    };
  }
};
DotHighlightComponent.ɵfac = function DotHighlightComponent_Factory(t) {
  return new (t || DotHighlightComponent)();
};
DotHighlightComponent.ɵcmp = ɵɵdefineComponent({
  type: DotHighlightComponent,
  selectors: [["bp-dot-highlight"]],
  inputs: {
    templateConfig: "templateConfig"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [[1, "dot-highlight", 3, "ngStyle"]],
  template: function DotHighlightComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ctx.divStyle);
    }
  },
  dependencies: [NgStyle],
  styles: [".dot-highlight[_ngcontent-%COMP%]{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:0px;top:0px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DotHighlightComponent, [{
    type: Component,
    args: [{
      selector: "bp-dot-highlight",
      template: '<div class="dot-highlight" [ngStyle]="divStyle"></div>',
      styles: [".dot-highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:0px;top:0px}\n"]
    }]
  }], null, {
    templateConfig: [{
      type: Input
    }]
  });
})();
var LevelAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.Level;
    this.levels = [];
    this.title = null;
    this.titleFontColor = null;
    this.titleColor = null;
    this.offset = new Thickness2(0, 0, 0, 0);
    this.lineWidth = new Thickness2(0, 0, 0, 0);
    this.opacity = 1;
    this.borderColor = null;
    this.fillColor = "#D4D4D4";
    this.lineType = LineType2.Solid;
    Object.assign(this, config);
  }
};
var LevelTitleOptions = class {
  constructor(config = {}) {
    this.levelTitleFontSize = "12px";
    this.levelTitleFontFamily = "Arial";
    this.levelTitleFontWeight = "normal";
    this.levelTitleFontStyle = "normal";
    this.levelTitleFontColor = "#ffffff";
    this.levelTitleOrientation = TextOrientationType2.Auto;
    this.levelTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.levelTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.levelTitleColor = "#4169e1";
    Object.assign(this, config);
  }
};
var LevelTitleComponent = class {
  constructor() {
    this.options = new LevelTitleOptions();
    this.annotationConfig = new LevelAnnotationConfig2();
    this.width = 0;
    this.height = 0;
    this.divStyle = null;
    this.label = "";
  }
  ngOnChanges(changes) {
    const backgroundColor = this.annotationConfig.titleColor || this.options.levelTitleColor;
    const color = this.annotationConfig.titleFontColor || this.options.levelTitleFontColor;
    this.divStyle = {
      backgroundColor,
      color,
      fontSize: this.options.levelTitleFontSize,
      fontFamily: this.options.levelTitleFontFamily,
      fontWeight: this.options.levelTitleFontWeight,
      fontStyle: this.options.levelTitleFontStyle
    };
    this.label = (this.annotationConfig.title || "").replace("\n", "<br/>");
  }
};
LevelTitleComponent.ɵfac = function LevelTitleComponent_Factory(t) {
  return new (t || LevelTitleComponent)();
};
LevelTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: LevelTitleComponent,
  selectors: [["bp-level-title"]],
  inputs: {
    options: "options",
    annotationConfig: "annotationConfig",
    width: "width",
    height: "height"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 3,
  vars: 7,
  consts: [[1, "level-title", 3, "ngStyle"], [3, "width", "height", "orientation", "horizontalAlignment", "verticalAlignment"]],
  template: function LevelTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "rotated-text", 1);
      ɵɵtext(2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ctx.divStyle);
      ɵɵadvance();
      ɵɵproperty("width", ctx.width)("height", ctx.height)("orientation", ctx.options.levelTitleOrientation)("horizontalAlignment", ctx.options.levelTitleHorizontalAlignment)("verticalAlignment", ctx.options.levelTitleVerticalAlignment);
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.label);
    }
  },
  dependencies: [RotatedText, NgStyle],
  styles: [".level-title[_ngcontent-%COMP%]{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LevelTitleComponent, [{
    type: Component,
    args: [{
      selector: "bp-level-title",
      template: '<div class="level-title" [ngStyle]="divStyle">\r\n  <rotated-text\r\n    [width]="width"\r\n    [height]="height"\r\n    [orientation]="options.levelTitleOrientation"\r\n    [horizontalAlignment]="options.levelTitleHorizontalAlignment"\r\n    [verticalAlignment]="options.levelTitleVerticalAlignment"\r\n  >{{label}}</rotated-text>\r\n</div>',
      styles: [".level-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"]
    }]
  }], null, {
    options: [{
      type: Input
    }],
    annotationConfig: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }]
  });
})();
function getBorderStyle2(lineType) {
  var result = null;
  switch (lineType) {
    case LineType2.Dotted:
      result = "dotted";
      break;
    case LineType2.Dashed:
      result = "dashed";
      break;
    default:
      result = "solid";
      break;
  }
  return result;
}
var LevelBackgroundComponent = class {
  constructor() {
    this.annotationConfig = new LevelAnnotationConfig2();
    this.divStyle = {};
  }
  ngOnChanges(changes) {
    this.divStyle = {
      opacity: this.annotationConfig.opacity,
      borderColor: this.annotationConfig.borderColor,
      backgroundColor: this.annotationConfig.fillColor,
      borderWidth: this.annotationConfig.lineWidth.toString(),
      borderStyle: getBorderStyle2(this.annotationConfig.lineType)
    };
  }
};
LevelBackgroundComponent.ɵfac = function LevelBackgroundComponent_Factory(t) {
  return new (t || LevelBackgroundComponent)();
};
LevelBackgroundComponent.ɵcmp = ɵɵdefineComponent({
  type: LevelBackgroundComponent,
  selectors: [["bp-level-background"]],
  inputs: {
    annotationConfig: "annotationConfig"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [[1, "level-background", 3, "ngStyle"]],
  template: function LevelBackgroundComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ctx.divStyle);
    }
  },
  dependencies: [NgStyle],
  styles: [".level-background[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LevelBackgroundComponent, [{
    type: Component,
    args: [{
      selector: "bp-level-background",
      template: '<div class="level-background" [ngStyle]="divStyle"></div>',
      styles: [".level-background{position:absolute;width:100%;height:100%}\n"]
    }]
  }], null, {
    annotationConfig: [{
      type: Input
    }]
  });
})();
var LayoutOptions = class {
  constructor(config = {}) {
    this.autoSize = false;
    this.controlSize = new Size2();
    this.scale = 1;
    this.frameMousePanelRect = new Rect2();
    this.framePlaceholderSize = new Size2();
    this.titlesMousePanelRect = new Rect2();
    this.titlesPlaceholderSize = new Size2();
    this.scrollPanelRect = new Rect2();
    this.mousePanelSize = new Size2();
    this.placeholderSize = new Size2();
    Object.assign(this, config);
  }
};
var BaseDiagramState = class {
  constructor() {
    this.viewportSize = new Size2(0, 0);
    this.contentPosition = new Point2(0, 0);
    this.centerOnCursor = true;
    this.highlightItem = null;
    this.cursorItem = null;
    this.selectedItems = [];
  }
};
var BaseDiagramComponent = class {
  constructor(host, zone, taskManagerFactory) {
    this.host = host;
    this.zone = zone;
    this.centerOnCursor = true;
    this.state = new BaseDiagramState();
    this.layoutOptions = new LayoutOptions();
    this.timer = null;
    this.templatesHash = {};
    this.placeholder = null;
    this.framePlaceholder = null;
    this.titlesPlaceholder = null;
    this.calloutPlaceholder = null;
    this.controlPanelStyle = {};
    this.frameMousePanelStyle = {};
    this.framePlaceholderStyle = {};
    this.titlesMousePanelStyle = {};
    this.titlesPlaceholderStyle = {};
    this.scrollPanelStyle = {};
    this.placeholderOffset = void 0;
    this.mousePanelStyle = {};
    this.placeholderStyle = {};
    this.calloutPlaceholderStyle = {};
    this.taskManagerFactory = taskManagerFactory;
    this.graphics = new Graphics2(new Size2(0, 0));
    var templates = {
      AnnotationLabelTemplate: AnnotationLabelTemplate3,
      ButtonsTemplate: ButtonsTemplate2,
      CheckBoxTemplate: CheckBoxTemplate3,
      CursorTemplate: CursorTemplate3,
      DotHighlightTemplate: DotHighlightTemplate2,
      GroupTitleTemplate: GroupTitleTemplate3,
      HighlightTemplate: HighlightTemplate3,
      ItemTemplate: ItemTemplate3,
      UserTemplate: UserTemplate3,
      CustomRenderTemplate: CustomRenderTemplate3,
      LabelAnnotationTemplate: LabelAnnotationTemplate3,
      LevelTitleTemplate: LevelTitleTemplate3,
      LevelBackgroundTemplate: LevelBackgroundTemplate3
    };
    this.tasks = taskManagerFactory.factory(this.getOptions.bind(this), this.getGraphics.bind(this), this.getLayout.bind(this), this.setLayout.bind(this), templates);
    this.layoutOptions = new LayoutOptions();
  }
  ngAfterViewInit() {
    var onSizeChanged = this.onSizeChanged.bind(this);
    this.observer = new ResizeObserver(() => this.zone.run(() => onSizeChanged()));
    this.observer.observe(this.controlPanelRef.nativeElement);
    this.fixPixelAlignment();
  }
  _onHighlightChanging(event, itemId, newItemId) {
  }
  _onHighlightChanged(eventArgs) {
  }
  _onCursorChanging(event, itemId, newItemId) {
  }
  _onCursorChanged(eventArgs) {
  }
  _onSelectionChanging(event, selectedItems, newSelectedItems) {
  }
  _onSelectionChanged(eventArgs) {
  }
  onItemRender(data) {
    const {
      templateName
    } = data;
    const template = this.templatesHash[templateName];
    return template.itemTemplate;
  }
  onHighlightRender(data) {
    const {
      templateName
    } = data;
    const template = this.templatesHash[templateName];
    return template.highlightTemplate;
  }
  onCursorRender(data) {
    const {
      templateName
    } = data;
    const template = this.templatesHash[templateName];
    return template.cursorTemplate;
  }
  getOptions() {
    const {
      config
    } = this.state;
    const templates = config.templates || [];
    this.templatesHash = {};
    templates.forEach((template) => {
      this.templatesHash[template.name] = template;
    });
    const effectiveTemplates = templates.map((template) => {
      const {
        buttonsTemplate
      } = template;
      return __spreadProps(__spreadValues({}, template), {
        onButtonsRender: !buttonsTemplate ? null : () => buttonsTemplate
      });
    });
    const {
      highlightItem,
      cursorItem,
      selectedItems
    } = this.state;
    return __spreadProps(__spreadValues({}, config), {
      templates: effectiveTemplates,
      highlightItem,
      cursorItem,
      selectedItems,
      onItemRender: this.onItemRender.bind(this),
      onCursorRender: this.onCursorRender.bind(this),
      onHighlightRender: this.onHighlightRender.bind(this),
      onGroupTitleRender: !config.groupTitleTemplate ? null : () => config.groupTitleTemplate,
      onLevelBackgroundRender: !config.levelBackgroundTemplate ? null : () => config.levelBackgroundTemplate,
      onLevelTitleRender: !config.levelTitleTemplate ? null : () => config.levelTitleTemplate,
      onButtonsRender: !config.buttonsTemplate ? null : () => config.buttonsTemplate
    });
  }
  getGraphics() {
    return this.graphics;
  }
  getLayout() {
    var centerOnCursor = this.state.centerOnCursor;
    var viewportSize = this.state.viewportSize;
    var contentPosition = this.state.contentPosition;
    return {
      forceCenterOnCursor: centerOnCursor,
      scrollPanelSize: new Size2(viewportSize.width, viewportSize.height),
      placeholderOffset: new Point2(contentPosition.x, contentPosition.y)
    };
  }
  setLayout(layoutOptions) {
    const {
      autoSize,
      // resize control if true
      controlSize,
      // Sets control Size in auto scale mode
      scale,
      // scale is needed for scale transform CSS creation
      frameMousePanelRect,
      framePlaceholderSize,
      // the frame content size before CSS Scale Transform applied
      titlesMousePanelRect,
      titlesPlaceholderSize,
      // Titles size before CSS Scale Transform applied
      scrollPanelRect,
      mousePanelSize,
      // Content mouse panel size
      placeholderSize
      // Content size before CSS Scale Transform applied
    } = layoutOptions;
    this.layoutOptions = new LayoutOptions({
      autoSize,
      controlSize: new Size2(controlSize.width, controlSize.height),
      scale,
      frameMousePanelRect: new Rect2(frameMousePanelRect.x, frameMousePanelRect.y, frameMousePanelRect.width, frameMousePanelRect.height),
      framePlaceholderSize: new Size2(framePlaceholderSize.width, framePlaceholderSize.height),
      titlesMousePanelRect: new Rect2(titlesMousePanelRect.x, titlesMousePanelRect.y, titlesMousePanelRect.width, titlesMousePanelRect.height),
      titlesPlaceholderSize: new Size2(titlesPlaceholderSize.width, titlesPlaceholderSize.height),
      scrollPanelRect: new Rect2(scrollPanelRect.x, scrollPanelRect.y, scrollPanelRect.width, scrollPanelRect.height),
      mousePanelSize: new Size2(mousePanelSize.width, mousePanelSize.height),
      placeholderSize: new Size2(placeholderSize.width, placeholderSize.height)
    });
  }
  fixPixelAlignment() {
    const {
      nativeElement
    } = this.controlPanelRef;
    var pixelAlignmentFix = getFixOfPixelAlignment(nativeElement);
    nativeElement.style.marginLeft = pixelAlignmentFix.width + "px";
    nativeElement.style.marginTop = pixelAlignmentFix.height + "px";
  }
  onSizeChanged() {
    const {
      width,
      height
    } = getInnerSize(this.controlPanelRef.nativeElement);
    this.setState({
      viewportSize: new Size2(width, height),
      centerOnCursor: true
    });
  }
  onScroll(event) {
    if (this.timer == null) {
      this.timer = window.setTimeout(this.onRefreshViewport.bind(this), 100);
    }
  }
  onRefreshViewport() {
    window.clearTimeout(this.timer);
    this.timer = null;
    const {
      scrollTop,
      scrollLeft
    } = this.scrollPanelRef.nativeElement;
    this.setState({
      contentPosition: new Point2(Math.floor(scrollLeft), Math.floor(scrollTop)),
      centerOnCursor: false
    });
  }
  onFrameMouseMove(event) {
    const placeholderOffset = getElementOffset(this.frameMousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, projectItemsToFrameTask = this.tasks.getTask("ProjectItemsToFrameTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask");
    if (highlightItemOptionTask.hasHighlightEnabled()) {
      const itemId = projectItemsToFrameTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
      this.setHighlightItem(event, itemId);
    }
  }
  onFrameClick(event) {
    const placeholderOffset = getElementOffset(this.frameMousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, projectItemsToFrameTask = this.tasks.getTask("ProjectItemsToFrameTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), newCursorItemId = projectItemsToFrameTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
    if (newCursorItemId !== null) {
      if (cursorItemOptionTask.hasCursorEnabled()) {
        this.setCursorItem(event, newCursorItemId);
        this.controlPanelRef.nativeElement.focus();
      }
    }
  }
  onMouseMove(event) {
    const placeholderOffset = getElementOffset(this.mousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, createTransformTask = this.tasks.getTask("CreateTransformTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask");
    if (highlightItemOptionTask.hasHighlightEnabled()) {
      const itemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
      this.setHighlightItem(event, itemId);
    }
  }
  getEventArgs(oldTreeItemId, newTreeItemId, name2 = null) {
    var result = {}, combinedContextsTask = this.tasks.getTask("CombinedContextsTask"), alignDiagramTask = this.tasks.getTask("AlignDiagramTask"), oldItemConfig = combinedContextsTask.getConfig(oldTreeItemId), newItemConfig = combinedContextsTask.getConfig(newTreeItemId), itemPosition, offset, panelOffset;
    if (oldItemConfig && oldItemConfig.id != null) {
      result.oldContext = oldItemConfig;
    }
    if (newItemConfig && newItemConfig.id != null) {
      result.context = newItemConfig;
      if (newItemConfig.parent !== null) {
        result.parentItem = combinedContextsTask.getConfig(newItemConfig.parent);
      }
      panelOffset = getElementOffset(this.mousePanelRef.nativeElement);
      offset = getElementOffset(this.scrollPanelRef.nativeElement);
      itemPosition = alignDiagramTask.getItemPosition(newTreeItemId);
      result.position = new Rect2(itemPosition.actualPosition).translate(panelOffset.left, panelOffset.top).translate(-offset.left, -offset.top);
    }
    if (name2 != null) {
      result.name = name2;
    }
    return result;
  }
  setHighlightItem(event, newHighlightItemId) {
    let eventArgs, cancel = false;
    const {
      highlightItem
    } = this.state;
    if (newHighlightItemId !== highlightItem) {
      eventArgs = this._onHighlightChanging(event, highlightItem, newHighlightItemId);
      if (!eventArgs.cancel) {
        this.setState({
          highlightItem: newHighlightItemId
        });
        this._onHighlightChanged(eventArgs);
      }
    }
  }
  setCursorItem(event, newCursorItemId) {
    let eventArgs, cancel = false;
    const {
      cursorItem
    } = this.state;
    if (newCursorItemId !== cursorItem) {
      eventArgs = this._onCursorChanging(event, cursorItem, newCursorItemId);
      if (!eventArgs.cancel) {
        this.setState({
          cursorItem: newCursorItemId,
          centerOnCursor: true
        });
        this._onCursorChanged(eventArgs);
      }
    }
  }
  onClick(event) {
    var placeholderOffset = getElementOffset(this.mousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, createTransformTask = this.tasks.getTask("CreateTransformTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), newCursorItemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
    var target = event.target;
    if (newCursorItemId !== null) {
      if (target.getAttribute("name") === "checkbox" || target.getAttribute("name") === "selectiontext") {
      } else {
        if (cursorItemOptionTask.hasCursorEnabled()) {
          this.setCursorItem(event, newCursorItemId);
          this.controlPanelRef.nativeElement.focus();
        }
      }
    }
  }
  onCheckboxChange(event) {
    let {
      selectedItems
    } = this.state;
    let newSelectedItems = [];
    const target = event.target;
    var itemId = target.getAttribute("data-id");
    const checked = target.checked;
    let cancel = false;
    if (itemId != null) {
      if (checked) {
        newSelectedItems = [...selectedItems, itemId];
      } else {
        newSelectedItems = selectedItems.filter((id) => id != itemId);
      }
      var eventArgs = this._onSelectionChanging(event, selectedItems, newSelectedItems);
      if (!eventArgs.cancel) {
        this.setState({
          selectedItems: newSelectedItems
        });
        this._onSelectionChanged(eventArgs);
      }
    }
  }
  onKeyDown(event) {
    var highlightItemTask = this.tasks.getTask("HighlightItemTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), cursorItemTask = this.tasks.getTask("CursorItemTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), alignDiagramTask = this.tasks.getTask("AlignDiagramTask"), createTransformTask = this.tasks.getTask("CreateTransformTask"), transform = createTransformTask.getTransform(), navigationItem = null, newNavigationItem, direction = null, accepted;
    if (highlightItemOptionTask.hasHighlightEnabled() && cursorItemOptionTask.hasCursorEnabled()) {
      navigationItem = highlightItemTask.getHighlightTreeItem();
      if (navigationItem === null) {
        navigationItem = cursorItemTask.getCursorTreeItem();
      }
    } else if (highlightItemOptionTask.hasHighlightEnabled()) {
      navigationItem = highlightItemTask.getHighlightTreeItem();
    } else if (cursorItemOptionTask.hasCursorEnabled()) {
      navigationItem = cursorItemTask.getCursorTreeItem();
    }
    if (navigationItem != null) {
      switch (event.which) {
        case 13:
          if (cursorItemOptionTask.hasCursorEnabled()) {
            this.setCursorItem(event, navigationItem);
            event.preventDefault();
            this.controlPanelRef.nativeElement.focus();
          }
          break;
        case 40:
          direction = OrientationType2.Bottom;
          break;
        case 38:
          direction = OrientationType2.Top;
          break;
        case 37:
          direction = OrientationType2.Left;
          break;
        case 39:
          direction = OrientationType2.Right;
          break;
        default:
          break;
      }
      if (direction != null) {
        accepted = false;
        while (!accepted) {
          accepted = true;
          direction = transform.getOrientation(direction);
          newNavigationItem = alignDiagramTask.getNextItem(navigationItem, direction);
          if (newNavigationItem != null) {
            event.preventDefault();
            if (highlightItemOptionTask.hasHighlightEnabled()) {
              this.setHighlightItem(event, newNavigationItem);
            } else if (cursorItemOptionTask.hasCursorEnabled()) {
              this.setCursorItem(event, newNavigationItem);
            }
          }
        }
        this.controlPanelRef.nativeElement.focus();
      }
    }
  }
  setState(newState = {}) {
    this.state = __spreadValues(__spreadValues({}, this.state), newState);
    this.render();
  }
  ngOnInit() {
    this.render();
  }
  render() {
    this.tasks.process("OptionsTask", null, false);
    const {
      placeholder,
      calloutplaceholder: calloutPlaceholder,
      frameplaceholder: framePlaceholder,
      titlesplaceholder: titlesPlaceholder
    } = this.graphics.placeholders;
    this.placeholder = placeholder;
    this.titlesPlaceholder = titlesPlaceholder;
    this.framePlaceholder = framePlaceholder;
    this.calloutPlaceholder = calloutPlaceholder;
    const {
      autoSize,
      // resize control if true
      controlSize,
      // Sets control Size in auto scale mode
      scale,
      // scale is needed for scale transform CSS creation
      frameMousePanelRect,
      titlesMousePanelRect,
      scrollPanelRect,
      mousePanelSize
      // Content mouse panel size
    } = this.layoutOptions;
    var scaleText = "scale(" + scale + "," + scale + ")";
    this.controlPanelStyle = autoSize ? controlSize.getCSS() : {};
    this.frameMousePanelStyle = frameMousePanelRect.getCSS();
    if (framePlaceholder) {
      this.framePlaceholderStyle = __spreadProps(__spreadValues({}, framePlaceholder.rect.getCSS()), {
        "transform": scaleText,
        "msTransform": scaleText,
        "WebkitTransform": scaleText,
        "OTransform": scaleText,
        "MozTransform": scaleText
      });
    }
    this.titlesMousePanelStyle = __spreadValues({}, titlesMousePanelRect.getCSS());
    if (titlesPlaceholder) {
      this.titlesPlaceholderStyle = __spreadProps(__spreadValues({}, titlesPlaceholder.rect.getCSS()), {
        "transformOrigin": "0 0",
        "transform": scaleText,
        "msTransform": scaleText,
        "WebkitTransform": scaleText,
        "OTransform": scaleText,
        "MozTransform": scaleText
      });
    }
    this.scrollPanelStyle = __spreadProps(__spreadValues({}, scrollPanelRect.getCSS()), {
      border: scrollPanelRect.x > 0 ? "1px dotted #dddddd" : ""
    });
    this.mousePanelStyle = __spreadValues({}, mousePanelSize.getCSS());
    this.placeholderStyle = __spreadProps(__spreadValues({}, placeholder.rect.getCSS()), {
      "transform": scaleText,
      "msTransform": scaleText,
      "WebkitTransform": scaleText,
      "OTransform": scaleText,
      "MozTransform": scaleText
    });
    if (calloutPlaceholder) {
      this.calloutPlaceholderStyle = {
        left: calloutPlaceholder.rect.x + "px",
        top: calloutPlaceholder.rect.y + "px"
      };
    }
    const {
      centerOnCursor
    } = this.state;
    if (centerOnCursor) {
      const centerOnCursorTask = this.tasks.getTask("CenterOnCursorTask");
      this.placeholderOffset = centerOnCursorTask.getPlaceholderOffset();
    }
  }
  ngOnDestroy() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.observer.disconnect();
  }
};
BaseDiagramComponent.ɵfac = function BaseDiagramComponent_Factory(t) {
  return new (t || BaseDiagramComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TaskManagerFactory2));
};
BaseDiagramComponent.ɵcmp = ɵɵdefineComponent({
  type: BaseDiagramComponent,
  selectors: [["ng-component"]],
  viewQuery: function BaseDiagramComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c5, 5);
      ɵɵviewQuery(_c6, 5);
      ɵɵviewQuery(_c7, 5);
      ɵɵviewQuery(_c8, 5);
      ɵɵviewQuery(_c9, 5);
      ɵɵviewQuery(_c10, 5);
      ɵɵviewQuery(_c11, 5);
      ɵɵviewQuery(_c12, 5);
      ɵɵviewQuery(_c13, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.frameMousePanelRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.framePlaceholderRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titlesMousePanelRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titlesPlaceholderRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollPanelRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.mousePanelRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.placeholderRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calloutPlaceholderRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlPanelRef = _t.first);
    }
  },
  inputs: {
    centerOnCursor: "centerOnCursor"
  },
  decls: 14,
  vars: 13,
  consts: [["controlPanelRef", ""], ["scrollPanelRef", ""], ["mousePanelRef", ""], ["placeholderRef", ""], ["layerTemplate", ""], ["frameMousePanelRef", ""], ["framePlaceholderRef", ""], ["titlesMousePanelRef", ""], ["titlesPlaceholderRef", ""], ["calloutPlaceholderRef", ""], ["tabIndex", "0", 1, "control-panel", 3, "keydown", "ngStyle"], ["class", "frame-mouse-panel", 3, "ngStyle", "click", "mousemove", 4, "ngIf"], ["class", "titles-mouse-panel", 3, "ngStyle", "mousemove", "click", 4, "ngIf"], [1, "scroll-panel", 3, "scroll", "ngStyle", "scrollLeft", "scrollTop"], [1, "mouse-panel", 3, "mousemove", "click", "change", "ngStyle"], [1, "placeholder", 3, "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "callout-placeholder", 3, "ngStyle", 4, "ngIf"], [1, "frame-mouse-panel", 3, "click", "mousemove", "ngStyle"], [1, "frame-placeholder", 3, "ngStyle"], [1, "titles-mouse-panel", 3, "mousemove", "click", "ngStyle"], [1, "titles-placeholder", 3, "ngStyle"], [1, "callout-placeholder", 3, "ngStyle"], ["class", "layer", 4, "ngFor", "ngForOf"], [1, "layer"], [4, "ngIf"], ["class", "label", 3, "ngStyle", 4, "ngFor", "ngForOf"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle", 4, "ngIf"], ["class", "template", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "label", 3, "ngStyle"], [3, "width", "height", "orientation", "horizontalAlignment", "verticalAlignment"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle"], [3, "ngStyle", 4, "ngFor", "ngForOf"], [3, "ngStyle"], [1, "template", 3, "ngStyle"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "itemConfig", "itemTitleFirstFontColor", "itemTitleSecondFontColor"], [3, "id", "isSelected", "label"], [3, "options", "itemConfig", "width", "height"], [3, "templateConfig"], [3, "options", "annotationConfig", "width", "height"], [3, "annotationConfig"], [1, "label-annotation"]],
  template: function BaseDiagramComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 10, 0);
      ɵɵlistener("keydown", function BaseDiagramComponent_Template_div_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onKeyDown($event));
      });
      ɵɵtemplate(2, BaseDiagramComponent_div_2_Template, 5, 6, "div", 11)(3, BaseDiagramComponent_div_3_Template, 5, 6, "div", 12);
      ɵɵelementStart(4, "div", 13, 1);
      ɵɵlistener("scroll", function BaseDiagramComponent_Template_div_scroll_4_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onScroll($event));
      });
      ɵɵelementStart(6, "div", 14, 2);
      ɵɵlistener("mousemove", function BaseDiagramComponent_Template_div_mousemove_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onMouseMove($event));
      })("click", function BaseDiagramComponent_Template_div_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      })("change", function BaseDiagramComponent_Template_div_change_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onCheckboxChange($event));
      });
      ɵɵelementStart(8, "div", 15, 3);
      ɵɵtemplate(10, BaseDiagramComponent_ng_container_10_Template, 1, 0, "ng-container", 16)(11, BaseDiagramComponent_div_11_Template, 3, 5, "div", 17);
      ɵɵelementEnd()()()();
      ɵɵtemplate(12, BaseDiagramComponent_ng_template_12_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const layerTemplate_r4 = ɵɵreference(13);
      ɵɵproperty("ngStyle", ctx.controlPanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.framePlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.titlesPlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx.scrollPanelStyle)("scrollLeft", ctx.placeholderOffset ? ctx.placeholderOffset.x : void 0)("scrollTop", ctx.placeholderOffset ? ctx.placeholderOffset.y : void 0);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.mousePanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.placeholderStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c14, ctx.placeholder));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.calloutPlaceholder);
    }
  },
  dependencies: [RotatedText, ItemComponent, CheckboxComponent, GroupTitleComponent, CursorComponent, HighlightComponent, DotHighlightComponent, LevelTitleComponent, LevelBackgroundComponent, NgStyle, NgIf, NgTemplateOutlet, NgForOf, NgSwitch, NgSwitchCase, NgSwitchDefault],
  styles: [".control-panel[_ngcontent-%COMP%]{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.frame-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel[_ngcontent-%COMP%], .titles-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.scroll-panel[_ngcontent-%COMP%]{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.placeholder[_ngcontent-%COMP%]{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder[_ngcontent-%COMP%]{position:absolute;overflow:visible}.layer[_ngcontent-%COMP%]{position:absolute;overflow:visible;left:0px;top:0px}.label[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation[_ngcontent-%COMP%]{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseDiagramComponent, [{
    type: Component,
    args: [{
      template: `<!-- root control panel -->\r
<div #controlPanelRef\r
  class="control-panel"\r
  [ngStyle]="controlPanelStyle"\r
  (keydown)="onKeyDown($event)"\r
  tabIndex="0"\r
>\r
  <div *ngIf="framePlaceholder"\r
    #frameMousePanelRef\r
    class="frame-mouse-panel"\r
    [ngStyle]="frameMousePanelStyle"\r
    (click)="onFrameClick($event)"\r
    (mousemove)="onFrameMouseMove($event)"\r
  >\r
    <div #framePlaceholderRef\r
      class="frame-placeholder" \r
      [ngStyle]="framePlaceholderStyle"\r
    >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: framePlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div *ngIf="titlesPlaceholder"\r
    #titlesMousePanelRef\r
    class="titles-mouse-panel"\r
    [ngStyle]="titlesMousePanelStyle"\r
    (mousemove)="onFrameMouseMove($event)"\r
    (click)="onFrameClick($event)"\r
  >\r
    <div #titlesPlaceholderRef\r
      [ngStyle]="titlesPlaceholderStyle"\r
      class="titles-placeholder"\r
     >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: titlesPlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div\r
    #scrollPanelRef\r
    class="scroll-panel"\r
    [ngStyle]="scrollPanelStyle"\r
    (scroll)="onScroll($event)"\r
    [scrollLeft]="placeholderOffset ? placeholderOffset.x : undefined"\r
    [scrollTop]="placeholderOffset ? placeholderOffset.y : undefined"\r
  >\r
    <div #mousePanelRef\r
      class="mouse-panel"\r
      [ngStyle]="mousePanelStyle"\r
      (mousemove)="onMouseMove($event)"\r
      (click)="onClick($event)"\r
      (change)="onCheckboxChange($event)"\r
    >\r
      <div #placeholderRef\r
        class="placeholder"\r
        [ngStyle]="placeholderStyle"\r
      >\r
        <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: placeholder}"></ng-container>\r
        <div *ngIf="calloutPlaceholder"\r
          #calloutPlaceholderRef\r
          class="callout-placeholder"\r
          [ngStyle]="calloutPlaceholderStyle"\r
        >\r
          <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: calloutPlaceholder}"></ng-container>\r
        </div>\r
      </div>\r
    </div>\r
  </div>\r
</div>\r
\r
<!--Templates: -->\r
<ng-template #layerTemplate let-placeholder>\r
  <div *ngFor="let layer of placeholder.layers" class="layer">\r
    <ng-container *ngIf="layer">\r
      <div *ngFor="let label of layer.labels" class="label" [ngStyle]= "label.style">\r
        <rotated-text\r
          [width]="label.width"\r
          [height]="label.height"\r
          [orientation]="label.orientation"\r
          [horizontalAlignment]="label.horizontalAlignment"\r
          [verticalAlignment]="label.verticalAlignment"\r
        >{{label.label}}</rotated-text>\r
      </div>\r
      <svg \r
        *ngIf="layer.polylines.length > 0"\r
        attr.height.px="{{placeholder.size.height}}"\r
        attr.width.px="{{placeholder.size.width}}"\r
        xmlns="http://www.w3.org/2000/svg"\r
        xmlns:xlink="http://www.w3.org/1999/xlink"\r
        [ngStyle]="{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}"\r
      >\r
        <path *ngFor="let path of layer.polylines" [attr.d]="path.data" [ngStyle]="path.style"></path>\r
      </svg>\r
      <div *ngFor="let item of layer.items;" class="template" [ngStyle]="item.style">\r
        <ng-container [ngSwitch]="item.templateType">\r
          <ng-container *ngSwitchCase="'itemTemplate'">\r
            <bp-item [itemConfig]="item.context.context" [itemTitleFirstFontColor]="item.context.itemTitleFirstFontColor" [itemTitleSecondFontColor]="item.context.itemTitleSecondFontColor"></bp-item>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'checkboxTemplate'">\r
            <bp-checkbox [id]="item.context.id" [isSelected]="item.context.isSelected" [label]="item.context.selectCheckBoxLabel"></bp-checkbox>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'groupTitleTemplate'">\r
            <bp-group-title [options]="item.context" [itemConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-group-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'cursorTemplate'">\r
            <bp-cursor [templateConfig]="item.context.templateConfig"></bp-cursor>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'highlightTemplate'">\r
            <bp-highlight [templateConfig]="item.context.templateConfig"></bp-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'dotHighlightTemplate'">\r
            <bp-dot-highlight [templateConfig]="item.context.templateConfig"></bp-dot-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelTitleTemplate'">\r
            <bp-level-title [options]="item.context" [annotationConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-level-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelBackgroundTemplate'">\r
            <bp-level-background [annotationConfig]="item.context.context"></bp-level-background>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'labelAnnotationTemplate'">\r
            <div class="label-annotation">{{item.context.context.title}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'annotationLabelTemplate'">\r
            <div class="label-annotation">{{item.context.context.label}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchDefault>\r
            <ng-container *ngTemplateOutlet="item.templateRef; context: item.context"></ng-container>\r
          </ng-container>\r
        </ng-container>\r
      </div>\r
    </ng-container>\r
  </div>\r
</ng-template>\r
`,
      styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: TaskManagerFactory2
    }];
  }, {
    frameMousePanelRef: [{
      type: ViewChild,
      args: ["frameMousePanelRef"]
    }],
    framePlaceholderRef: [{
      type: ViewChild,
      args: ["framePlaceholderRef"]
    }],
    titlesMousePanelRef: [{
      type: ViewChild,
      args: ["titlesMousePanelRef"]
    }],
    titlesPlaceholderRef: [{
      type: ViewChild,
      args: ["titlesPlaceholderRef"]
    }],
    scrollPanelRef: [{
      type: ViewChild,
      args: ["scrollPanelRef"]
    }],
    mousePanelRef: [{
      type: ViewChild,
      args: ["mousePanelRef"]
    }],
    placeholderRef: [{
      type: ViewChild,
      args: ["placeholderRef"]
    }],
    calloutPlaceholderRef: [{
      type: ViewChild,
      args: ["calloutPlaceholderRef"]
    }],
    controlPanelRef: [{
      type: ViewChild,
      args: ["controlPanelRef"]
    }],
    centerOnCursor: [{
      type: Input
    }]
  });
})();
var FamEventArgs2 = class {
  constructor(config = {}) {
    this.oldContext = null;
    this.context = null;
    this.parentItems = [];
    this.childrenItems = [];
    this.position = null;
    this.name = null;
    this.cancel = false;
    Object.assign(this, config);
  }
};
var OrgEventArgs2 = class {
  constructor(config = {}) {
    this.oldContext = null;
    this.context = null;
    this.parentItem = null;
    this.position = null;
    this.name = null;
    this.cancel = false;
    Object.assign(this, config);
  }
};
var SelectionEventArgs = class {
  constructor(config = {}) {
    this.selectedItems = [];
    this.newSelectedItems = [];
    this.cancel = false;
    Object.assign(this, config);
  }
};
var OrgConfig2 = class {
  constructor(config = {}) {
    this.navigationMode = NavigationMode2.Default;
    this.pageFitMode = PageFitMode2.FitToPage;
    this.alignBranches = false;
    this.minimalVisibility = Visibility2.Dot;
    this.minimumVisibleLevels = 1;
    this.orientationType = OrientationType2.Top;
    this.horizontalAlignment = HorizontalAlignmentType2.Center;
    this.verticalAlignment = VerticalAlignmentType2.Middle;
    this.arrowsDirection = GroupByType2.None;
    this.showExtraArrows = false;
    this.extraArrowsMinimumSpace = 30;
    this.connectorType = ConnectorType2.Squared;
    this.bevelSize = 4;
    this.elbowType = ElbowType2.None;
    this.elbowDotSize = 4;
    this.emptyDiagramMessage = "Diagram is empty.";
    this.items = [];
    this.annotations = [];
    this.cursorItem = null;
    this.highlightItem = null;
    this.highlightGravityRadius = 40;
    this.selectedItems = [];
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.selectCheckBoxLabel = "Selected";
    this.selectionPathMode = SelectionPathMode2.FullStack;
    this.templates = [];
    this.defaultTemplateName = null;
    this.hasButtons = Enabled2.Auto;
    this.buttonsTemplate = null;
    this.normalLevelShift = 20;
    this.dotLevelShift = 20;
    this.lineLevelShift = 10;
    this.normalItemsInterval = 10;
    this.dotItemsInterval = 1;
    this.lineItemsInterval = 2;
    this.cousinsIntervalMultiplier = 5;
    this.itemTitleFirstFontColor = "#ffffff";
    this.itemTitleSecondFontColor = "#000080";
    this.minimizedItemShapeType = ShapeType2.None;
    this.linesColor = "#c0c0c0";
    this.linesWidth = 1;
    this.linesType = LineType2.Solid;
    this.highlightLinesColor = "#ff0000";
    this.highlightLinesWidth = 1;
    this.highlightLinesType = LineType2.Solid;
    this.calloutMaximumVisibility = Visibility2.Dot;
    this.showCallout = true;
    this.calloutPlacementOffset = 100;
    this.defaultCalloutTemplateName = null;
    this.calloutfillColor = "#000000";
    this.calloutBorderColor = null;
    this.calloutOffset = 4;
    this.calloutCornerRadius = 4;
    this.calloutPointerWidth = "10%";
    this.calloutLineWidth = 1;
    this.calloutOpacity = 0.2;
    this.childrenPlacementType = ChildrenPlacementType2.Horizontal;
    this.leavesPlacementType = ChildrenPlacementType2.Horizontal;
    this.placeAssistantsAboveChildren = true;
    this.placeAdvisersAboveChildren = true;
    this.maximumColumnsInMatrix = 6;
    this.buttonsPanelSize = 28;
    this.groupTitlePanelSize = 24;
    this.checkBoxPanelSize = 24;
    this.groupTitlePlacementType = AdviserPlacementType2.Left;
    this.groupTitleOrientation = TextOrientationType2.RotateRight;
    this.groupTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.groupTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.groupTitleFontSize = "12px";
    this.groupTitleFontFamily = "Arial";
    this.groupTitleColor = "#4169e1";
    this.groupTitleFontWeight = "normal";
    this.groupTitleFontStyle = "normal";
    this.groupTitleTemplate = null;
    this.levelTitlePanelSize = 24;
    this.levelTitlePlacementType = AdviserPlacementType2.Left;
    this.levelTitlePlaceInside = false;
    this.levelTitleOrientation = TextOrientationType2.Auto;
    this.levelTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.levelTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.levelTitleFontSize = "12px";
    this.levelTitleFontFamily = "Arial";
    this.levelTitleFontColor = "#ffffff";
    this.levelTitleColor = "#4169e1";
    this.levelTitleFontWeight = "normal";
    this.levelTitleFontStyle = "normal";
    this.levelTitleTemplate = null;
    this.levelBackgroundTemplate = null;
    this.distance = 3;
    this.scale = 1;
    this.minimumScale = 0.5;
    this.maximumScale = 2;
    this.showLabels = Enabled2.Auto;
    this.labelSize = new Size2(80, 24);
    this.labelOffset = 1;
    this.labelOrientation = TextOrientationType2.Horizontal;
    this.labelPlacement = PlacementType2.Top;
    this.labelFontSize = "10px";
    this.labelFontFamily = "Arial";
    this.labelColor = "#000000";
    this.labelFontWeight = "normal";
    this.labelFontStyle = "normal";
    this.enablePanning = true;
    this.autoSizeMinimum = new Size2(800, 600);
    this.autoSizeMaximum = new Size2(1024, 768);
    this.showFrame = false;
    this.frameInnerPadding = new Thickness2(2, 2, 2, 2);
    this.frameOuterPadding = new Thickness2(2, 2, 2, 2);
    this.padding = new Thickness2(10, 10, 10, 10);
    Object.assign(this, config);
  }
};
var OrgDiagramComponent = class extends BaseDiagramComponent {
  constructor(host, zone) {
    super(host, zone, new TaskManagerFactory2(TaskManagerFactory));
    this.navigationMode = NavigationMode2.Default;
    this.pageFitMode = PageFitMode2.FitToPage;
    this.alignBranches = false;
    this.minimalVisibility = Visibility2.Dot;
    this.minimumVisibleLevels = 1;
    this.orientationType = OrientationType2.Top;
    this.horizontalAlignment = HorizontalAlignmentType2.Center;
    this.verticalAlignment = VerticalAlignmentType2.Middle;
    this.arrowsDirection = GroupByType2.None;
    this.showExtraArrows = false;
    this.extraArrowsMinimumSpace = 30;
    this.connectorType = ConnectorType2.Squared;
    this.bevelSize = 4;
    this.elbowType = ElbowType2.None;
    this.elbowDotSize = 4;
    this.emptyDiagramMessage = "Diagram is empty.";
    this.items = [];
    this.annotations = [];
    this.cursorItem = null;
    this.highlightItem = null;
    this.highlightGravityRadius = 40;
    this.selectedItems = [];
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.selectCheckBoxLabel = "Selected";
    this.selectionPathMode = SelectionPathMode2.FullStack;
    this.templates = [];
    this.defaultTemplateName = null;
    this.hasButtons = Enabled2.Auto;
    this.buttonsTemplate = null;
    this.normalLevelShift = 20;
    this.dotLevelShift = 20;
    this.lineLevelShift = 10;
    this.normalItemsInterval = 10;
    this.dotItemsInterval = 1;
    this.lineItemsInterval = 2;
    this.cousinsIntervalMultiplier = 5;
    this.itemTitleFirstFontColor = "#ffffff";
    this.itemTitleSecondFontColor = "#000080";
    this.minimizedItemShapeType = ShapeType2.None;
    this.linesColor = "#c0c0c0";
    this.linesWidth = 1;
    this.linesType = LineType2.Solid;
    this.highlightLinesColor = "#ff0000";
    this.highlightLinesWidth = 1;
    this.highlightLinesType = LineType2.Solid;
    this.calloutMaximumVisibility = Visibility2.Dot;
    this.showCallout = true;
    this.calloutPlacementOffset = 100;
    this.defaultCalloutTemplateName = null;
    this.calloutfillColor = "#000000";
    this.calloutBorderColor = null;
    this.calloutOffset = 4;
    this.calloutCornerRadius = 4;
    this.calloutPointerWidth = "10%";
    this.calloutLineWidth = 1;
    this.calloutOpacity = 0.2;
    this.childrenPlacementType = ChildrenPlacementType2.Horizontal;
    this.leavesPlacementType = ChildrenPlacementType2.Horizontal;
    this.placeAssistantsAboveChildren = true;
    this.placeAdvisersAboveChildren = true;
    this.maximumColumnsInMatrix = 6;
    this.buttonsPanelSize = 28;
    this.groupTitlePanelSize = 24;
    this.checkBoxPanelSize = 24;
    this.groupTitlePlacementType = AdviserPlacementType2.Left;
    this.groupTitleOrientation = TextOrientationType2.RotateRight;
    this.groupTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.groupTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.groupTitleFontSize = "12px";
    this.groupTitleFontFamily = "Arial";
    this.groupTitleColor = "#4169e1";
    this.groupTitleFontWeight = "normal";
    this.groupTitleFontStyle = "normal";
    this.groupTitleTemplate = null;
    this.levelTitlePanelSize = 24;
    this.levelTitlePlacementType = AdviserPlacementType2.Left;
    this.levelTitlePlaceInside = false;
    this.levelTitleOrientation = TextOrientationType2.Auto;
    this.levelTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.levelTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.levelTitleFontSize = "12px";
    this.levelTitleFontFamily = "Arial";
    this.levelTitleFontColor = "#ffffff";
    this.levelTitleColor = "#4169e1";
    this.levelTitleFontWeight = "normal";
    this.levelTitleFontStyle = "normal";
    this.levelTitleTemplate = null;
    this.levelBackgroundTemplate = null;
    this.distance = 3;
    this.scale = 1;
    this.minimumScale = 0.5;
    this.maximumScale = 2;
    this.showLabels = Enabled2.Auto;
    this.labelSize = new Size2(80, 24);
    this.labelOffset = 1;
    this.labelOrientation = TextOrientationType2.Horizontal;
    this.labelPlacement = PlacementType2.Top;
    this.labelFontSize = "10px";
    this.labelFontFamily = "Arial";
    this.labelColor = "#000000";
    this.labelFontWeight = "normal";
    this.labelFontStyle = "normal";
    this.enablePanning = true;
    this.autoSizeMinimum = new Size2(800, 600);
    this.autoSizeMaximum = new Size2(1024, 768);
    this.showFrame = false;
    this.frameInnerPadding = new Thickness2(2, 2, 2, 2);
    this.frameOuterPadding = new Thickness2(2, 2, 2, 2);
    this.padding = new Thickness2(10, 10, 10, 10);
    this.onHighlightChanging = new EventEmitter(false);
    this.onHighlightChanged = new EventEmitter();
    this.onCursorChanging = new EventEmitter(false);
    this.onCursorChanged = new EventEmitter();
    this.onSelectionChanging = new EventEmitter(false);
    this.onSelectionChanged = new EventEmitter();
  }
  ngOnChanges(changes) {
    var config = new OrgConfig2(this);
    const {
      highlightItem,
      cursorItem,
      selectedItems
    } = config;
    this.state = __spreadProps(__spreadValues({}, this.state), {
      config,
      highlightItem,
      cursorItem,
      selectedItems,
      centerOnCursor: this.centerOnCursor
    });
    this.render();
  }
  _onHighlightChanging(event, itemId, newItemId) {
    var newEvent = new OrgEventArgs2(__spreadProps(__spreadValues({}, this.getEventArgs(itemId, newItemId)), {
      event
    }));
    this.onHighlightChanging.emit(newEvent);
    return newEvent;
  }
  _onHighlightChanged(eventArgs) {
    this.onHighlightChanged.emit(eventArgs);
  }
  _onCursorChanging(event, itemId, newItemId) {
    var newEvent = new OrgEventArgs2(__spreadProps(__spreadValues({}, this.getEventArgs(itemId, newItemId)), {
      event
    }));
    this.onCursorChanging.emit(newEvent);
    return newEvent;
  }
  _onCursorChanged(eventArgs) {
    this.onCursorChanged.emit(eventArgs);
  }
  _onSelectionChanging(event, selectedItems, newSelectedItems) {
    var newEvent = new SelectionEventArgs({
      selectedItems,
      newSelectedItems,
      event
    });
    this.onSelectionChanging.emit(newEvent);
    return newEvent;
  }
  _onSelectionChanged(eventArgs) {
    this.onSelectionChanged.emit(eventArgs);
  }
};
OrgDiagramComponent.ɵfac = function OrgDiagramComponent_Factory(t) {
  return new (t || OrgDiagramComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
OrgDiagramComponent.ɵcmp = ɵɵdefineComponent({
  type: OrgDiagramComponent,
  selectors: [["org-diagram"]],
  inputs: {
    navigationMode: "navigationMode",
    pageFitMode: "pageFitMode",
    alignBranches: "alignBranches",
    minimalVisibility: "minimalVisibility",
    minimumVisibleLevels: "minimumVisibleLevels",
    orientationType: "orientationType",
    horizontalAlignment: "horizontalAlignment",
    verticalAlignment: "verticalAlignment",
    arrowsDirection: "arrowsDirection",
    showExtraArrows: "showExtraArrows",
    extraArrowsMinimumSpace: "extraArrowsMinimumSpace",
    connectorType: "connectorType",
    bevelSize: "bevelSize",
    elbowType: "elbowType",
    elbowDotSize: "elbowDotSize",
    emptyDiagramMessage: "emptyDiagramMessage",
    items: "items",
    annotations: "annotations",
    cursorItem: "cursorItem",
    highlightItem: "highlightItem",
    highlightGravityRadius: "highlightGravityRadius",
    selectedItems: "selectedItems",
    hasSelectorCheckbox: "hasSelectorCheckbox",
    selectCheckBoxLabel: "selectCheckBoxLabel",
    selectionPathMode: "selectionPathMode",
    templates: "templates",
    defaultTemplateName: "defaultTemplateName",
    hasButtons: "hasButtons",
    buttonsTemplate: "buttonsTemplate",
    normalLevelShift: "normalLevelShift",
    dotLevelShift: "dotLevelShift",
    lineLevelShift: "lineLevelShift",
    normalItemsInterval: "normalItemsInterval",
    dotItemsInterval: "dotItemsInterval",
    lineItemsInterval: "lineItemsInterval",
    cousinsIntervalMultiplier: "cousinsIntervalMultiplier",
    itemTitleFirstFontColor: "itemTitleFirstFontColor",
    itemTitleSecondFontColor: "itemTitleSecondFontColor",
    minimizedItemShapeType: "minimizedItemShapeType",
    linesColor: "linesColor",
    linesWidth: "linesWidth",
    linesType: "linesType",
    highlightLinesColor: "highlightLinesColor",
    highlightLinesWidth: "highlightLinesWidth",
    highlightLinesType: "highlightLinesType",
    calloutMaximumVisibility: "calloutMaximumVisibility",
    showCallout: "showCallout",
    calloutPlacementOffset: "calloutPlacementOffset",
    defaultCalloutTemplateName: "defaultCalloutTemplateName",
    calloutfillColor: "calloutfillColor",
    calloutBorderColor: "calloutBorderColor",
    calloutOffset: "calloutOffset",
    calloutCornerRadius: "calloutCornerRadius",
    calloutPointerWidth: "calloutPointerWidth",
    calloutLineWidth: "calloutLineWidth",
    calloutOpacity: "calloutOpacity",
    childrenPlacementType: "childrenPlacementType",
    leavesPlacementType: "leavesPlacementType",
    placeAssistantsAboveChildren: "placeAssistantsAboveChildren",
    placeAdvisersAboveChildren: "placeAdvisersAboveChildren",
    maximumColumnsInMatrix: "maximumColumnsInMatrix",
    buttonsPanelSize: "buttonsPanelSize",
    groupTitlePanelSize: "groupTitlePanelSize",
    checkBoxPanelSize: "checkBoxPanelSize",
    groupTitlePlacementType: "groupTitlePlacementType",
    groupTitleOrientation: "groupTitleOrientation",
    groupTitleVerticalAlignment: "groupTitleVerticalAlignment",
    groupTitleHorizontalAlignment: "groupTitleHorizontalAlignment",
    groupTitleFontSize: "groupTitleFontSize",
    groupTitleFontFamily: "groupTitleFontFamily",
    groupTitleColor: "groupTitleColor",
    groupTitleFontWeight: "groupTitleFontWeight",
    groupTitleFontStyle: "groupTitleFontStyle",
    groupTitleTemplate: "groupTitleTemplate",
    levelTitlePanelSize: "levelTitlePanelSize",
    levelTitlePlacementType: "levelTitlePlacementType",
    levelTitlePlaceInside: "levelTitlePlaceInside",
    levelTitleOrientation: "levelTitleOrientation",
    levelTitleVerticalAlignment: "levelTitleVerticalAlignment",
    levelTitleHorizontalAlignment: "levelTitleHorizontalAlignment",
    levelTitleFontSize: "levelTitleFontSize",
    levelTitleFontFamily: "levelTitleFontFamily",
    levelTitleFontColor: "levelTitleFontColor",
    levelTitleColor: "levelTitleColor",
    levelTitleFontWeight: "levelTitleFontWeight",
    levelTitleFontStyle: "levelTitleFontStyle",
    levelTitleTemplate: "levelTitleTemplate",
    levelBackgroundTemplate: "levelBackgroundTemplate",
    distance: "distance",
    scale: "scale",
    minimumScale: "minimumScale",
    maximumScale: "maximumScale",
    showLabels: "showLabels",
    labelSize: "labelSize",
    labelOffset: "labelOffset",
    labelOrientation: "labelOrientation",
    labelPlacement: "labelPlacement",
    labelFontSize: "labelFontSize",
    labelFontFamily: "labelFontFamily",
    labelColor: "labelColor",
    labelFontWeight: "labelFontWeight",
    labelFontStyle: "labelFontStyle",
    enablePanning: "enablePanning",
    autoSizeMinimum: "autoSizeMinimum",
    autoSizeMaximum: "autoSizeMaximum",
    showFrame: "showFrame",
    frameInnerPadding: "frameInnerPadding",
    frameOuterPadding: "frameOuterPadding",
    padding: "padding"
  },
  outputs: {
    onHighlightChanging: "onHighlightChanging",
    onHighlightChanged: "onHighlightChanged",
    onCursorChanging: "onCursorChanging",
    onCursorChanged: "onCursorChanged",
    onSelectionChanging: "onSelectionChanging",
    onSelectionChanged: "onSelectionChanged"
  },
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 14,
  vars: 13,
  consts: [["controlPanelRef", ""], ["scrollPanelRef", ""], ["mousePanelRef", ""], ["placeholderRef", ""], ["layerTemplate", ""], ["frameMousePanelRef", ""], ["framePlaceholderRef", ""], ["titlesMousePanelRef", ""], ["titlesPlaceholderRef", ""], ["calloutPlaceholderRef", ""], ["tabIndex", "0", 1, "control-panel", 3, "keydown", "ngStyle"], ["class", "frame-mouse-panel", 3, "ngStyle", "click", "mousemove", 4, "ngIf"], ["class", "titles-mouse-panel", 3, "ngStyle", "mousemove", "click", 4, "ngIf"], [1, "scroll-panel", 3, "scroll", "ngStyle", "scrollLeft", "scrollTop"], [1, "mouse-panel", 3, "mousemove", "click", "change", "ngStyle"], [1, "placeholder", 3, "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "callout-placeholder", 3, "ngStyle", 4, "ngIf"], [1, "frame-mouse-panel", 3, "click", "mousemove", "ngStyle"], [1, "frame-placeholder", 3, "ngStyle"], [1, "titles-mouse-panel", 3, "mousemove", "click", "ngStyle"], [1, "titles-placeholder", 3, "ngStyle"], [1, "callout-placeholder", 3, "ngStyle"], ["class", "layer", 4, "ngFor", "ngForOf"], [1, "layer"], [4, "ngIf"], ["class", "label", 3, "ngStyle", 4, "ngFor", "ngForOf"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle", 4, "ngIf"], ["class", "template", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "label", 3, "ngStyle"], [3, "width", "height", "orientation", "horizontalAlignment", "verticalAlignment"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle"], [3, "ngStyle", 4, "ngFor", "ngForOf"], [3, "ngStyle"], [1, "template", 3, "ngStyle"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "itemConfig", "itemTitleFirstFontColor", "itemTitleSecondFontColor"], [3, "id", "isSelected", "label"], [3, "options", "itemConfig", "width", "height"], [3, "templateConfig"], [3, "options", "annotationConfig", "width", "height"], [3, "annotationConfig"], [1, "label-annotation"]],
  template: function OrgDiagramComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 10, 0);
      ɵɵlistener("keydown", function OrgDiagramComponent_Template_div_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onKeyDown($event));
      });
      ɵɵtemplate(2, OrgDiagramComponent_div_2_Template, 5, 6, "div", 11)(3, OrgDiagramComponent_div_3_Template, 5, 6, "div", 12);
      ɵɵelementStart(4, "div", 13, 1);
      ɵɵlistener("scroll", function OrgDiagramComponent_Template_div_scroll_4_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onScroll($event));
      });
      ɵɵelementStart(6, "div", 14, 2);
      ɵɵlistener("mousemove", function OrgDiagramComponent_Template_div_mousemove_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onMouseMove($event));
      })("click", function OrgDiagramComponent_Template_div_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      })("change", function OrgDiagramComponent_Template_div_change_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onCheckboxChange($event));
      });
      ɵɵelementStart(8, "div", 15, 3);
      ɵɵtemplate(10, OrgDiagramComponent_ng_container_10_Template, 1, 0, "ng-container", 16)(11, OrgDiagramComponent_div_11_Template, 3, 5, "div", 17);
      ɵɵelementEnd()()()();
      ɵɵtemplate(12, OrgDiagramComponent_ng_template_12_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const layerTemplate_r4 = ɵɵreference(13);
      ɵɵproperty("ngStyle", ctx.controlPanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.framePlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.titlesPlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx.scrollPanelStyle)("scrollLeft", ctx.placeholderOffset ? ctx.placeholderOffset.x : void 0)("scrollTop", ctx.placeholderOffset ? ctx.placeholderOffset.y : void 0);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.mousePanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.placeholderStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c14, ctx.placeholder));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.calloutPlaceholder);
    }
  },
  dependencies: [RotatedText, ItemComponent, CheckboxComponent, GroupTitleComponent, CursorComponent, HighlightComponent, DotHighlightComponent, LevelTitleComponent, LevelBackgroundComponent, NgStyle, NgIf, NgTemplateOutlet, NgForOf, NgSwitch, NgSwitchCase, NgSwitchDefault],
  styles: [_c16]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OrgDiagramComponent, [{
    type: Component,
    args: [{
      selector: "org-diagram",
      template: `<!-- root control panel -->\r
<div #controlPanelRef\r
  class="control-panel"\r
  [ngStyle]="controlPanelStyle"\r
  (keydown)="onKeyDown($event)"\r
  tabIndex="0"\r
>\r
  <div *ngIf="framePlaceholder"\r
    #frameMousePanelRef\r
    class="frame-mouse-panel"\r
    [ngStyle]="frameMousePanelStyle"\r
    (click)="onFrameClick($event)"\r
    (mousemove)="onFrameMouseMove($event)"\r
  >\r
    <div #framePlaceholderRef\r
      class="frame-placeholder" \r
      [ngStyle]="framePlaceholderStyle"\r
    >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: framePlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div *ngIf="titlesPlaceholder"\r
    #titlesMousePanelRef\r
    class="titles-mouse-panel"\r
    [ngStyle]="titlesMousePanelStyle"\r
    (mousemove)="onFrameMouseMove($event)"\r
    (click)="onFrameClick($event)"\r
  >\r
    <div #titlesPlaceholderRef\r
      [ngStyle]="titlesPlaceholderStyle"\r
      class="titles-placeholder"\r
     >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: titlesPlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div\r
    #scrollPanelRef\r
    class="scroll-panel"\r
    [ngStyle]="scrollPanelStyle"\r
    (scroll)="onScroll($event)"\r
    [scrollLeft]="placeholderOffset ? placeholderOffset.x : undefined"\r
    [scrollTop]="placeholderOffset ? placeholderOffset.y : undefined"\r
  >\r
    <div #mousePanelRef\r
      class="mouse-panel"\r
      [ngStyle]="mousePanelStyle"\r
      (mousemove)="onMouseMove($event)"\r
      (click)="onClick($event)"\r
      (change)="onCheckboxChange($event)"\r
    >\r
      <div #placeholderRef\r
        class="placeholder"\r
        [ngStyle]="placeholderStyle"\r
      >\r
        <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: placeholder}"></ng-container>\r
        <div *ngIf="calloutPlaceholder"\r
          #calloutPlaceholderRef\r
          class="callout-placeholder"\r
          [ngStyle]="calloutPlaceholderStyle"\r
        >\r
          <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: calloutPlaceholder}"></ng-container>\r
        </div>\r
      </div>\r
    </div>\r
  </div>\r
</div>\r
\r
<!--Templates: -->\r
<ng-template #layerTemplate let-placeholder>\r
  <div *ngFor="let layer of placeholder.layers" class="layer">\r
    <ng-container *ngIf="layer">\r
      <div *ngFor="let label of layer.labels" class="label" [ngStyle]= "label.style">\r
        <rotated-text\r
          [width]="label.width"\r
          [height]="label.height"\r
          [orientation]="label.orientation"\r
          [horizontalAlignment]="label.horizontalAlignment"\r
          [verticalAlignment]="label.verticalAlignment"\r
        >{{label.label}}</rotated-text>\r
      </div>\r
      <svg \r
        *ngIf="layer.polylines.length > 0"\r
        attr.height.px="{{placeholder.size.height}}"\r
        attr.width.px="{{placeholder.size.width}}"\r
        xmlns="http://www.w3.org/2000/svg"\r
        xmlns:xlink="http://www.w3.org/1999/xlink"\r
        [ngStyle]="{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}"\r
      >\r
        <path *ngFor="let path of layer.polylines" [attr.d]="path.data" [ngStyle]="path.style"></path>\r
      </svg>\r
      <div *ngFor="let item of layer.items;" class="template" [ngStyle]="item.style">\r
        <ng-container [ngSwitch]="item.templateType">\r
          <ng-container *ngSwitchCase="'itemTemplate'">\r
            <bp-item [itemConfig]="item.context.context" [itemTitleFirstFontColor]="item.context.itemTitleFirstFontColor" [itemTitleSecondFontColor]="item.context.itemTitleSecondFontColor"></bp-item>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'checkboxTemplate'">\r
            <bp-checkbox [id]="item.context.id" [isSelected]="item.context.isSelected" [label]="item.context.selectCheckBoxLabel"></bp-checkbox>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'groupTitleTemplate'">\r
            <bp-group-title [options]="item.context" [itemConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-group-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'cursorTemplate'">\r
            <bp-cursor [templateConfig]="item.context.templateConfig"></bp-cursor>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'highlightTemplate'">\r
            <bp-highlight [templateConfig]="item.context.templateConfig"></bp-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'dotHighlightTemplate'">\r
            <bp-dot-highlight [templateConfig]="item.context.templateConfig"></bp-dot-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelTitleTemplate'">\r
            <bp-level-title [options]="item.context" [annotationConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-level-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelBackgroundTemplate'">\r
            <bp-level-background [annotationConfig]="item.context.context"></bp-level-background>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'labelAnnotationTemplate'">\r
            <div class="label-annotation">{{item.context.context.title}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'annotationLabelTemplate'">\r
            <div class="label-annotation">{{item.context.context.label}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchDefault>\r
            <ng-container *ngTemplateOutlet="item.templateRef; context: item.context"></ng-container>\r
          </ng-container>\r
        </ng-container>\r
      </div>\r
    </ng-container>\r
  </div>\r
</ng-template>\r
`,
      styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    navigationMode: [{
      type: Input
    }],
    pageFitMode: [{
      type: Input
    }],
    alignBranches: [{
      type: Input
    }],
    minimalVisibility: [{
      type: Input
    }],
    minimumVisibleLevels: [{
      type: Input
    }],
    orientationType: [{
      type: Input
    }],
    horizontalAlignment: [{
      type: Input
    }],
    verticalAlignment: [{
      type: Input
    }],
    arrowsDirection: [{
      type: Input
    }],
    showExtraArrows: [{
      type: Input
    }],
    extraArrowsMinimumSpace: [{
      type: Input
    }],
    connectorType: [{
      type: Input
    }],
    bevelSize: [{
      type: Input
    }],
    elbowType: [{
      type: Input
    }],
    elbowDotSize: [{
      type: Input
    }],
    emptyDiagramMessage: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    annotations: [{
      type: Input
    }],
    cursorItem: [{
      type: Input
    }],
    highlightItem: [{
      type: Input
    }],
    highlightGravityRadius: [{
      type: Input
    }],
    selectedItems: [{
      type: Input
    }],
    hasSelectorCheckbox: [{
      type: Input
    }],
    selectCheckBoxLabel: [{
      type: Input
    }],
    selectionPathMode: [{
      type: Input
    }],
    templates: [{
      type: Input
    }],
    defaultTemplateName: [{
      type: Input
    }],
    hasButtons: [{
      type: Input
    }],
    buttonsTemplate: [{
      type: Input
    }],
    normalLevelShift: [{
      type: Input
    }],
    dotLevelShift: [{
      type: Input
    }],
    lineLevelShift: [{
      type: Input
    }],
    normalItemsInterval: [{
      type: Input
    }],
    dotItemsInterval: [{
      type: Input
    }],
    lineItemsInterval: [{
      type: Input
    }],
    cousinsIntervalMultiplier: [{
      type: Input
    }],
    itemTitleFirstFontColor: [{
      type: Input
    }],
    itemTitleSecondFontColor: [{
      type: Input
    }],
    minimizedItemShapeType: [{
      type: Input
    }],
    linesColor: [{
      type: Input
    }],
    linesWidth: [{
      type: Input
    }],
    linesType: [{
      type: Input
    }],
    highlightLinesColor: [{
      type: Input
    }],
    highlightLinesWidth: [{
      type: Input
    }],
    highlightLinesType: [{
      type: Input
    }],
    calloutMaximumVisibility: [{
      type: Input
    }],
    showCallout: [{
      type: Input
    }],
    calloutPlacementOffset: [{
      type: Input
    }],
    defaultCalloutTemplateName: [{
      type: Input
    }],
    calloutfillColor: [{
      type: Input
    }],
    calloutBorderColor: [{
      type: Input
    }],
    calloutOffset: [{
      type: Input
    }],
    calloutCornerRadius: [{
      type: Input
    }],
    calloutPointerWidth: [{
      type: Input
    }],
    calloutLineWidth: [{
      type: Input
    }],
    calloutOpacity: [{
      type: Input
    }],
    childrenPlacementType: [{
      type: Input
    }],
    leavesPlacementType: [{
      type: Input
    }],
    placeAssistantsAboveChildren: [{
      type: Input
    }],
    placeAdvisersAboveChildren: [{
      type: Input
    }],
    maximumColumnsInMatrix: [{
      type: Input
    }],
    buttonsPanelSize: [{
      type: Input
    }],
    groupTitlePanelSize: [{
      type: Input
    }],
    checkBoxPanelSize: [{
      type: Input
    }],
    groupTitlePlacementType: [{
      type: Input
    }],
    groupTitleOrientation: [{
      type: Input
    }],
    groupTitleVerticalAlignment: [{
      type: Input
    }],
    groupTitleHorizontalAlignment: [{
      type: Input
    }],
    groupTitleFontSize: [{
      type: Input
    }],
    groupTitleFontFamily: [{
      type: Input
    }],
    groupTitleColor: [{
      type: Input
    }],
    groupTitleFontWeight: [{
      type: Input
    }],
    groupTitleFontStyle: [{
      type: Input
    }],
    groupTitleTemplate: [{
      type: Input
    }],
    levelTitlePanelSize: [{
      type: Input
    }],
    levelTitlePlacementType: [{
      type: Input
    }],
    levelTitlePlaceInside: [{
      type: Input
    }],
    levelTitleOrientation: [{
      type: Input
    }],
    levelTitleVerticalAlignment: [{
      type: Input
    }],
    levelTitleHorizontalAlignment: [{
      type: Input
    }],
    levelTitleFontSize: [{
      type: Input
    }],
    levelTitleFontFamily: [{
      type: Input
    }],
    levelTitleFontColor: [{
      type: Input
    }],
    levelTitleColor: [{
      type: Input
    }],
    levelTitleFontWeight: [{
      type: Input
    }],
    levelTitleFontStyle: [{
      type: Input
    }],
    levelTitleTemplate: [{
      type: Input
    }],
    levelBackgroundTemplate: [{
      type: Input
    }],
    distance: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    minimumScale: [{
      type: Input
    }],
    maximumScale: [{
      type: Input
    }],
    showLabels: [{
      type: Input
    }],
    labelSize: [{
      type: Input
    }],
    labelOffset: [{
      type: Input
    }],
    labelOrientation: [{
      type: Input
    }],
    labelPlacement: [{
      type: Input
    }],
    labelFontSize: [{
      type: Input
    }],
    labelFontFamily: [{
      type: Input
    }],
    labelColor: [{
      type: Input
    }],
    labelFontWeight: [{
      type: Input
    }],
    labelFontStyle: [{
      type: Input
    }],
    enablePanning: [{
      type: Input
    }],
    autoSizeMinimum: [{
      type: Input
    }],
    autoSizeMaximum: [{
      type: Input
    }],
    showFrame: [{
      type: Input
    }],
    frameInnerPadding: [{
      type: Input
    }],
    frameOuterPadding: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    onHighlightChanging: [{
      type: Output
    }],
    onHighlightChanged: [{
      type: Output
    }],
    onCursorChanging: [{
      type: Output
    }],
    onCursorChanged: [{
      type: Output
    }],
    onSelectionChanging: [{
      type: Output
    }],
    onSelectionChanged: [{
      type: Output
    }]
  });
})();
var FamConfig2 = class {
  constructor(config = {}) {
    this.navigationMode = NavigationMode2.Default;
    this.pageFitMode = PageFitMode2.FitToPage;
    this.minimalVisibility = Visibility2.Dot;
    this.minimumVisibleLevels = 0;
    this.orientationType = OrientationType2.Top;
    this.verticalAlignment = VerticalAlignmentType2.Middle;
    this.arrowsDirection = GroupByType2.None;
    this.showExtraArrows = true;
    this.extraArrowsMinimumSpace = 30;
    this.groupByType = GroupByType2.Children;
    this.alignBylevels = true;
    this.enableMatrixLayout = false;
    this.minimumMatrixSize = 4;
    this.maximumColumnsInMatrix = 6;
    this.hideGrandParentsConnectors = false;
    this.bevelSize = 4;
    this.elbowType = ElbowType2.Round;
    this.elbowDotSize = 4;
    this.emptyDiagramMessage = "Diagram is empty.";
    this.items = [];
    this.annotations = [];
    this.cursorItem = null;
    this.highlightItem = null;
    this.highlightGravityRadius = 40;
    this.selectedItems = [];
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.selectCheckBoxLabel = "Selected";
    this.selectionPathMode = SelectionPathMode2.None;
    this.neighboursSelectionMode = NeighboursSelectionMode2.ParentsAndChildren;
    this.templates = [];
    this.defaultTemplateName = null;
    this.defaultLabelAnnotationTemplate = null;
    this.hasButtons = Enabled2.Auto;
    this.buttonsTemplate = null;
    this.normalLevelShift = 20;
    this.dotLevelShift = 20;
    this.lineLevelShift = 10;
    this.normalItemsInterval = 10;
    this.dotItemsInterval = 1;
    this.lineItemsInterval = 2;
    this.cousinsIntervalMultiplier = 5;
    this.itemTitleFirstFontColor = "#ffffff";
    this.itemTitleSecondFontColor = "#000080";
    this.minimizedItemShapeType = ShapeType2.None;
    this.linesColor = "#c0c0c0";
    this.linesWidth = 1;
    this.linesType = LineType2.Solid;
    this.showNeigboursConnectorsHighlighted = false;
    this.highlightLinesColor = "#ff0000";
    this.highlightLinesWidth = 1;
    this.highlightLinesType = LineType2.Solid;
    this.linesPalette = [];
    this.calloutMaximumVisibility = Visibility2.Dot;
    this.showCallout = true;
    this.calloutPlacementOffset = 100;
    this.defaultCalloutTemplateName = null;
    this.calloutfillColor = "#000000";
    this.calloutBorderColor = null;
    this.calloutOffset = 4;
    this.calloutCornerRadius = 4;
    this.calloutPointerWidth = "10%";
    this.calloutLineWidth = 1;
    this.calloutOpacity = 0.2;
    this.buttonsPanelSize = 28;
    this.groupTitlePanelSize = 24;
    this.checkBoxPanelSize = 24;
    this.groupTitlePlacementType = AdviserPlacementType2.Left;
    this.groupTitleOrientation = TextOrientationType2.RotateRight;
    this.groupTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.groupTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.groupTitleFontSize = "12px";
    this.groupTitleFontFamily = "Arial";
    this.groupTitleColor = "#4169e1";
    this.groupTitleFontWeight = "normal";
    this.groupTitleFontStyle = "normal";
    this.groupTitleTemplate = null;
    this.levelTitlePanelSize = 24;
    this.levelTitlePlacementType = AdviserPlacementType2.Left;
    this.levelTitlePlaceInside = false;
    this.levelTitleOrientation = TextOrientationType2.Auto;
    this.levelTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.levelTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.levelTitleFontSize = "12px";
    this.levelTitleFontFamily = "Arial";
    this.levelTitleFontColor = "#ffffff";
    this.levelTitleColor = "#4169e1";
    this.levelTitleFontWeight = "normal";
    this.levelTitleFontStyle = "normal";
    this.levelTitleTemplate = null;
    this.levelBackgroundTemplate = null;
    this.distance = 3;
    this.scale = 1;
    this.minimumScale = 0.5;
    this.maximumScale = 1;
    this.showLabels = Enabled2.Auto;
    this.labelSize = new Size2(80, 24);
    this.labelOffset = 1;
    this.labelOrientation = TextOrientationType2.Horizontal;
    this.labelPlacement = PlacementType2.Top;
    this.labelFontSize = "10px";
    this.labelFontFamily = "Arial";
    this.labelColor = "#000000";
    this.labelFontWeight = "normal";
    this.labelFontStyle = "normal";
    this.enablePanning = true;
    this.autoSizeMinimum = new Size2(800, 600);
    this.autoSizeMaximum = new Size2(1024, 768);
    this.showFrame = false;
    this.frameInnerPadding = new Thickness2(2, 2, 2, 2);
    this.frameOuterPadding = new Thickness2(2, 2, 2, 2);
    this.padding = new Thickness2(10, 10, 10, 10);
    Object.assign(this, config);
  }
};
var FamDiagramComponent = class extends BaseDiagramComponent {
  constructor(host, zone) {
    super(host, zone, new TaskManagerFactory2(FamTaskManagerFactory));
    this.navigationMode = NavigationMode2.Default;
    this.pageFitMode = PageFitMode2.FitToPage;
    this.minimalVisibility = Visibility2.Dot;
    this.minimumVisibleLevels = 0;
    this.orientationType = OrientationType2.Top;
    this.verticalAlignment = VerticalAlignmentType2.Middle;
    this.arrowsDirection = GroupByType2.None;
    this.showExtraArrows = true;
    this.extraArrowsMinimumSpace = 30;
    this.groupByType = GroupByType2.Children;
    this.alignBylevels = true;
    this.enableMatrixLayout = false;
    this.minimumMatrixSize = 4;
    this.maximumColumnsInMatrix = 6;
    this.hideGrandParentsConnectors = false;
    this.bevelSize = 4;
    this.elbowType = ElbowType2.Round;
    this.elbowDotSize = 4;
    this.emptyDiagramMessage = "Diagram is empty.";
    this.items = [];
    this.annotations = [];
    this.cursorItem = null;
    this.highlightItem = null;
    this.highlightGravityRadius = 40;
    this.selectedItems = [];
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.selectCheckBoxLabel = "Selected";
    this.selectionPathMode = SelectionPathMode2.None;
    this.neighboursSelectionMode = NeighboursSelectionMode2.ParentsAndChildren;
    this.templates = [];
    this.defaultTemplateName = null;
    this.defaultLabelAnnotationTemplate = null;
    this.hasButtons = Enabled2.Auto;
    this.buttonsTemplate = null;
    this.normalLevelShift = 20;
    this.dotLevelShift = 20;
    this.lineLevelShift = 10;
    this.normalItemsInterval = 10;
    this.dotItemsInterval = 1;
    this.lineItemsInterval = 2;
    this.cousinsIntervalMultiplier = 5;
    this.itemTitleFirstFontColor = "#ffffff";
    this.itemTitleSecondFontColor = "#000080";
    this.minimizedItemShapeType = ShapeType2.None;
    this.linesColor = "#c0c0c0";
    this.linesWidth = 1;
    this.linesType = LineType2.Solid;
    this.showNeigboursConnectorsHighlighted = false;
    this.highlightLinesColor = "#ff0000";
    this.highlightLinesWidth = 1;
    this.highlightLinesType = LineType2.Solid;
    this.linesPalette = [];
    this.calloutMaximumVisibility = Visibility2.Dot;
    this.showCallout = true;
    this.calloutPlacementOffset = 100;
    this.defaultCalloutTemplateName = null;
    this.calloutfillColor = "#000000";
    this.calloutBorderColor = null;
    this.calloutOffset = 4;
    this.calloutCornerRadius = 4;
    this.calloutPointerWidth = "10%";
    this.calloutLineWidth = 1;
    this.calloutOpacity = 0.2;
    this.buttonsPanelSize = 28;
    this.groupTitlePanelSize = 24;
    this.checkBoxPanelSize = 24;
    this.groupTitlePlacementType = AdviserPlacementType2.Left;
    this.groupTitleOrientation = TextOrientationType2.RotateRight;
    this.groupTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.groupTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.groupTitleFontSize = "12px";
    this.groupTitleFontFamily = "Arial";
    this.groupTitleColor = "#4169e1";
    this.groupTitleFontWeight = "normal";
    this.groupTitleFontStyle = "normal";
    this.groupTitleTemplate = null;
    this.levelTitlePanelSize = 24;
    this.levelTitlePlacementType = AdviserPlacementType2.Left;
    this.levelTitlePlaceInside = false;
    this.levelTitleOrientation = TextOrientationType2.Auto;
    this.levelTitleVerticalAlignment = VerticalAlignmentType2.Middle;
    this.levelTitleHorizontalAlignment = HorizontalAlignmentType2.Center;
    this.levelTitleFontSize = "12px";
    this.levelTitleFontFamily = "Arial";
    this.levelTitleFontColor = "#ffffff";
    this.levelTitleColor = "#4169e1";
    this.levelTitleFontWeight = "normal";
    this.levelTitleFontStyle = "normal";
    this.levelTitleTemplate = null;
    this.levelBackgroundTemplate = null;
    this.distance = 3;
    this.scale = 1;
    this.minimumScale = 0.5;
    this.maximumScale = 1;
    this.showLabels = Enabled2.Auto;
    this.labelSize = new Size2(80, 24);
    this.labelOffset = 1;
    this.labelOrientation = TextOrientationType2.Horizontal;
    this.labelPlacement = PlacementType2.Top;
    this.labelFontSize = "10px";
    this.labelFontFamily = "Arial";
    this.labelColor = "#000000";
    this.labelFontWeight = "normal";
    this.labelFontStyle = "normal";
    this.enablePanning = true;
    this.autoSizeMinimum = new Size2(800, 600);
    this.autoSizeMaximum = new Size2(1024, 768);
    this.showFrame = false;
    this.frameInnerPadding = new Thickness2(2, 2, 2, 2);
    this.frameOuterPadding = new Thickness2(2, 2, 2, 2);
    this.padding = new Thickness2(10, 10, 10, 10);
    this.onHighlightChanging = new EventEmitter(false);
    this.onHighlightChanged = new EventEmitter();
    this.onCursorChanging = new EventEmitter(false);
    this.onCursorChanged = new EventEmitter();
    this.onSelectionChanging = new EventEmitter(false);
    this.onSelectionChanged = new EventEmitter();
  }
  ngOnChanges(changes) {
    var config = new FamConfig2(this);
    const {
      highlightItem,
      cursorItem,
      selectedItems
    } = config;
    this.state = __spreadProps(__spreadValues({}, this.state), {
      config,
      highlightItem,
      cursorItem,
      selectedItems,
      centerOnCursor: this.centerOnCursor
    });
    this.render();
  }
  _onHighlightChanging(event, itemId, newItemId) {
    var newEvent = new FamEventArgs2(__spreadProps(__spreadValues({}, this.getEventArgs(itemId, newItemId)), {
      event
    }));
    this.onHighlightChanging.emit(newEvent);
    return newEvent;
  }
  _onHighlightChanged(eventArgs) {
    this.onHighlightChanged.emit(eventArgs);
  }
  _onCursorChanging(event, itemId, newItemId) {
    var newEvent = new FamEventArgs2(__spreadProps(__spreadValues({}, this.getEventArgs(itemId, newItemId)), {
      event
    }));
    this.onCursorChanging.emit(newEvent);
    return newEvent;
  }
  _onCursorChanged(eventArgs) {
    this.onCursorChanged.emit(eventArgs);
  }
  _onSelectionChanging(event, selectedItems, newSelectedItems) {
    var newEvent = new SelectionEventArgs({
      selectedItems,
      newSelectedItems,
      event
    });
    this.onSelectionChanging.emit(newEvent);
    return newEvent;
  }
  _onSelectionChanged(eventArgs) {
    this.onSelectionChanged.emit(eventArgs);
  }
};
FamDiagramComponent.ɵfac = function FamDiagramComponent_Factory(t) {
  return new (t || FamDiagramComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
FamDiagramComponent.ɵcmp = ɵɵdefineComponent({
  type: FamDiagramComponent,
  selectors: [["fam-diagram"]],
  inputs: {
    navigationMode: "navigationMode",
    pageFitMode: "pageFitMode",
    minimalVisibility: "minimalVisibility",
    minimumVisibleLevels: "minimumVisibleLevels",
    orientationType: "orientationType",
    verticalAlignment: "verticalAlignment",
    arrowsDirection: "arrowsDirection",
    showExtraArrows: "showExtraArrows",
    extraArrowsMinimumSpace: "extraArrowsMinimumSpace",
    groupByType: "groupByType",
    alignBylevels: "alignBylevels",
    enableMatrixLayout: "enableMatrixLayout",
    minimumMatrixSize: "minimumMatrixSize",
    maximumColumnsInMatrix: "maximumColumnsInMatrix",
    hideGrandParentsConnectors: "hideGrandParentsConnectors",
    bevelSize: "bevelSize",
    elbowType: "elbowType",
    elbowDotSize: "elbowDotSize",
    emptyDiagramMessage: "emptyDiagramMessage",
    items: "items",
    annotations: "annotations",
    cursorItem: "cursorItem",
    highlightItem: "highlightItem",
    highlightGravityRadius: "highlightGravityRadius",
    selectedItems: "selectedItems",
    hasSelectorCheckbox: "hasSelectorCheckbox",
    selectCheckBoxLabel: "selectCheckBoxLabel",
    selectionPathMode: "selectionPathMode",
    neighboursSelectionMode: "neighboursSelectionMode",
    templates: "templates",
    defaultTemplateName: "defaultTemplateName",
    defaultLabelAnnotationTemplate: "defaultLabelAnnotationTemplate",
    hasButtons: "hasButtons",
    buttonsTemplate: "buttonsTemplate",
    normalLevelShift: "normalLevelShift",
    dotLevelShift: "dotLevelShift",
    lineLevelShift: "lineLevelShift",
    normalItemsInterval: "normalItemsInterval",
    dotItemsInterval: "dotItemsInterval",
    lineItemsInterval: "lineItemsInterval",
    cousinsIntervalMultiplier: "cousinsIntervalMultiplier",
    itemTitleFirstFontColor: "itemTitleFirstFontColor",
    itemTitleSecondFontColor: "itemTitleSecondFontColor",
    minimizedItemShapeType: "minimizedItemShapeType",
    linesColor: "linesColor",
    linesWidth: "linesWidth",
    linesType: "linesType",
    showNeigboursConnectorsHighlighted: "showNeigboursConnectorsHighlighted",
    highlightLinesColor: "highlightLinesColor",
    highlightLinesWidth: "highlightLinesWidth",
    highlightLinesType: "highlightLinesType",
    linesPalette: "linesPalette",
    calloutMaximumVisibility: "calloutMaximumVisibility",
    showCallout: "showCallout",
    calloutPlacementOffset: "calloutPlacementOffset",
    defaultCalloutTemplateName: "defaultCalloutTemplateName",
    calloutfillColor: "calloutfillColor",
    calloutBorderColor: "calloutBorderColor",
    calloutOffset: "calloutOffset",
    calloutCornerRadius: "calloutCornerRadius",
    calloutPointerWidth: "calloutPointerWidth",
    calloutLineWidth: "calloutLineWidth",
    calloutOpacity: "calloutOpacity",
    buttonsPanelSize: "buttonsPanelSize",
    groupTitlePanelSize: "groupTitlePanelSize",
    checkBoxPanelSize: "checkBoxPanelSize",
    groupTitlePlacementType: "groupTitlePlacementType",
    groupTitleOrientation: "groupTitleOrientation",
    groupTitleVerticalAlignment: "groupTitleVerticalAlignment",
    groupTitleHorizontalAlignment: "groupTitleHorizontalAlignment",
    groupTitleFontSize: "groupTitleFontSize",
    groupTitleFontFamily: "groupTitleFontFamily",
    groupTitleColor: "groupTitleColor",
    groupTitleFontWeight: "groupTitleFontWeight",
    groupTitleFontStyle: "groupTitleFontStyle",
    groupTitleTemplate: "groupTitleTemplate",
    levelTitlePanelSize: "levelTitlePanelSize",
    levelTitlePlacementType: "levelTitlePlacementType",
    levelTitlePlaceInside: "levelTitlePlaceInside",
    levelTitleOrientation: "levelTitleOrientation",
    levelTitleVerticalAlignment: "levelTitleVerticalAlignment",
    levelTitleHorizontalAlignment: "levelTitleHorizontalAlignment",
    levelTitleFontSize: "levelTitleFontSize",
    levelTitleFontFamily: "levelTitleFontFamily",
    levelTitleFontColor: "levelTitleFontColor",
    levelTitleColor: "levelTitleColor",
    levelTitleFontWeight: "levelTitleFontWeight",
    levelTitleFontStyle: "levelTitleFontStyle",
    levelTitleTemplate: "levelTitleTemplate",
    levelBackgroundTemplate: "levelBackgroundTemplate",
    distance: "distance",
    scale: "scale",
    minimumScale: "minimumScale",
    maximumScale: "maximumScale",
    showLabels: "showLabels",
    labelSize: "labelSize",
    labelOffset: "labelOffset",
    labelOrientation: "labelOrientation",
    labelPlacement: "labelPlacement",
    labelFontSize: "labelFontSize",
    labelFontFamily: "labelFontFamily",
    labelColor: "labelColor",
    labelFontWeight: "labelFontWeight",
    labelFontStyle: "labelFontStyle",
    enablePanning: "enablePanning",
    autoSizeMinimum: "autoSizeMinimum",
    autoSizeMaximum: "autoSizeMaximum",
    showFrame: "showFrame",
    frameInnerPadding: "frameInnerPadding",
    frameOuterPadding: "frameOuterPadding",
    padding: "padding"
  },
  outputs: {
    onHighlightChanging: "onHighlightChanging",
    onHighlightChanged: "onHighlightChanged",
    onCursorChanging: "onCursorChanging",
    onCursorChanged: "onCursorChanged",
    onSelectionChanging: "onSelectionChanging",
    onSelectionChanged: "onSelectionChanged"
  },
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 14,
  vars: 13,
  consts: [["controlPanelRef", ""], ["scrollPanelRef", ""], ["mousePanelRef", ""], ["placeholderRef", ""], ["layerTemplate", ""], ["frameMousePanelRef", ""], ["framePlaceholderRef", ""], ["titlesMousePanelRef", ""], ["titlesPlaceholderRef", ""], ["calloutPlaceholderRef", ""], ["tabIndex", "0", 1, "control-panel", 3, "keydown", "ngStyle"], ["class", "frame-mouse-panel", 3, "ngStyle", "click", "mousemove", 4, "ngIf"], ["class", "titles-mouse-panel", 3, "ngStyle", "mousemove", "click", 4, "ngIf"], [1, "scroll-panel", 3, "scroll", "ngStyle", "scrollLeft", "scrollTop"], [1, "mouse-panel", 3, "mousemove", "click", "change", "ngStyle"], [1, "placeholder", 3, "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "callout-placeholder", 3, "ngStyle", 4, "ngIf"], [1, "frame-mouse-panel", 3, "click", "mousemove", "ngStyle"], [1, "frame-placeholder", 3, "ngStyle"], [1, "titles-mouse-panel", 3, "mousemove", "click", "ngStyle"], [1, "titles-placeholder", 3, "ngStyle"], [1, "callout-placeholder", 3, "ngStyle"], ["class", "layer", 4, "ngFor", "ngForOf"], [1, "layer"], [4, "ngIf"], ["class", "label", 3, "ngStyle", 4, "ngFor", "ngForOf"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle", 4, "ngIf"], ["class", "template", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "label", 3, "ngStyle"], [3, "width", "height", "orientation", "horizontalAlignment", "verticalAlignment"], ["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", 3, "ngStyle"], [3, "ngStyle", 4, "ngFor", "ngForOf"], [3, "ngStyle"], [1, "template", 3, "ngStyle"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "itemConfig", "itemTitleFirstFontColor", "itemTitleSecondFontColor"], [3, "id", "isSelected", "label"], [3, "options", "itemConfig", "width", "height"], [3, "templateConfig"], [3, "options", "annotationConfig", "width", "height"], [3, "annotationConfig"], [1, "label-annotation"]],
  template: function FamDiagramComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 10, 0);
      ɵɵlistener("keydown", function FamDiagramComponent_Template_div_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onKeyDown($event));
      });
      ɵɵtemplate(2, FamDiagramComponent_div_2_Template, 5, 6, "div", 11)(3, FamDiagramComponent_div_3_Template, 5, 6, "div", 12);
      ɵɵelementStart(4, "div", 13, 1);
      ɵɵlistener("scroll", function FamDiagramComponent_Template_div_scroll_4_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onScroll($event));
      });
      ɵɵelementStart(6, "div", 14, 2);
      ɵɵlistener("mousemove", function FamDiagramComponent_Template_div_mousemove_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onMouseMove($event));
      })("click", function FamDiagramComponent_Template_div_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      })("change", function FamDiagramComponent_Template_div_change_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onCheckboxChange($event));
      });
      ɵɵelementStart(8, "div", 15, 3);
      ɵɵtemplate(10, FamDiagramComponent_ng_container_10_Template, 1, 0, "ng-container", 16)(11, FamDiagramComponent_div_11_Template, 3, 5, "div", 17);
      ɵɵelementEnd()()()();
      ɵɵtemplate(12, FamDiagramComponent_ng_template_12_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const layerTemplate_r4 = ɵɵreference(13);
      ɵɵproperty("ngStyle", ctx.controlPanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.framePlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.titlesPlaceholder);
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx.scrollPanelStyle)("scrollLeft", ctx.placeholderOffset ? ctx.placeholderOffset.x : void 0)("scrollTop", ctx.placeholderOffset ? ctx.placeholderOffset.y : void 0);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.mousePanelStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", ctx.placeholderStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", layerTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c14, ctx.placeholder));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.calloutPlaceholder);
    }
  },
  dependencies: [RotatedText, ItemComponent, CheckboxComponent, GroupTitleComponent, CursorComponent, HighlightComponent, DotHighlightComponent, LevelTitleComponent, LevelBackgroundComponent, NgStyle, NgIf, NgTemplateOutlet, NgForOf, NgSwitch, NgSwitchCase, NgSwitchDefault],
  styles: [_c16]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FamDiagramComponent, [{
    type: Component,
    args: [{
      selector: "fam-diagram",
      template: `<!-- root control panel -->\r
<div #controlPanelRef\r
  class="control-panel"\r
  [ngStyle]="controlPanelStyle"\r
  (keydown)="onKeyDown($event)"\r
  tabIndex="0"\r
>\r
  <div *ngIf="framePlaceholder"\r
    #frameMousePanelRef\r
    class="frame-mouse-panel"\r
    [ngStyle]="frameMousePanelStyle"\r
    (click)="onFrameClick($event)"\r
    (mousemove)="onFrameMouseMove($event)"\r
  >\r
    <div #framePlaceholderRef\r
      class="frame-placeholder" \r
      [ngStyle]="framePlaceholderStyle"\r
    >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: framePlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div *ngIf="titlesPlaceholder"\r
    #titlesMousePanelRef\r
    class="titles-mouse-panel"\r
    [ngStyle]="titlesMousePanelStyle"\r
    (mousemove)="onFrameMouseMove($event)"\r
    (click)="onFrameClick($event)"\r
  >\r
    <div #titlesPlaceholderRef\r
      [ngStyle]="titlesPlaceholderStyle"\r
      class="titles-placeholder"\r
     >\r
      <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: titlesPlaceholder}"></ng-container>\r
    </div>\r
  </div>\r
  <div\r
    #scrollPanelRef\r
    class="scroll-panel"\r
    [ngStyle]="scrollPanelStyle"\r
    (scroll)="onScroll($event)"\r
    [scrollLeft]="placeholderOffset ? placeholderOffset.x : undefined"\r
    [scrollTop]="placeholderOffset ? placeholderOffset.y : undefined"\r
  >\r
    <div #mousePanelRef\r
      class="mouse-panel"\r
      [ngStyle]="mousePanelStyle"\r
      (mousemove)="onMouseMove($event)"\r
      (click)="onClick($event)"\r
      (change)="onCheckboxChange($event)"\r
    >\r
      <div #placeholderRef\r
        class="placeholder"\r
        [ngStyle]="placeholderStyle"\r
      >\r
        <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: placeholder}"></ng-container>\r
        <div *ngIf="calloutPlaceholder"\r
          #calloutPlaceholderRef\r
          class="callout-placeholder"\r
          [ngStyle]="calloutPlaceholderStyle"\r
        >\r
          <ng-container *ngTemplateOutlet="layerTemplate; context: {$implicit: calloutPlaceholder}"></ng-container>\r
        </div>\r
      </div>\r
    </div>\r
  </div>\r
</div>\r
\r
<!--Templates: -->\r
<ng-template #layerTemplate let-placeholder>\r
  <div *ngFor="let layer of placeholder.layers" class="layer">\r
    <ng-container *ngIf="layer">\r
      <div *ngFor="let label of layer.labels" class="label" [ngStyle]= "label.style">\r
        <rotated-text\r
          [width]="label.width"\r
          [height]="label.height"\r
          [orientation]="label.orientation"\r
          [horizontalAlignment]="label.horizontalAlignment"\r
          [verticalAlignment]="label.verticalAlignment"\r
        >{{label.label}}</rotated-text>\r
      </div>\r
      <svg \r
        *ngIf="layer.polylines.length > 0"\r
        attr.height.px="{{placeholder.size.height}}"\r
        attr.width.px="{{placeholder.size.width}}"\r
        xmlns="http://www.w3.org/2000/svg"\r
        xmlns:xlink="http://www.w3.org/1999/xlink"\r
        [ngStyle]="{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}"\r
      >\r
        <path *ngFor="let path of layer.polylines" [attr.d]="path.data" [ngStyle]="path.style"></path>\r
      </svg>\r
      <div *ngFor="let item of layer.items;" class="template" [ngStyle]="item.style">\r
        <ng-container [ngSwitch]="item.templateType">\r
          <ng-container *ngSwitchCase="'itemTemplate'">\r
            <bp-item [itemConfig]="item.context.context" [itemTitleFirstFontColor]="item.context.itemTitleFirstFontColor" [itemTitleSecondFontColor]="item.context.itemTitleSecondFontColor"></bp-item>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'checkboxTemplate'">\r
            <bp-checkbox [id]="item.context.id" [isSelected]="item.context.isSelected" [label]="item.context.selectCheckBoxLabel"></bp-checkbox>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'groupTitleTemplate'">\r
            <bp-group-title [options]="item.context" [itemConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-group-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'cursorTemplate'">\r
            <bp-cursor [templateConfig]="item.context.templateConfig"></bp-cursor>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'highlightTemplate'">\r
            <bp-highlight [templateConfig]="item.context.templateConfig"></bp-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'dotHighlightTemplate'">\r
            <bp-dot-highlight [templateConfig]="item.context.templateConfig"></bp-dot-highlight>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelTitleTemplate'">\r
            <bp-level-title [options]="item.context" [annotationConfig]="item.context.context" [width]="item.context.width" [height]="item.context.height"></bp-level-title>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'levelBackgroundTemplate'">\r
            <bp-level-background [annotationConfig]="item.context.context"></bp-level-background>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'labelAnnotationTemplate'">\r
            <div class="label-annotation">{{item.context.context.title}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchCase="'annotationLabelTemplate'">\r
            <div class="label-annotation">{{item.context.context.label}}</div>\r
          </ng-container>\r
          <ng-container *ngSwitchDefault>\r
            <ng-container *ngTemplateOutlet="item.templateRef; context: item.context"></ng-container>\r
          </ng-container>\r
        </ng-container>\r
      </div>\r
    </ng-container>\r
  </div>\r
</ng-template>\r
`,
      styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    navigationMode: [{
      type: Input
    }],
    pageFitMode: [{
      type: Input
    }],
    minimalVisibility: [{
      type: Input
    }],
    minimumVisibleLevels: [{
      type: Input
    }],
    orientationType: [{
      type: Input
    }],
    verticalAlignment: [{
      type: Input
    }],
    arrowsDirection: [{
      type: Input
    }],
    showExtraArrows: [{
      type: Input
    }],
    extraArrowsMinimumSpace: [{
      type: Input
    }],
    groupByType: [{
      type: Input
    }],
    alignBylevels: [{
      type: Input
    }],
    enableMatrixLayout: [{
      type: Input
    }],
    minimumMatrixSize: [{
      type: Input
    }],
    maximumColumnsInMatrix: [{
      type: Input
    }],
    hideGrandParentsConnectors: [{
      type: Input
    }],
    bevelSize: [{
      type: Input
    }],
    elbowType: [{
      type: Input
    }],
    elbowDotSize: [{
      type: Input
    }],
    emptyDiagramMessage: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    annotations: [{
      type: Input
    }],
    cursorItem: [{
      type: Input
    }],
    highlightItem: [{
      type: Input
    }],
    highlightGravityRadius: [{
      type: Input
    }],
    selectedItems: [{
      type: Input
    }],
    hasSelectorCheckbox: [{
      type: Input
    }],
    selectCheckBoxLabel: [{
      type: Input
    }],
    selectionPathMode: [{
      type: Input
    }],
    neighboursSelectionMode: [{
      type: Input
    }],
    templates: [{
      type: Input
    }],
    defaultTemplateName: [{
      type: Input
    }],
    defaultLabelAnnotationTemplate: [{
      type: Input
    }],
    hasButtons: [{
      type: Input
    }],
    buttonsTemplate: [{
      type: Input
    }],
    normalLevelShift: [{
      type: Input
    }],
    dotLevelShift: [{
      type: Input
    }],
    lineLevelShift: [{
      type: Input
    }],
    normalItemsInterval: [{
      type: Input
    }],
    dotItemsInterval: [{
      type: Input
    }],
    lineItemsInterval: [{
      type: Input
    }],
    cousinsIntervalMultiplier: [{
      type: Input
    }],
    itemTitleFirstFontColor: [{
      type: Input
    }],
    itemTitleSecondFontColor: [{
      type: Input
    }],
    minimizedItemShapeType: [{
      type: Input
    }],
    linesColor: [{
      type: Input
    }],
    linesWidth: [{
      type: Input
    }],
    linesType: [{
      type: Input
    }],
    showNeigboursConnectorsHighlighted: [{
      type: Input
    }],
    highlightLinesColor: [{
      type: Input
    }],
    highlightLinesWidth: [{
      type: Input
    }],
    highlightLinesType: [{
      type: Input
    }],
    linesPalette: [{
      type: Input
    }],
    calloutMaximumVisibility: [{
      type: Input
    }],
    showCallout: [{
      type: Input
    }],
    calloutPlacementOffset: [{
      type: Input
    }],
    defaultCalloutTemplateName: [{
      type: Input
    }],
    calloutfillColor: [{
      type: Input
    }],
    calloutBorderColor: [{
      type: Input
    }],
    calloutOffset: [{
      type: Input
    }],
    calloutCornerRadius: [{
      type: Input
    }],
    calloutPointerWidth: [{
      type: Input
    }],
    calloutLineWidth: [{
      type: Input
    }],
    calloutOpacity: [{
      type: Input
    }],
    buttonsPanelSize: [{
      type: Input
    }],
    groupTitlePanelSize: [{
      type: Input
    }],
    checkBoxPanelSize: [{
      type: Input
    }],
    groupTitlePlacementType: [{
      type: Input
    }],
    groupTitleOrientation: [{
      type: Input
    }],
    groupTitleVerticalAlignment: [{
      type: Input
    }],
    groupTitleHorizontalAlignment: [{
      type: Input
    }],
    groupTitleFontSize: [{
      type: Input
    }],
    groupTitleFontFamily: [{
      type: Input
    }],
    groupTitleColor: [{
      type: Input
    }],
    groupTitleFontWeight: [{
      type: Input
    }],
    groupTitleFontStyle: [{
      type: Input
    }],
    groupTitleTemplate: [{
      type: Input
    }],
    levelTitlePanelSize: [{
      type: Input
    }],
    levelTitlePlacementType: [{
      type: Input
    }],
    levelTitlePlaceInside: [{
      type: Input
    }],
    levelTitleOrientation: [{
      type: Input
    }],
    levelTitleVerticalAlignment: [{
      type: Input
    }],
    levelTitleHorizontalAlignment: [{
      type: Input
    }],
    levelTitleFontSize: [{
      type: Input
    }],
    levelTitleFontFamily: [{
      type: Input
    }],
    levelTitleFontColor: [{
      type: Input
    }],
    levelTitleColor: [{
      type: Input
    }],
    levelTitleFontWeight: [{
      type: Input
    }],
    levelTitleFontStyle: [{
      type: Input
    }],
    levelTitleTemplate: [{
      type: Input
    }],
    levelBackgroundTemplate: [{
      type: Input
    }],
    distance: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    minimumScale: [{
      type: Input
    }],
    maximumScale: [{
      type: Input
    }],
    showLabels: [{
      type: Input
    }],
    labelSize: [{
      type: Input
    }],
    labelOffset: [{
      type: Input
    }],
    labelOrientation: [{
      type: Input
    }],
    labelPlacement: [{
      type: Input
    }],
    labelFontSize: [{
      type: Input
    }],
    labelFontFamily: [{
      type: Input
    }],
    labelColor: [{
      type: Input
    }],
    labelFontWeight: [{
      type: Input
    }],
    labelFontStyle: [{
      type: Input
    }],
    enablePanning: [{
      type: Input
    }],
    autoSizeMinimum: [{
      type: Input
    }],
    autoSizeMaximum: [{
      type: Input
    }],
    showFrame: [{
      type: Input
    }],
    frameInnerPadding: [{
      type: Input
    }],
    frameOuterPadding: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    onHighlightChanging: [{
      type: Output
    }],
    onHighlightChanged: [{
      type: Output
    }],
    onCursorChanging: [{
      type: Output
    }],
    onCursorChanged: [{
      type: Output
    }],
    onSelectionChanging: [{
      type: Output
    }],
    onSelectionChanged: [{
      type: Output
    }]
  });
})();
var BasicPrimitivesService = class {
  constructor() {
  }
};
BasicPrimitivesService.ɵfac = function BasicPrimitivesService_Factory(t) {
  return new (t || BasicPrimitivesService)();
};
BasicPrimitivesService.ɵprov = ɵɵdefineInjectable({
  token: BasicPrimitivesService,
  factory: BasicPrimitivesService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BasicPrimitivesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var BasicPrimitivesModule = class {
};
BasicPrimitivesModule.ɵfac = function BasicPrimitivesModule_Factory(t) {
  return new (t || BasicPrimitivesModule)();
};
BasicPrimitivesModule.ɵmod = ɵɵdefineNgModule({
  type: BasicPrimitivesModule,
  declarations: [BaseDiagramComponent, OrgDiagramComponent, FamDiagramComponent, RotatedText, ItemComponent, CursorComponent, HighlightComponent, DotHighlightComponent, CheckboxComponent, GroupTitleComponent, LevelBackgroundComponent, LevelTitleComponent],
  imports: [CommonModule],
  exports: [OrgDiagramComponent, FamDiagramComponent, RotatedText]
});
BasicPrimitivesModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BasicPrimitivesModule, [{
    type: NgModule,
    args: [{
      declarations: [BaseDiagramComponent, OrgDiagramComponent, FamDiagramComponent, RotatedText, ItemComponent, CursorComponent, HighlightComponent, DotHighlightComponent, CheckboxComponent, GroupTitleComponent, LevelBackgroundComponent, LevelTitleComponent],
      imports: [CommonModule],
      exports: [OrgDiagramComponent, FamDiagramComponent, RotatedText]
    }]
  }], null, null);
})();
var FamItemConfig2 = class {
  constructor(config = {}) {
    this.id = null;
    this.parents = [];
    this.title = null;
    this.description = null;
    this.image = null;
    this.context = null;
    this.itemTitleColor = "#4169e1";
    this.minimizedItemShapeType = null;
    this.groupTitle = null;
    this.groupTitleColor = "#4169e1";
    this.isActive = true;
    this.hasSelectorCheckbox = Enabled2.Auto;
    this.hasButtons = Enabled2.Auto;
    this.templateName = null;
    this.showCallout = Enabled2.Auto;
    this.calloutTemplateName = null;
    this.label = null;
    this.showLabel = Enabled2.Auto;
    this.labelSize = null;
    this.labelOrientation = TextOrientationType2.Auto;
    this.labelPlacement = PlacementType2.Auto;
    this.primaryParent = null;
    this.relativeItem = null;
    this.position = null;
    this.placementType = AdviserPlacementType2.Right;
    this.matrixId = null;
    this.addToMatrix = true;
    Object.assign(this, config);
  }
};
var PaletteItemConfig2 = class {
  constructor(config = {}) {
    this.lineColor = "#c0c0c0";
    this.lineWidth = 1;
    this.lineType = LineType2.Solid;
    Object.assign(this, config);
  }
};
var ConnectorAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.Connector;
    this.zOrderType = ZOrderType2.Foreground;
    this.fromItem = null;
    this.toItem = null;
    this.connectorShapeType = ConnectorShapeType2.OneWay;
    this.connectorPlacementType = ConnectorPlacementType2.Offbeat;
    this.labelPlacementType = ConnectorLabelPlacementType2.Between;
    this.offset = new Thickness2(0, 0, 0, 0);
    this.lineWidth = 2;
    this.color = "#000000";
    this.lineType = LineType2.Solid;
    this.selectItems = true;
    this.label = null;
    this.size = new Size2(60, 30);
    Object.assign(this, config);
  }
};
var HighlightPathAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.HighlightPath;
    this.zOrderType = ZOrderType2.Foreground;
    this.items = [];
    this.lineWidth = 2;
    this.color = "#ff0000";
    this.lineType = LineType2.Solid;
    this.opacity = 1;
    this.showArrows = true;
    this.selectItems = false;
    Object.assign(this, config);
  }
};
var LabelAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.Label;
    this.fromItem = null;
    this.toItems = [];
    this.title = null;
    this.itemTitleColor = "#4169e1";
    this.templateName = null;
    Object.assign(this, config);
  }
};
var ShapeAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.Shape;
    this.zOrderType = ZOrderType2.Auto;
    this.items = [];
    this.shapeType = ShapeType2.Rectangle;
    this.offset = new Thickness2(0, 0, 0, 0);
    this.lineWidth = 2;
    this.cornerRadius = "10%";
    this.opacity = 1;
    this.borderColor = null;
    this.fillColor = null;
    this.lineType = LineType2.Solid;
    this.selectItems = false;
    this.label = null;
    this.labelSize = new Size2(60, 30);
    this.labelPlacement = PlacementType2.Auto;
    this.labelOffset = 4;
    Object.assign(this, config);
  }
};
var BackgroundAnnotationConfig2 = class {
  constructor(config = {}) {
    this.annotationType = AnnotationType2.Background;
    this.items = [];
    this.includeChildren = false;
    this.zOrderType = ZOrderType2.Auto;
    this.offset = new Thickness2(18, 18, 18, 18);
    this.lineWidth = 2;
    this.opacity = 1;
    this.borderColor = null;
    this.fillColor = null;
    this.lineType = LineType2.Solid;
    this.selectItems = false;
    Object.assign(this, config);
  }
};
export {
  AdviserPlacementType2 as AdviserPlacementType,
  AnnotationType2 as AnnotationType,
  BackgroundAnnotationConfig2 as BackgroundAnnotationConfig,
  BasicPrimitivesModule,
  BasicPrimitivesService,
  ChildrenPlacementType2 as ChildrenPlacementType,
  Colors2 as Colors,
  ConnectorAnnotationConfig2 as ConnectorAnnotationConfig,
  ConnectorLabelPlacementType2 as ConnectorLabelPlacementType,
  ConnectorPlacementType2 as ConnectorPlacementType,
  ConnectorShapeType2 as ConnectorShapeType,
  ConnectorStyleType2 as ConnectorStyleType,
  ConnectorType2 as ConnectorType,
  ElbowType2 as ElbowType,
  Enabled2 as Enabled,
  FamDiagramComponent,
  FamItemConfig2 as FamItemConfig,
  GroupByType2 as GroupByType,
  HighlightPathAnnotationConfig2 as HighlightPathAnnotationConfig,
  HorizontalAlignmentType2 as HorizontalAlignmentType,
  ItemType2 as ItemType,
  LabelAnnotationConfig2 as LabelAnnotationConfig,
  LabelType2 as LabelType,
  Layers2 as Layers,
  LevelAnnotationConfig2 as LevelAnnotationConfig,
  LineType2 as LineType,
  NavigationMode2 as NavigationMode,
  NeighboursSelectionMode2 as NeighboursSelectionMode,
  OrgDiagramComponent,
  OrgItemConfig2 as OrgItemConfig,
  OrientationType2 as OrientationType,
  PageFitMode2 as PageFitMode,
  PaletteItemConfig2 as PaletteItemConfig,
  PlacementType2 as PlacementType,
  Rect2 as Rect,
  RenderingMode2 as RenderingMode,
  RotatedText,
  SegmentType2 as SegmentType,
  SelectionPathMode2 as SelectionPathMode,
  ShapeAnnotationConfig2 as ShapeAnnotationConfig,
  ShapeType2 as ShapeType,
  SideFlag2 as SideFlag,
  Size2 as Size,
  TemplateConfig2 as TemplateConfig,
  TextOrientationType2 as TextOrientationType,
  Thickness2 as Thickness,
  UpdateMode2 as UpdateMode,
  VectorRelationType2 as VectorRelationType,
  VerticalAlignmentType2 as VerticalAlignmentType,
  Visibility2 as Visibility,
  ZOrderType2 as ZOrderType
};
//# sourceMappingURL=ngx-basic-primitives.js.map
